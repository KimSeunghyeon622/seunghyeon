This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/agents/prd-agent.md
.claude/agents/tdd-agent.md
.claude/agents/trd-agent.md
.claude/agents/ux-ui-agent.md
.claude/docs/skills-guide.md
.claude/docs/sub-agents-guide.md
.claude/settings.local.json
.claude/skills/api-spec/SKILL.md
.claude/skills/create-agent/SKILL.md
.claude/skills/deploy-strategy/SKILL.md
.claude/skills/erd/SKILL.md
.claude/skills/frontend-design/SKILL.md
.claude/skills/ia-db/SKILL.md
.claude/skills/supabase-helper/SKILL.md
.claude/skills/test-plan/SKILL.md
.claude/skills/webapp-testing/SKILL.md
.gitignore
app/.gitignore
app/app.json
app/App.tsx
app/assets/images/android-icon-background.png
app/assets/images/android-icon-foreground.png
app/assets/images/android-icon-monochrome.png
app/assets/images/favicon.png
app/assets/images/icon.png
app/assets/images/partial-react-logo.png
app/assets/images/react-logo.png
app/assets/images/react-logo@2x.png
app/assets/images/react-logo@3x.png
app/assets/images/splash-icon.png
app/components/external-link.tsx
app/components/haptic-tab.tsx
app/components/hello-wave.tsx
app/components/parallax-scroll-view.tsx
app/components/themed-text.tsx
app/components/themed-view.tsx
app/components/ui/collapsible.tsx
app/components/ui/icon-symbol.ios.tsx
app/components/ui/icon-symbol.tsx
app/constants/theme.ts
app/eslint.config.js
app/hooks/use-color-scheme.ts
app/hooks/use-color-scheme.web.ts
app/hooks/use-theme-color.ts
app/index.js
app/package.json
app/README.md
app/scripts/reset-project.js
app/src/lib/supabase.ts
app/src/screens/ConsumerSignupScreen.tsx
app/src/screens/HomeScreen.tsx
app/src/screens/LoginScreen.tsx
app/src/screens/MyPageScreen.tsx
app/src/screens/MyReservations.tsx
app/src/screens/ProfileEditScreen.tsx
app/src/screens/ReservationScreen.tsx
app/src/screens/ReviewScreen.tsx
app/src/screens/ReviewWrite.tsx
app/src/screens/SignupScreen.tsx
app/src/screens/SignupTypeScreen.tsx
app/src/screens/StoreCashHistory.tsx
app/src/screens/StoreCashManagement.tsx
app/src/screens/StoreDashboard.tsx
app/src/screens/StoreDetail.tsx
app/src/screens/StoreInfoManagement.tsx
app/src/screens/StoreList.tsx
app/src/screens/StoreListHome.tsx
app/src/screens/StoreListHomeWithSearch.tsx
app/src/screens/StoreOperatingHoursScreen.tsx
app/src/screens/StoreProductManagement.tsx
app/src/screens/StoreRegularCustomers.tsx
app/src/screens/StoreReservationManagement.tsx
app/src/screens/StoreReviewManagement.tsx
app/src/screens/StoreReviewManagementWithReply.tsx
app/src/screens/StoreSignupScreen.tsx
app/src/stores/authStore.ts
app/src/stores/index.ts
app/src/stores/navigationStore.ts
app/src/stores/selectionStore.ts
app/tsconfig.json
CLAUDE.md
docs/plans/.gitkeep
docs/PRD.md
docs/PROJECT-ANALYSIS-REPORT.md
docs/requirements/경쟁사 분석 및 기타 메모.txt
docs/requirements/앱 사용자 시나리오 초안.txt
docs/supabase-cleanup-all.sql
docs/SUPABASE-CLEANUP.md
docs/supabase-final-fix.sql
docs/Test-Plan.md
docs/TRD.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(tree:*)"
    ]
  }
}
</file>

<file path=".claude/skills/frontend-design/SKILL.md">
---
name: frontend-design
description: 고품질 프론트엔드 UI를 디자인합니다. 컴포넌트, 화면, 스타일링 작업 시 사용하세요. React Native/Expo 앱에 최적화되어 있습니다.
license: Based on Anthropic Skills (MIT)
---

# Frontend Design 스킬

고품질의 프론트엔드 인터페이스를 생성합니다. 일반적인 "AI 스타일" 미학을 피하고, 독창적이고 세련된 UI를 구현합니다.

## 적용 대상

- React Native 컴포넌트
- Expo 앱 화면
- 스타일링/UI 개선 작업
- 랜딩 페이지, 대시보드, 폼 등

## 디자인 사고 프로세스

코딩 전에 **대담한 미적 방향**을 결정합니다:

### 1. 목적 파악
- 이 인터페이스가 해결하는 문제는?
- 사용자는 누구인가?

### 2. 톤 선택 (하나를 명확히)
- **미니멀**: 극도로 절제된, 여백 중심
- **맥시멀리스트**: 풍부한 요소, 레이어
- **레트로 퓨처리스틱**: 복고풍 + 미래적
- **오가닉/자연적**: 유기적 형태, 자연 색상
- **럭셔리/정제된**: 고급스러운, 세련된
- **플레이풀**: 장난스러운, 밝은
- **에디토리얼**: 잡지 스타일
- **브루탈리스트**: 날것의, 강렬한
- **아트데코**: 기하학적, 대칭적
- **소프트/파스텔**: 부드러운, 연한

### 3. 차별화 포인트
- 무엇이 이 UI를 **기억에 남게** 만드는가?
- 사용자가 기억할 **하나의 요소**는?

## 프론트엔드 미학 가이드라인

### 타이포그래피
```
❌ 피할 것: Arial, Inter, Roboto, 시스템 기본 폰트
✅ 추구할 것: 독특하고 개성 있는 폰트 조합
```

**React Native 권장 폰트:**
- 디스플레이: Poppins, Montserrat, Playfair Display
- 본문: Nunito, Open Sans, Lato
- expo-google-fonts 패키지 활용

### 색상 & 테마
```javascript
// ❌ 피할 것: 흰 배경에 보라색 그라데이션 (AI 클리셰)
// ✅ 추구할 것: 의도적인 색상 팔레트

const colors = {
  // 주요 색상 (대담하게)
  primary: '#00D563',    // 브랜드 그린
  secondary: '#1A1A2E',  // 깊은 네이비

  // 악센트 (포인트)
  accent: '#FF6B6B',

  // 배경 (분위기)
  background: '#FAFAFA',
  surface: '#FFFFFF',
};
```

### 모션 & 애니메이션
```javascript
// React Native Reanimated 활용
import Animated, {
  FadeInUp,
  FadeInDown,
  SlideInRight
} from 'react-native-reanimated';

// 페이지 진입 시 스태거드 애니메이션
<Animated.View entering={FadeInUp.delay(100).duration(400)}>
  <Title />
</Animated.View>
<Animated.View entering={FadeInUp.delay(200).duration(400)}>
  <Subtitle />
</Animated.View>
```

### 공간 구성
- **비대칭** 레이아웃 고려
- **여백**을 두려워하지 않기
- **오버랩** 요소로 깊이감
- **그리드 깨기** 요소로 시선 집중

### 시각적 디테일
```javascript
// 그림자로 깊이감
const cardShadow = {
  shadowColor: '#000',
  shadowOffset: { width: 0, height: 4 },
  shadowOpacity: 0.1,
  shadowRadius: 12,
  elevation: 5,
};

// 그라데이션 배경
import { LinearGradient } from 'expo-linear-gradient';

<LinearGradient
  colors={['#667eea', '#764ba2']}
  style={styles.gradientBackground}
/>
```

## 절대 피할 것

```
❌ 일반적인 AI 미학:
- Inter, Roboto, Arial 폰트
- 흰 배경 + 보라색 그라데이션
- 예측 가능한 레이아웃
- 맥락 없는 쿠키커터 디자인
- 모든 프로젝트에서 같은 스타일
```

## 프로젝트별 적용

### 재고 할인 중개 플랫폼 (현재 프로젝트)
```
톤: 친근한 + 신뢰감
색상: 그린(#00D563) 중심, 따뜻한 톤
타이포: 둥근 산세리프 (친근함)
모션: 부드러운 페이드, 바운스
특징: 할인율 강조, 음식 사진 중심
```

## 구현 체크리스트

- [ ] 명확한 미적 방향 결정
- [ ] 색상 팔레트 정의 (3-5색)
- [ ] 폰트 조합 선택 (2개)
- [ ] 핵심 컴포넌트 스타일링
- [ ] 애니메이션 추가
- [ ] 다크모드 고려 (선택)
- [ ] 접근성 확인

## 참고

- PRD: `docs/PRD.md`
- TRD: `docs/TRD.md` (7장 코드 가이드라인)

---

**기억하세요**: Claude는 뛰어난 창의적 작업이 가능합니다. 독창적인 비전에 완전히 몰입하세요.
</file>

<file path=".claude/skills/supabase-helper/SKILL.md">
---
name: supabase-helper
description: Supabase DB 관리를 도와줍니다. 테이블 생성, RLS 정책, 함수/트리거, 마이그레이션 SQL을 생성할 때 사용하세요.
---

# Supabase Helper 스킬

Supabase 데이터베이스 관리 작업을 자동화합니다. SQL 생성, RLS 정책 최적화, 문제 진단을 수행합니다.

## 실행 지침

1. 사용자의 요청 파악 (테이블 생성, RLS 설정, 함수 생성 등)
2. TRD의 DB 설계 참조 (`docs/TRD.md` 4장)
3. 최적화된 SQL 생성
4. `docs/supabase/` 폴더에 SQL 파일 저장

## 주요 기능

### 1. 테이블 생성
```sql
-- 템플릿
CREATE TABLE public.[테이블명] (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- RLS 활성화
ALTER TABLE public.[테이블명] ENABLE ROW LEVEL SECURITY;
```

### 2. RLS 정책 생성 (최적화 패턴)
```sql
-- SELECT 정책
CREATE POLICY "[테이블]_policy_select" ON public.[테이블]
  FOR SELECT USING ([조건]);

-- INSERT 정책
CREATE POLICY "[테이블]_policy_insert" ON public.[테이블]
  FOR INSERT WITH CHECK ([조건]);

-- UPDATE 정책
CREATE POLICY "[테이블]_policy_update" ON public.[테이블]
  FOR UPDATE USING ([조건]);

-- DELETE 정책
CREATE POLICY "[테이블]_policy_delete" ON public.[테이블]
  FOR DELETE USING ([조건]);
```

### 3. 함수 생성 (보안 패턴)
```sql
CREATE OR REPLACE FUNCTION public.[함수명]()
RETURNS [반환타입]
LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = ''
AS $$
BEGIN
  -- 로직
END;
$$;
```

### 4. 트리거 생성
```sql
CREATE TRIGGER [트리거명]
  [BEFORE|AFTER] [INSERT|UPDATE|DELETE] ON public.[테이블]
  FOR EACH ROW
  EXECUTE FUNCTION public.[함수명]();
```

## 진단 SQL

### 현재 상태 확인
```sql
-- 테이블 목록
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public' AND table_type = 'BASE TABLE';

-- RLS 정책 목록
SELECT tablename, policyname, cmd FROM pg_policies
WHERE schemaname = 'public' ORDER BY tablename;

-- 함수 목록
SELECT routine_name FROM information_schema.routines
WHERE routine_schema = 'public' AND routine_type = 'FUNCTION';
```

## 보안 체크리스트

- [ ] 모든 테이블에 RLS 활성화
- [ ] 함수에 `SET search_path = ''` 설정
- [ ] SECURITY DEFINER 대신 SECURITY INVOKER 사용 권장
- [ ] 민감한 데이터 접근 제한

## 출력 위치

- SQL 파일: `docs/supabase/[작업명].sql`
- 마이그레이션: `docs/supabase/migrations/[날짜]_[설명].sql`

## 참고 문서

- TRD: `docs/TRD.md` (4장 데이터베이스 설계)
- 정리 가이드: `docs/SUPABASE-CLEANUP.md`
</file>

<file path=".claude/skills/webapp-testing/SKILL.md">
---
name: webapp-testing
description: Playwright를 사용해 웹 앱을 테스트합니다. Expo 웹 빌드 테스트, UI 검증, 스크린샷 캡처에 사용하세요.
license: Based on Anthropic Skills (MIT)
---

# Web Application Testing 스킬

Playwright를 사용하여 로컬 웹 애플리케이션을 테스트합니다. Expo 웹 빌드를 통해 React Native 앱도 테스트할 수 있습니다.

## 사전 요구사항

### Playwright 설치
```bash
pip install playwright
playwright install chromium
```

### Expo 웹 빌드 (React Native 앱 테스트 시)
```bash
cd C:\Users\user\claude-test\app
npx expo start --web
# 또는
npx expo export:web
```

## 의사결정 트리

```
사용자 요청 → 정적 HTML인가?
 ├─ Yes → HTML 파일을 직접 읽어 셀렉터 파악
 │         → Playwright 스크립트 작성
 │
 └─ No (동적 웹앱) → 서버가 실행 중인가?
   ├─ No → 서버 먼저 시작
   │        npx expo start --web
   │
   └─ Yes → 정찰 후 행동:
     1. 페이지 이동 + networkidle 대기
     2. 스크린샷 또는 DOM 검사
     3. 렌더링된 상태에서 셀렉터 파악
     4. 발견한 셀렉터로 액션 실행
```

## 기본 테스트 스크립트

### 1. 간단한 페이지 테스트
```python
# tests/test_basic.py
from playwright.sync_api import sync_playwright

def test_homepage():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()

        # Expo 웹 서버 접속
        page.goto('http://localhost:8081')
        page.wait_for_load_state('networkidle')  # 중요!

        # 스크린샷 캡처
        page.screenshot(path='screenshots/homepage.png', full_page=True)

        # 요소 확인
        assert page.locator('text=로그인').is_visible()

        browser.close()

if __name__ == '__main__':
    test_homepage()
```

### 2. 로그인 플로우 테스트
```python
# tests/test_login.py
from playwright.sync_api import sync_playwright

def test_login_flow():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()

        page.goto('http://localhost:8081')
        page.wait_for_load_state('networkidle')

        # 이메일 입력
        page.fill('input[placeholder*="이메일"]', 'test@test.com')

        # 비밀번호 입력
        page.fill('input[placeholder*="비밀번호"]', 'test1234')

        # 로그인 버튼 클릭
        page.click('text=로그인')

        # 결과 대기 및 확인
        page.wait_for_timeout(2000)
        page.screenshot(path='screenshots/after_login.png')

        browser.close()

if __name__ == '__main__':
    test_login_flow()
```

### 3. 예약 플로우 테스트 (핵심)
```python
# tests/test_reservation.py
from playwright.sync_api import sync_playwright

def test_reservation_flow():
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()

        # 1. 로그인
        page.goto('http://localhost:8081')
        page.wait_for_load_state('networkidle')
        page.fill('input[placeholder*="이메일"]', 'test@test.com')
        page.fill('input[placeholder*="비밀번호"]', 'test1234')
        page.click('text=로그인')
        page.wait_for_timeout(2000)

        # 2. 업체 선택
        page.click('text=테스트 베이커리')  # 업체명
        page.wait_for_load_state('networkidle')
        page.screenshot(path='screenshots/store_detail.png')

        # 3. 상품 선택 및 예약
        page.click('text=예약하기')
        page.wait_for_timeout(1000)

        # 4. 예약 확인
        page.screenshot(path='screenshots/reservation_complete.png')

        browser.close()

if __name__ == '__main__':
    test_reservation_flow()
```

## 정찰 후 행동 패턴

```python
# 1. 렌더링된 DOM 검사
page.screenshot(path='/tmp/inspect.png', full_page=True)
content = page.content()
buttons = page.locator('button').all()
print([btn.text_content() for btn in buttons])

# 2. 콘솔 로그 캡처
page.on('console', lambda msg: print(f'Console: {msg.text}'))

# 3. 네트워크 요청 모니터링
page.on('request', lambda req: print(f'Request: {req.url}'))
```

## 흔한 실수

```python
# ❌ 잘못된 방법: networkidle 전에 DOM 검사
page.goto('http://localhost:8081')
content = page.content()  # 아직 JS 실행 안 됨!

# ✅ 올바른 방법: networkidle 후 검사
page.goto('http://localhost:8081')
page.wait_for_load_state('networkidle')  # JS 실행 대기
content = page.content()  # 이제 완전한 DOM
```

## 베스트 프랙티스

1. **항상 `sync_playwright()` 사용** (동기 스크립트)
2. **브라우저 종료 필수** `browser.close()`
3. **명확한 셀렉터 사용**: `text=`, `role=`, CSS, ID
4. **적절한 대기 추가**: `wait_for_selector()`, `wait_for_timeout()`
5. **스크린샷으로 디버깅**: 각 단계별 캡처

## 테스트 결과 저장

```
tests/
├── test_basic.py
├── test_login.py
├── test_reservation.py
└── screenshots/
    ├── homepage.png
    ├── after_login.png
    └── reservation_complete.png
```

## Expo 웹 테스트 실행 순서

```bash
# 1. Expo 웹 서버 시작 (터미널 1)
cd C:\Users\user\claude-test\app
npx expo start --web

# 2. 테스트 실행 (터미널 2)
cd C:\Users\user\claude-test
python tests/test_login.py
```

## 참고 문서

- Test-Plan: `docs/Test-Plan.md`
- TRD: `docs/TRD.md`
- PRD: `docs/PRD.md`

---

**팁**: Puppeteer MCP가 설치되어 있다면, 브라우저 자동화를 더 쉽게 수행할 수 있습니다.
</file>

<file path="app/src/stores/authStore.ts">
/**
 * 인증 상태 관리 스토어
 * - 세션, 사용자 정보, 업주 여부 등을 전역으로 관리
 */
import { create } from 'zustand';
import { Session } from '@supabase/supabase-js';
import { supabase } from '../lib/supabase';

// 상태 타입 정의
interface AuthState {
  // 상태
  session: Session | null;
  isStoreOwner: boolean;
  loading: boolean;

  // 액션
  setSession: (session: Session | null) => void;
  setIsStoreOwner: (isOwner: boolean) => void;
  setLoading: (loading: boolean) => void;

  // 복합 액션
  checkUserType: (userId: string) => Promise<void>;
  checkSession: () => Promise<void>;
  logout: () => Promise<void>;
  reset: () => void;
}

// 초기 상태
const initialState = {
  session: null,
  isStoreOwner: false,
  loading: true,
};

// 스토어 생성
export const useAuthStore = create<AuthState>((set, get) => ({
  // 초기 상태
  ...initialState,

  // 단순 액션
  setSession: (session) => set({ session }),
  setIsStoreOwner: (isOwner) => set({ isStoreOwner: isOwner }),
  setLoading: (loading) => set({ loading }),

  // 사용자 유형 확인 (소비자/업주)
  checkUserType: async (userId: string) => {
    try {
      // 소비자 체크
      const { data: consumer } = await supabase
        .from('consumers')
        .select('id')
        .eq('user_id', userId)
        .single();

      // 업주 체크
      const { data: store } = await supabase
        .from('stores')
        .select('id, is_approved')
        .eq('user_id', userId)
        .single();

      if (store) {
        set({ isStoreOwner: true });
      }

      // 소비자 또는 업주 데이터가 있으면 성공
      if (consumer || store) {
        return;
      }

      // 둘 다 없으면 로그아웃
      console.log('사용자 유형을 찾을 수 없습니다');
      await get().logout();
    } catch (error) {
      console.error('사용자 유형 확인 오류:', error);
    }
  },

  // 세션 확인
  checkSession: async () => {
    try {
      set({ loading: true });
      const { data: { session } } = await supabase.auth.getSession();
      set({ session });

      if (session) {
        await get().checkUserType(session.user.id);
      }
    } catch (error) {
      console.error('세션 확인 오류:', error);
    } finally {
      set({ loading: false });
    }
  },

  // 로그아웃
  logout: async () => {
    await supabase.auth.signOut();
    get().reset();
  },

  // 상태 초기화
  reset: () => set({ ...initialState, loading: false }),
}));
</file>

<file path="app/src/stores/index.ts">
/**
 * 스토어 통합 export
 * - 모든 Zustand 스토어를 한 곳에서 export
 */

// 인증 스토어
export { useAuthStore } from './authStore';

// 네비게이션 스토어
export {
  useNavigationStore,
  type AuthScreen,
  type ConsumerScreen,
  type StoreScreen,
} from './navigationStore';

// 선택 스토어
export { useSelectionStore } from './selectionStore';
</file>

<file path="app/src/stores/navigationStore.ts">
/**
 * 네비게이션 상태 관리 스토어
 * - 현재 화면 상태, 모드 전환 등을 전역으로 관리
 */
import { create } from 'zustand';

// 화면 타입 정의
export type AuthScreen = 'login' | 'signupType' | 'consumerSignup' | 'storeSignup';
export type ConsumerScreen = 'storelist' | 'detail' | 'reserve' | 'myreservations' | 'review' | 'mypage';
export type StoreScreen = 'dashboard' | 'products' | 'cash' | 'cashHistory' | 'reservations' | 'info' | 'reviews' | 'regulars';

// 상태 타입 정의
interface NavigationState {
  // 상태
  authScreen: AuthScreen;
  consumerScreen: ConsumerScreen;
  storeScreen: StoreScreen;
  showStoreMode: boolean;

  // 액션
  setAuthScreen: (screen: AuthScreen) => void;
  setConsumerScreen: (screen: ConsumerScreen) => void;
  setStoreScreen: (screen: StoreScreen) => void;
  setShowStoreMode: (show: boolean) => void;

  // 편의 액션
  goToLogin: () => void;
  goToStoreList: () => void;
  goToDashboard: () => void;
  enterStoreMode: () => void;
  exitStoreMode: () => void;
  reset: () => void;
}

// 초기 상태
const initialState = {
  authScreen: 'login' as AuthScreen,
  consumerScreen: 'storelist' as ConsumerScreen,
  storeScreen: 'dashboard' as StoreScreen,
  showStoreMode: false,
};

// 스토어 생성
export const useNavigationStore = create<NavigationState>((set) => ({
  // 초기 상태
  ...initialState,

  // 단순 액션
  setAuthScreen: (screen) => set({ authScreen: screen }),
  setConsumerScreen: (screen) => set({ consumerScreen: screen }),
  setStoreScreen: (screen) => set({ storeScreen: screen }),
  setShowStoreMode: (show) => set({ showStoreMode: show }),

  // 편의 액션
  goToLogin: () => set({ authScreen: 'login' }),
  goToStoreList: () => set({ consumerScreen: 'storelist', showStoreMode: false }),
  goToDashboard: () => set({ storeScreen: 'dashboard' }),

  enterStoreMode: () => set({
    showStoreMode: true,
    storeScreen: 'dashboard'
  }),

  exitStoreMode: () => set({
    showStoreMode: false,
    consumerScreen: 'mypage'
  }),

  // 상태 초기화
  reset: () => set(initialState),
}));
</file>

<file path="app/src/stores/selectionStore.ts">
/**
 * 선택 항목 상태 관리 스토어
 * - 선택된 업체, 상품, 예약 등을 전역으로 관리
 */
import { create } from 'zustand';

// 상품 타입 (간단한 정의)
interface Product {
  id: string;
  name: string;
  original_price: number;
  discounted_price: number;
  stock_quantity: number;
  store_id: string;
  [key: string]: any; // 추가 필드 허용
}

// 예약 타입 (간단한 정의)
interface Reservation {
  id: string;
  reservation_number: string;
  status: string;
  total_amount: number;
  pickup_time: string;
  store_id: string;
  product_id: string;
  [key: string]: any; // 추가 필드 허용
}

// 상태 타입 정의
interface SelectionState {
  // 상태
  selectedStoreId: string;
  selectedProduct: Product | null;
  selectedReservation: Reservation | null;

  // 액션
  selectStore: (storeId: string) => void;
  selectProduct: (product: Product | null) => void;
  selectReservation: (reservation: Reservation | null) => void;

  // 편의 액션
  clearStore: () => void;
  clearProduct: () => void;
  clearReservation: () => void;
  clearAll: () => void;
}

// 초기 상태
const initialState = {
  selectedStoreId: '',
  selectedProduct: null,
  selectedReservation: null,
};

// 스토어 생성
export const useSelectionStore = create<SelectionState>((set) => ({
  // 초기 상태
  ...initialState,

  // 선택 액션
  selectStore: (storeId) => set({ selectedStoreId: storeId }),
  selectProduct: (product) => set({ selectedProduct: product }),
  selectReservation: (reservation) => set({ selectedReservation: reservation }),

  // 초기화 액션
  clearStore: () => set({ selectedStoreId: '' }),
  clearProduct: () => set({ selectedProduct: null }),
  clearReservation: () => set({ selectedReservation: null }),
  clearAll: () => set(initialState),
}));
</file>

<file path="docs/plans/.gitkeep">
# 기능 구현 계획서 폴더

이 폴더는 TDD 기반 기능 구현 계획서를 저장합니다.

## 파일 명명 규칙
- `PLAN_<feature-name>.md`
- 예: `PLAN_user-authentication.md`, `PLAN_payment-flow.md`

## 계획서 작성 시점
- 새로운 기능 구현 시작 전
- Medium/Large 규모 리팩토링 전
- 복잡한 버그 수정 전

## 참고
- 계획서 템플릿: `.claude/agents/tdd-agent.md`의 "기능 구현 계획 템플릿" 섹션 참조
</file>

<file path="docs/PRD.md">
# 재고 할인 중개 플랫폼 PRD (제품 요구사항 정의서)

> **문서 버전**: 1.0
> **작성일**: 2026-01-17
> **프로젝트명**: 재고 할인 중개 플랫폼 (투굿투고 유사 서비스)
> **현재 상태**: MVP 90% 완료

---

## 목차

1. [제품 비전](#1-제품-비전)
2. [목표 및 KPI](#2-목표-및-kpi)
3. [타겟 사용자](#3-타겟-사용자)
4. [핵심 기능](#4-핵심-기능)
5. [사용자 스토리](#5-사용자-스토리)
6. [비기능적 요구사항](#6-비기능적-요구사항)
7. [경쟁사 분석](#7-경쟁사-분석)
8. [우선순위 및 로드맵](#8-우선순위-및-로드맵)
9. [제약 사항](#9-제약-사항)
10. [리스크 및 가정](#10-리스크-및-가정)
11. [부록](#11-부록)

---

## 1. 제품 비전

### 1.1 제품이 해결하고자 하는 핵심 문제

**음식물 폐기 문제와 소비자 가격 부담**

- 음식점, 베이커리, 편의점 등에서 매일 발생하는 마감 재고 폐기
- 소비자는 질 좋은 음식을 저렴하게 구매할 기회 부족
- 소규모 업체는 재고 손실로 인한 수익성 악화

### 1.2 제품 솔루션

마감 시간에 가까워진 재고 상품을 할인된 가격으로 연결하는 **중개 플랫폼**

- **업체**: 폐기 예정 재고를 할인 판매하여 손실 최소화
- **소비자**: 품질 좋은 상품을 30~70% 할인된 가격으로 구매
- **사회**: 음식물 낭비 감소를 통한 환경 보호

### 1.3 장기적인 제품 방향성

| 단계 | 목표 | 기간 |
|------|------|------|
| **Phase 1 (MVP)** | 예약 중개 기본 기능 완성 | 현재 ~ 2주 |
| **Phase 2** | 지도 탐색, 소셜 로그인, 검색 강화 | 4~6주 |
| **Phase 3** | 운영자 대시보드, 실시간 채팅, 쿠폰 | 6~8주 |
| **Phase 4** | 배송 서비스 확장 (픽업 안정화 후) | 추후 검토 |

### 1.4 성공의 정의

- 월간 활성 사용자(MAU) 1,000명 이상
- 업체 50개 이상 등록
- 예약 완료율 70% 이상 유지
- 평균 리뷰 평점 4.0 이상

---

## 2. 목표 및 KPI

### 2.1 비즈니스 목표

| 목표 | 설명 | 측정 방법 |
|------|------|----------|
| **수익 창출** | 예약 확정 시 15% 수수료 수익 | 월간 수수료 총액 |
| **업체 확보** | 초기 50개 업체 등록 | 등록 업체 수 |
| **사용자 확보** | 초기 1,000명 소비자 가입 | 가입자 수 |
| **거래 활성화** | 일 평균 50건 예약 | 일일 예약 건수 |

### 2.2 측정 가능한 성공 지표 (KPI)

#### MVP 출시 후 1개월

| 지표 | 목표치 | 측정 주기 |
|------|--------|----------|
| DAU (일간 활성 사용자) | 100명 | 일간 |
| 회원가입 전환율 | 30% | 주간 |
| 예약 완료율 | 70% | 주간 |
| 평균 리뷰 평점 | 4.0 이상 | 주간 |
| 앱 크래시 비율 | 1% 미만 | 일간 |

#### 3개월 후

| 지표 | 목표치 | 측정 주기 |
|------|--------|----------|
| MAU (월간 활성 사용자) | 1,000명 | 월간 |
| 등록 업체 수 | 50개 | 월간 |
| 일 평균 예약 건수 | 50건 | 일간 |
| 리뷰 작성률 | 30% | 월간 |
| 재구매율 | 40% | 월간 |

### 2.3 타임라인별 마일스톤

```
2026년 1월 (현재)
  |-- MVP 완료 및 내부 테스트

2026년 2월
  |-- 베타 출시 (제한된 사용자)
  |-- 토스페이먼츠 연동 완료

2026년 3월
  |-- 정식 출시 (앱스토어/플레이스토어)
  |-- 지도 기능 추가 (Phase 2 시작)

2026년 4월~5월
  |-- 소셜 로그인, 검색 강화
  |-- 카카오톡 알림 연동

2026년 6월 이후
  |-- 운영자 대시보드 구축
  |-- 실시간 채팅, 쿠폰 기능
```

---

## 3. 타겟 사용자

### 3.1 사용자 유형

| 유형 | 역할 | 구현 상태 |
|------|------|----------|
| **소비자** | 할인 상품 검색, 예약, 리뷰 작성 | 완료 |
| **업주** | 상품 등록, 예약 관리, 캐시 관리 | 완료 |
| **운영자** | 전체 관리, 클레임 처리 | 미구현 |

### 3.2 주요 사용자 페르소나

#### 페르소나 1: 알뜰 소비자 "김민지" (28세, 직장인)

**배경**
- 서울 강남 거주, 1인 가구
- 퇴근 후 집 근처에서 저녁 해결
- 가격 대비 품질을 중시

**니즈**
- 퇴근길에 저렴하게 식사 해결
- 다양한 음식 선택권
- 빠르고 간편한 예약

**페인포인트**
- 할인 상품 정보를 얻기 어려움
- 재고가 없어서 헛걸음한 경험
- 기존 앱들의 복잡한 결제 과정

**기대 행동**
- 매일 퇴근 전 앱에서 주변 할인 상품 확인
- 주 3회 이상 예약 및 픽업
- 단골 업체 즐겨찾기 등록

---

#### 페르소나 2: 동네 빵집 사장님 "이상훈" (45세, 베이커리 운영)

**배경**
- 주택가 베이커리 10년 운영
- 매일 저녁 남는 빵 폐기
- 디지털 마케팅 경험 부족

**니즈**
- 마감 재고 폐기 손실 줄이기
- 신규 고객 유치
- 간편한 상품 등록

**페인포인트**
- SNS 마케팅에 시간 투자 어려움
- 기존 플랫폼 수수료가 비쌈
- 복잡한 시스템 사용 어려움

**기대 행동**
- 하루 1회 마감 상품 등록 (30초 이내)
- 예약 알림 확인 후 빠른 처리
- 단골 고객 관리

---

#### 페르소나 3: 환경 의식 소비자 "박서연" (32세, 프리랜서)

**배경**
- 환경 문제에 관심이 많음
- 제로웨이스트 실천 중
- 가격보다 가치를 중시

**니즈**
- 음식물 낭비 줄이기에 기여
- 의미 있는 소비 경험
- 내 기여도 확인 (절약 금액, 환경 기여)

**페인포인트**
- 친환경 서비스를 찾기 어려움
- 기존 앱들의 환경 메시지 부재
- 내 기여를 확인할 방법 없음

**기대 행동**
- 누적 절약 금액 및 환경 기여도 확인
- 리뷰를 통한 경험 공유
- 친구에게 서비스 추천

---

### 3.3 사용자 세그먼트

| 세그먼트 | 특징 | 예상 비율 |
|----------|------|----------|
| **가격 민감 소비자** | 할인율이 높을수록 구매 의향 증가 | 50% |
| **편의 추구 소비자** | 거리, 시간 효율성 중시 | 30% |
| **가치 추구 소비자** | 환경 보호, 의미 있는 소비 | 20% |

---

## 4. 핵심 기능

### 4.1 기능 현황 요약

| 구분 | 완료 | 미완료 | 완료율 |
|------|------|--------|--------|
| 소비자 기능 | 10개 | 3개 | 77% |
| 업주 기능 | 12개 | 2개 | 86% |
| 시스템 기능 | 4개 | 2개 | 67% |
| **전체** | **26개** | **7개** | **79%** |

### 4.2 구현 완료 기능

#### 소비자 기능

| 기능 | 설명 | 화면 파일 | 우선순위 |
|------|------|----------|----------|
| 로그인 | 이메일/비밀번호 로그인 | LoginScreen.tsx | Must-have |
| 소비자 회원가입 | 닉네임 설정, 이메일 인증 | ConsumerSignupScreen.tsx | Must-have |
| 업체 리스트 | 거리순 업체 목록, 필터링 | StoreListHome.tsx | Must-have |
| 업체 상세 | 상품, 리뷰, 영업시간 확인 | StoreDetail.tsx | Must-have |
| 예약하기 | 수량, 픽업 시간 선택 | ReservationScreen.tsx | Must-have |
| 예약 내역 | 진행중/완료/취소 예약 | MyReservations.tsx | Must-have |
| 리뷰 작성 | 별점, 텍스트 리뷰 | ReviewScreen.tsx | Must-have |
| 마이페이지 | 프로필, 누적 절약 금액 | MyPageScreen.tsx | Must-have |
| 프로필 편집 | 닉네임, 전화번호, 주소 | ProfileEditScreen.tsx | Should-have |
| 즐겨찾기 | 업체 하트 버튼으로 저장 | StoreListHomeWithSearch.tsx | Should-have |

#### 업주 기능

| 기능 | 설명 | 화면 파일 | 우선순위 |
|------|------|----------|----------|
| 업주 회원가입 | 업체 정보, 사업자등록번호 | StoreSignupScreen.tsx | Must-have |
| 대시보드 | 오늘 예약, 매출, 통계 | StoreDashboard.tsx | Must-have |
| 상품 관리 | 등록/수정/삭제, 재고 | StoreProductManagement.tsx | Must-have |
| 상품 카테고리 | 빵, 도시락, 음료 등 6개 | StoreProductManagement.tsx | Should-have |
| 캐시 관리 | 잔액 확인, 충전 요청 | StoreCashManagement.tsx | Must-have |
| 캐시 내역 | 충전/차감 이력 조회 | StoreCashHistory.tsx | Must-have |
| 예약 관리 | 확인/완료/취소 처리 | StoreReservationManagement.tsx | Must-have |
| 리뷰 관리 | 리뷰 확인, 답글 작성 | StoreReviewManagement.tsx | Must-have |
| 리뷰 답글 | 답글 작성/수정/삭제 | StoreReviewManagementWithReply.tsx | Should-have |
| 업체 정보 | 업체명, 설명, 주소 수정 | StoreInfoManagement.tsx | Should-have |
| 영업시간 관리 | 요일별 영업시간, 휴무일 | StoreOperatingHoursScreen.tsx | Should-have |
| 단골 고객 | 단골 고객 목록 관리 | StoreRegularCustomers.tsx | Nice-to-have |

#### 시스템 기능

| 기능 | 설명 | 구현 방식 | 우선순위 |
|------|------|----------|----------|
| 수수료 자동 차감 | 예약 확정 시 15% 차감 | DB 트리거 | Must-have |
| 예약 번호 자동 생성 | R + 날짜 + 일련번호 | DB 함수 | Must-have |
| 재고 자동 관리 | 예약 시 차감, 취소 시 복구 | DB 트리거 | Must-have |
| 평점 자동 업데이트 | 리뷰 작성 시 업체 평점 갱신 | DB 트리거 | Must-have |

### 4.3 미구현 기능

| 기능 | 설명 | 우선순위 | 예상 기간 |
|------|------|----------|----------|
| **지도 기반 탐색** | 카카오/구글 맵 연동, 마커 표시 | 높음 | 1.5주 |
| **실결제 연동** | 토스페이먼츠 캐시 충전 | 높음 | 1.5주 |
| **푸시 알림** | Expo Push, 카카오 알림톡 | 중간 | 1주 |
| **운영자 대시보드** | 전체 관리, 통계, 사용자 관리 | 중간 | 2주 |
| **소셜 로그인** | 카카오, 구글 로그인 | 낮음 | 1주 |
| **검색 기능 강화** | 업체/상품 통합 검색, 필터 | 중간 | 1주 |
| **예약 취소** | 픽업 1시간 전까지 취소, 자동 환불 | 높음 | 0.5주 |

### 4.4 기능 의존성

```
[인증 시스템]
    |
    +-- [소비자 기능]
    |       |-- 업체 탐색 --> [지도 연동] (미구현)
    |       |-- 예약하기 --> [재고 자동 관리]
    |       |-- 예약 취소 --> [환불 처리]
    |       +-- 리뷰 작성 --> [평점 자동 업데이트]
    |
    +-- [업주 기능]
            |-- 상품 관리 --> [재고 자동 관리]
            |-- 캐시 충전 --> [토스페이먼츠] (미구현)
            +-- 예약 관리 --> [수수료 자동 차감]
```

---

## 5. 사용자 스토리

### 5.1 에픽(Epic) 정의

| 에픽 ID | 에픽명 | 설명 |
|---------|--------|------|
| E-01 | 사용자 인증 | 회원가입, 로그인, 사용자 구분 |
| E-02 | 업체 탐색 | 업체 검색, 필터링, 상세 보기 |
| E-03 | 예약 관리 | 예약 생성, 취소, 픽업 완료 |
| E-04 | 리뷰 시스템 | 리뷰 작성, 답글, 평점 관리 |
| E-05 | 캐시 관리 | 충전, 차감, 내역 조회 |
| E-06 | 상품 관리 | 상품 등록, 수정, 재고 관리 |
| E-07 | 알림 시스템 | 푸시 알림, 카카오톡 알림 |

### 5.2 사용자 스토리 목록

#### E-01: 사용자 인증

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-01 | 소비자로서, 이메일로 회원가입하여 서비스를 이용할 수 있다 | 이메일 형식 검증, 중복 확인, 닉네임 설정 | 완료 |
| US-02 | 업주로서, 업체 정보를 입력하여 회원가입할 수 있다 | 업체명, 주소, 사업자번호, 관리자 승인 대기 | 완료 |
| US-03 | 사용자로서, 로그인 후 자동으로 내 역할에 맞는 화면을 볼 수 있다 | 소비자 -> 업체 리스트, 업주 -> 대시보드 | 완료 |
| US-04 | 사용자로서, 카카오 계정으로 간편 로그인할 수 있다 | OAuth 연동, 프로필 자동 연동 | 미구현 |

#### E-02: 업체 탐색

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-05 | 소비자로서, 내 위치 기준 가까운 업체를 볼 수 있다 | 거리순 정렬, 거리 표시 | 완료 |
| US-06 | 소비자로서, 업체를 검색하고 필터링할 수 있다 | 이름, 카테고리 검색, 평점 필터 | 완료 |
| US-07 | 소비자로서, 지도에서 주변 업체를 탐색할 수 있다 | 마커 표시, 클러스터링 | 미구현 |
| US-08 | 소비자로서, 마음에 드는 업체를 즐겨찾기할 수 있다 | 하트 버튼, 즐겨찾기 목록 | 완료 |
| US-09 | 소비자로서, 업체 상세에서 상품과 리뷰를 볼 수 있다 | 상품 목록, 리뷰 목록, 영업시간 | 완료 |

#### E-03: 예약 관리

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-10 | 소비자로서, 상품을 예약하고 예약번호를 받을 수 있다 | 수량 선택, 픽업 시간, 예약번호 발급 | 완료 |
| US-11 | 소비자로서, 내 예약 내역을 조회할 수 있다 | 진행중/완료/취소 구분 | 완료 |
| US-12 | 소비자로서, 픽업 1시간 전까지 예약을 취소할 수 있다 | 시간 제한, 재고 복구 | 완료 |
| US-13 | 업주로서, 새 예약 알림을 받고 확인할 수 있다 | 예약 목록, 상태 변경 | 완료 |
| US-14 | 업주로서, 픽업 완료를 처리할 수 있다 | 수수료 차감, 거래 완료 | 완료 |

#### E-04: 리뷰 시스템

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-15 | 소비자로서, 픽업 완료 후 리뷰를 작성할 수 있다 | 별점 1~5, 텍스트, 1거래 1리뷰 | 완료 |
| US-16 | 업주로서, 리뷰에 답글을 달 수 있다 | 답글 작성/수정/삭제 | 완료 |
| US-17 | 소비자로서, 업체의 리뷰와 평점을 볼 수 있다 | 리뷰 목록, 평균 평점 | 완료 |

#### E-05: 캐시 관리

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-18 | 업주로서, 캐시 잔액을 확인할 수 있다 | 현재 잔액, 상태 표시 | 완료 |
| US-19 | 업주로서, 토스페이먼츠로 캐시를 충전할 수 있다 | 금액 선택, 결제 완료 | 부분 완료 (실결제 미연동) |
| US-20 | 업주로서, 캐시 충전/차감 내역을 조회할 수 있다 | 거래 유형, 날짜, 금액 | 완료 |
| US-21 | 업주로서, 캐시가 부족하면 알림을 받을 수 있다 | 1만원 미만 시 알림 | 미구현 |

#### E-06: 상품 관리

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-22 | 업주로서, 상품을 등록할 수 있다 | 이름, 가격, 재고, 카테고리 | 완료 |
| US-23 | 업주로서, 상품 정보를 수정할 수 있다 | 가격, 재고, 상태 변경 | 완료 |
| US-24 | 업주로서, 상품을 삭제할 수 있다 | 예약 없는 상품만 삭제 가능 | 완료 |
| US-25 | 시스템이 예약 시 자동으로 재고를 차감한다 | 동시성 제어, 재고 부족 시 오류 | 완료 |

#### E-07: 알림 시스템

| ID | 사용자 스토리 | 인수 조건 | 상태 |
|----|---------------|----------|------|
| US-26 | 소비자로서, 예약 확정 알림을 받을 수 있다 | 푸시 알림, 앱 알림 | 미구현 |
| US-27 | 업주로서, 새 예약 알림을 받을 수 있다 | 푸시 알림, 카카오톡 | 미구현 |
| US-28 | 소비자로서, 즐겨찾기 업체의 신상품 알림을 받을 수 있다 | 구독 설정, 알림 발송 | 미구현 |

---

## 6. 비기능적 요구사항

### 6.1 성능 요구사항

| 항목 | 요구사항 | 측정 기준 |
|------|----------|----------|
| **페이지 로딩** | 3초 이내 | 첫 화면 렌더링 완료 |
| **API 응답** | 500ms 이내 | 95 percentile 기준 |
| **동시 사용자** | 100명 이상 | 동시 접속 기준 |
| **이미지 로딩** | 2초 이내 | 상품/업체 이미지 |
| **검색 결과** | 1초 이내 | 검색 쿼리 응답 |

### 6.2 보안 요구사항

| 항목 | 요구사항 | 구현 방식 |
|------|----------|----------|
| **인증** | JWT 토큰 기반 인증 | Supabase Auth |
| **데이터 접근 제어** | Row Level Security | Supabase RLS 정책 |
| **API 키 관리** | 환경변수로 관리, 하드코딩 금지 | .env 파일 |
| **민감정보 로깅** | 비밀번호, 결제정보 로그 금지 | 로그 필터링 |
| **데이터 암호화** | HTTPS 통신, 비밀번호 해싱 | Supabase 기본 제공 |
| **세션 관리** | 토큰 자동 갱신, 7일 만료 | AsyncStorage |

### 6.3 확장성 요구사항

| 항목 | 요구사항 | 대응 전략 |
|------|----------|----------|
| **사용자 증가** | MAU 10만까지 대응 | Supabase Pro 플랜 |
| **데이터 증가** | 월 100만 건 예약 처리 | 테이블 파티셔닝 |
| **트래픽 급증** | 점심/저녁 피크 타임 대응 | React Query 캐싱 |
| **기능 확장** | 새 기능 추가 용이성 | 모듈화된 코드 구조 |

### 6.4 배포 요구사항

| 항목 | 요구사항 | 구현 방식 |
|------|----------|----------|
| **배포 환경** | iOS, Android 앱스토어 | EAS Build + Submit |
| **CI/CD** | 자동 빌드, 테스트 | GitHub Actions |
| **롤백 전략** | 이전 버전 복구 가능 | EAS Update |
| **모니터링** | 에러 추적, 성능 모니터링 | Sentry |
| **버전 관리** | 시맨틱 버저닝 | 1.0.0 형식 |

### 6.5 호환성 요구사항

| 항목 | 요구사항 |
|------|----------|
| **iOS 버전** | iOS 13.0 이상 |
| **Android 버전** | Android 8.0 (API 26) 이상 |
| **화면 크기** | 다양한 화면 크기 대응 (반응형) |
| **네트워크** | 오프라인 시 적절한 에러 메시지 |

---

## 7. 경쟁사 분석

### 7.1 주요 경쟁사

| 서비스 | 특징 | 강점 | 약점 |
|--------|------|------|------|
| **Too Good To Go** | 글로벌 No.1, 서프라이즈 백 | 브랜드 인지도, 환경 메시지 | 국내 미진출 |
| **럭키밀** | 50%+ 할인, Bubble MVP | 높은 할인율, 선물 브랜딩 | 기술 부채 |
| **마감 히어로** | 30초 상품 등록 | 빠른 등록, 매장 추천 | 기능 제한 |
| **라스트 오더** | 선도 서비스 | 초기 시장 선점 | 재고 신뢰성 이슈 |

### 7.2 경쟁사 분석 인사이트

#### 라스트 오더 부정적 리뷰 분석 결과

| 문제점 | 원인 | 우리의 대응 |
|--------|------|------------|
| **재고 불일치** | 실재고 미연동 | 예약 시 실시간 재고 차감 |
| **가격 신뢰성** | 정가 증빙 없음 | 정가/할인가 필수 표시 |
| **품질 불만** | 유통기한 미표시 | 제조일/소비기한 필수 입력 |
| **환불 지연** | 수동 CS 처리 | 자동 환불 시스템 |
| **배송 문제** | 배송 확장 급함 | 픽업 전용으로 시작 |

### 7.3 차별화 포인트

| 항목 | 경쟁사 | 우리 서비스 |
|------|--------|------------|
| **재고 관리** | 수동 업데이트 | 예약 시 자동 차감, 취소 시 자동 복구 |
| **수수료 모델** | 월정액 또는 높은 수수료 | 거래 발생 시에만 15% |
| **업주 부담** | 선결제 없음 | 캐시 선충전으로 신뢰성 확보 |
| **예약 취소** | 복잡한 절차 | 1시간 전까지 원클릭 취소 |
| **리뷰 신뢰성** | 구매 무관 리뷰 가능 | 픽업 완료 시에만 리뷰 가능 |

---

## 8. 우선순위 및 로드맵

### 8.1 우선순위 기준

```
[Must-have] 서비스 운영에 필수적인 기능
[Should-have] 사용자 경험 향상에 중요한 기능
[Nice-to-have] 있으면 좋지만 필수는 아닌 기능
```

### 8.2 개발 로드맵

#### Phase 1: MVP 완성 (현재 ~ 2주)

| 주차 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 1주 | 테스트 환경 구축, 기능 테스트 | Must-have |
| 1주 | 버그 수정, 코드 정리 | Must-have |
| 2주 | 토스페이먼츠 연동 | Must-have |
| 2주 | 예약 취소 기능 완성 | Must-have |

**산출물**: 내부 테스트 가능한 MVP

#### Phase 2: 베타 출시 (3~6주)

| 주차 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 3주 | 지도 기반 탐색 (카카오맵) | Should-have |
| 4주 | 푸시 알림 (Expo Push) | Should-have |
| 5주 | 소셜 로그인 (카카오) | Should-have |
| 6주 | 검색 기능 강화 | Should-have |

**산출물**: 앱스토어 베타 버전

#### Phase 3: 정식 출시 (7~12주)

| 주차 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 7~8주 | 운영자 대시보드 | Should-have |
| 9주 | 카카오톡 알림톡 | Should-have |
| 10주 | 성능 최적화 | Should-have |
| 11~12주 | 정식 출시 준비 | Must-have |

**산출물**: 앱스토어 정식 버전

#### Phase 4: 확장 (12주 이후)

| 작업 내용 | 우선순위 |
|----------|----------|
| 실시간 채팅 | Nice-to-have |
| 쿠폰/프로모션 | Nice-to-have |
| 다크 모드 | Nice-to-have |
| 다국어 지원 | Nice-to-have |

### 8.3 마일스톤 요약

```
2026-01 (현재)
    |-- [M1] MVP 테스트 완료
    |
2026-02
    |-- [M2] 토스페이먼츠 연동 완료
    |-- [M3] 베타 테스트 시작
    |
2026-03
    |-- [M4] 앱스토어 베타 출시
    |-- [M5] 지도 기능 추가
    |
2026-04
    |-- [M6] 정식 출시
    |
2026-05~06
    |-- [M7] 운영자 대시보드 완성
    |-- [M8] MAU 1,000명 달성
```

---

## 9. 제약 사항

### 9.1 기술적 제약

| 제약 사항 | 영향 | 대응 방안 |
|----------|------|----------|
| **React Native 사용** | 일부 네이티브 기능 제한 | Expo 모듈 활용 |
| **Supabase 무료 플랜** | 월 500MB DB, 1GB Storage | 초기 무료 사용, 이후 Pro 전환 |
| **실결제 테스트** | 토스페이먼츠 테스트 환경 제한 | 테스트 키로 개발, 런칭 시 전환 |

### 9.2 비즈니스 제약

| 제약 사항 | 영향 | 대응 방안 |
|----------|------|----------|
| **1인 개발** | 개발 속도 제한 | 우선순위 집중, MVP 범위 축소 |
| **예산 제한** | 유료 서비스 사용 제한 | 무료 티어 최대 활용 |
| **초기 업체 확보** | 콜드스타트 문제 | 지인 업체부터 시작 |

### 9.3 일정 제약

| 제약 사항 | 목표 일정 | 비고 |
|----------|----------|------|
| **MVP 완성** | 2026년 1월 말 | 2주 내 |
| **베타 출시** | 2026년 2월 | 앱스토어 심사 포함 |
| **정식 출시** | 2026년 3월 | 마케팅 시작 |

---

## 10. 리스크 및 가정

### 10.1 식별된 리스크

| 리스크 | 가능성 | 영향 | 대응 방안 |
|--------|--------|------|----------|
| **앱스토어 심사 거절** | 중간 | 높음 | 가이드라인 사전 확인, 수정 대비 |
| **업체 확보 실패** | 중간 | 높음 | 지인 네트워크 활용, 초기 무료 운영 |
| **결제 연동 지연** | 낮음 | 높음 | 토스 기술지원팀 연락처 확보 |
| **동시성 이슈** | 낮음 | 중간 | DB 트랜잭션, 락 메커니즘 구현 완료 |
| **사용자 이탈** | 중간 | 중간 | 피드백 수집, 빠른 개선 |

### 10.2 가정 사항

| 가정 | 근거 | 검증 방법 |
|------|------|----------|
| 사용자가 할인 상품에 관심이 있다 | 경쟁사 존재, 시장 성장 | 베타 테스트 반응 |
| 업주가 마감 재고 판매를 원한다 | 폐기 손실 존재 | 업주 인터뷰 |
| 15% 수수료가 적정하다 | 경쟁사 대비 낮은 수준 | 업주 피드백 |
| 픽업 방식이 선호된다 | 배송비 부담 없음 | 사용자 조사 |
| 모바일 앱이 적합하다 | 위치 기반 서비스 | 경쟁사 분석 |

---

## 11. 부록

### 11.1 용어 정의

| 용어 | 정의 |
|------|------|
| **캐시** | 업체가 선충전하여 수수료 결제에 사용하는 플랫폼 내 가상 화폐 |
| **픽업** | 소비자가 업체를 방문하여 예약 상품을 수령하는 것 |
| **예약** | 소비자가 상품을 미리 확보하는 것 (결제는 현장에서) |
| **수수료** | 예약 확정 시 업체 캐시에서 차감되는 플랫폼 이용료 (15%) |
| **MVP** | Minimum Viable Product, 최소 기능 제품 |
| **MAU** | Monthly Active Users, 월간 활성 사용자 |
| **DAU** | Daily Active Users, 일간 활성 사용자 |

### 11.2 기술 스택 요약

| 영역 | 기술 | 버전 |
|------|------|------|
| **Frontend** | React Native + Expo | SDK 54, RN 0.81.5 |
| **Language** | TypeScript | 5.9.2 |
| **Backend** | Supabase (PostgreSQL) | Latest |
| **Auth** | Supabase Auth | JWT |
| **결제 (예정)** | 토스페이먼츠 | - |
| **지도 (예정)** | 카카오맵 | - |

### 11.3 관련 문서

| 문서 | 위치 |
|------|------|
| 프로젝트 분석 보고서 | `docs/PROJECT-ANALYSIS-REPORT.md` |
| 개발 로드맵 | `project-analysis/repo-latest/docs/04-development-roadmap.md` |
| 기능 구현 가이드 | `project-analysis/repo-latest/FEATURE-IMPLEMENTATION-GUIDE.md` |
| 데이터베이스 스키마 | `project-analysis/repo-latest/docs/01-database-schema.md` |
| 시스템 아키텍처 | `project-analysis/repo-latest/docs/02-system-architecture.md` |

### 11.4 화면 파일 목록

```
app/src/screens/
|-- LoginScreen.tsx              # 로그인
|-- ConsumerSignupScreen.tsx     # 소비자 회원가입
|-- StoreSignupScreen.tsx        # 업주 회원가입
|-- StoreListHome.tsx            # 업체 리스트 (홈)
|-- StoreListHomeWithSearch.tsx  # 검색 + 즐겨찾기
|-- StoreDetail.tsx              # 업체 상세
|-- ReservationScreen.tsx        # 예약하기
|-- MyReservations.tsx           # 예약 내역
|-- ReviewScreen.tsx             # 리뷰 작성
|-- MyPageScreen.tsx             # 마이페이지
|-- ProfileEditScreen.tsx        # 프로필 편집
|-- StoreDashboard.tsx           # 업주 대시보드
|-- StoreProductManagement.tsx   # 상품 관리
|-- StoreCashManagement.tsx      # 캐시 관리
|-- StoreCashHistory.tsx         # 캐시 내역
|-- StoreReservationManagement.tsx   # 예약 관리
|-- StoreReviewManagement.tsx    # 리뷰 관리
|-- StoreReviewManagementWithReply.tsx  # 리뷰 답글
|-- StoreInfoManagement.tsx      # 업체 정보
|-- StoreOperatingHoursScreen.tsx    # 영업시간 관리
|-- StoreRegularCustomers.tsx    # 단골 고객
```

---

**문서 작성**: PRD 에이전트
**검토일**: 2026-01-17
**다음 단계**: TRD (기술 요구사항 정의서) 작성

---

> 이 PRD는 비전공자도 이해할 수 있도록 기술적 용어를 최소화하고, 명확한 설명을 포함하였습니다.
</file>

<file path="docs/requirements/경쟁사 분석 및 기타 메모.txt">
1. 경쟁사 분석
 a) Too good to go(해외)
   - 남은 음식 정가 대비 30% 이상 저렴하게 판매, 5-~70% 저렴한 서프라이즈 백도 있음
   - 어플 내 결제 후, 픽업 시간에 맞춰 소비자가 픽업 (+배달)
   - 반경 거리 설정하면, 지도로 근처 매장 확인 가능
   - 업체 별 남은 수량 표기, 별점 리뷰 표기, 업체 별 개인 상세 페이지 있음 (아래 이미지)
  
   - 결제 시, ‘지구를 지켰다’라는 메시지 + 주소와 지도 제공 + 영수증 / 픽업 시간 제공
 
b) 라스트 오더(국내)
   - 오프라인은 편의점만, 온라인 위주로 재고 떨이 상품 취급하고 있음
   - 리뷰 분석: 오프라인 거래에 대한 후기 매우 안 좋음(아래 표)
#	반복 불만 유형	구체 내용	문제의 본질	인사이트
1	재고 신뢰 붕괴	결제 후 품절 / 잦은 취소 / 부분취소	실재고 미연동	‘결제 전 재고 확정’ 구조 (선결제 금지, 점주 확정 버튼 필수) 재고 오프라인 정가 판매 못하도록 해야 함
2	가격 신뢰 붕괴	할인인데 쿠팡/정가와 차이 없음	기준가 조작 의심	정가 증빙 필수 
3	상품 품질 불만	유통기한 임박·상함·곰팡이	품질 책임 불명확	품질 하한선 규칙 (D-몇일, 제조일 표시 의무)
4	지역 커버리지 부족	지방은 매장 거의 없음	플랫폼 밀도 실패	초기 ‘1개 동네 집중 전략’ (전국 확장 금지)
5	UX/기술 미완성	알림 안 옴, 확대 안 됨, 결제 오류	MVP 미완	기능 축소: 알림·결제·취소만 완벽히
6	환불·정산 불신	부분취소 후 환불 지연/미처리	금융 신뢰 붕괴	즉시 자동 환불 (수동 CS 개입 제거)
7	플랫폼-점주 책임 전가	점주 탓, 플랫폼 탓	책임 주체 불명	책임 주체 단일화 (소비자 대응은 무조건 업체)
9	배송/픽업 혼선	배송 전환, 픽업 불명확	약속 불이행	픽업 ONLY로 시작 (배송 확장 금지)
10	CS 불신·리뷰 삭제 의혹	응답 느림, 리뷰 삭제	신뢰 파괴	리뷰 비삭제 원칙 + 공개 대응 로그

c) 럭키 밀(국내) – 
   - 오늘 내일 중 픽업 가능시간 표기. 업체별 대표 상품(아마 최저가)에 대해 정가와 할인가 표기
   - 소비자 매너지수를 운영 / 마이페이지에서 구매 이력에 따라 저감한 CO2e 와 절약 금액을 보여줌
   - 빵집/빵순이 타겟: 빵집 대상 확장 속도 빠를 듯..고객 선확보후 카테고리 확장 좋을 듯
   - 50%이상 고정 할인율 제공 (수수료는 정가의 10%, 할인가의 20%)
   - 떨이 상품 이용한다는 소비자들의 부정적 인식 없애기 위해, ‘선물’과 ‘행운’ 키워드로 브랜딩
   - 픽업 60분 전까지 사장이 취소 가능. 60분 내 취소하면 수수료 500원. 픽업 후 소비자 확정 버튼
   - 럭키밀 앱은 Bubble 기반의 노코드 MVP로 시작. 서울 공릉 마포 광진 성동 > 전국 확장중
   - 기존 앱의 네이티브 전환 작업 중. 대용량 트래픽을 처리할 수 있는 서버 및 데이터베이스 확보 목표
  - 구매 시 카톡 알람
 

e) 마감 히어로(국내)
   - 찜, 선착순 알림 등 차별화 기능 개발: 상품을 업로드하면, 주민들에게 즉시 알림이 전달됩니다
   - 랜덤팩 구성 / 할인율 설정 / 등 30초만에 상품 등록 가능하도록 함
   - 마감히어로를 통해 해당 매장에서 구매한 고객 중 60% 이상 ‘첫 방문’ > 내부 포스터만으로 부족?
   - 제과 위주, 곧 음식점으로 확장 예정. 수원 성남부터 순차 오픈
   - 매장에 포스터 부착 / 앱 내 유저가 매장 추천 가능한 버튼 
   - 지도로 볼 수 있고, 리스트 거리순으로(위치기반)도 볼 수 있음
    

f) 기타(참고할 사항)
- 사용자 하교 및 퇴근 시간대에 픽업 가능하도록 (17시 이후)
    - 주요 고객을 선정하자. Ex 자취/맞벌이/1인가구 위한.. 과일 반찬가게 정육점 생선 시장 등(필수 식품)
    - 1분기 내 배달앱에서 마감할인 시작.. 더 큰 할인제공하기 위해서 차별화할 것 고민 ex. 수수료
    - 동네 정육점·반찬가게·어시장: IT 친화도 낮음 > 편의성 고려하여 시스템 설계
    - 반찬·육류·생선·과일 = 상함/냄새/상태 차이 큼. 할인 구매자일수록 클레임 강도 ↑ > 강한 
      ㄴ 운영 규칙 마련하고 고객에게도 홍보 ex. 주 2회 클레임시 경고, 경고 3회 시 방출 등
      ㄴ 클레임 고객에게 환불 시 클레임 처리 취소. 리뷰 삭제 ok 
      ㄴ 클레임에 따른 책임 및 처리 등은 각 업체가 하는 것으로 약관 작성
    - 프랜차이즈 본사를 타겟으로 먼저 영업하자 
    - 제품에 대해 정보 표기 강조. 알러지 등
    - 거래 데이터 : 일시, 픽업 여부, 할인율, 금액, 제품명 등 데이터 관리 >> 탄소포인트
      ㄴ 월/분기 단위로 엑셀 다운 (엑셀다운 아니어도되긴함) 정부제출가능토록(월별/분기별 감축 리포트)
    - 관련 협회도 찾아보기
씨제이푸드빌(주)·(주)파리크라상, 대한제과협회·한국외식업중앙회·한국편의점산업협회 등 식품판매업계 베이커리 프랜차이즈 본사 2개 사와 식품 판매 유관협회 3곳, 한국환경단이 참여했다.

---
[개발]
1. 지도 + 현재 위치 + 거리순 나열
가능. 브라우저 Geolocation API로 위치 받고,
지도는 Kakao Maps / Naver Maps / Google Maps중 하나 붙이면 됨.
거리순 정렬은 서버 없이도 Haversine 계산으로 바로 가능.
2. 결제 시스템
가능. 한국이면 보통 토스페이먼츠 / 아임포트(포트원) / KG이니시스같은 PG 연동으로 처리.
MVP는 “결제 완료→주문 생성”까지만, 환불/정산은 나중에.
3. 현실적인 MVP 권고(핵심)
앱이 아니라도 **PWA(모바일 웹앱)**로 시작하면 3개 기능 다 가능하고 개발 속도 가장 빠름.
초기 리스크(개발 과몰입) 줄이려면 지도는 최소 기능(핀+리스트), 결제는 단일 PG로 제한.
추천 스택: Next.js + Supabase + (Kakao Maps) + (Toss Payments)
이 조합으로 가면 “로그인/DB/호스팅”까지 속도 잘 나와.

6. 외부 의존 2개 확정
 지도: 카카오(또는 네이버) 중 1개
 결제: 토스페이먼츠(또는 포트원) 중 1개
</file>

<file path="docs/requirements/앱 사용자 시나리오 초안.txt">
앱의 주요 사용 시나리오와 흐름 

1소비자, 2:업체, 3:소비자 및 업체 공통, 4:운영자의 총 네 가지로 나눠, 앱의 주요 사용 시나리오와 흐름을 정리해보았어.
1-1) 사용 경험이 많지 않은 소비자는, 어플을 키고 거리순 업체 리스트와 지도 기반 업체들을 보며, 활동 반경 인근의 업체에 대해 익힌다.
1-2) 사용 경험이 많은 소비자는, 활동 반경 및 이동 경로에 위치한 단골 가게가 생기며, 즐겨찾기 또는 거리순 or 지도 기반 리스트에서 특정 업체의 상세 페이지로 바로 들어간다. 이후, 업체의 상세 페이지에 있는 업체의 상품 및 가격을 보고 ‘예약’ 의사결정을 수행함.
1-3) 소비자가 제품을 플랫폼 내에서 ‘예약’할 경우 자동으로 확정되며, 이 때, 픽업 시간을 정할 수 있다. 점주의 ‘예약’ 취소가 없으면 ‘소비자는’ 예정된 픽업 시간에 제품을 픽업하며, 취소될 경우 ‘취소 알림을 받는다.’
1-4) 소비자가 ‘예약’ 시, ‘예약 완료’ 화면이 나온다. 해당 화면에는 업체의 주소, 지도상 위치, 가격, ‘예약’번호 등이 나온다. ‘예약’번호는 플랫폼에서 생성하여 발급한다. 이 때, 소비자에게 ‘지구를 구했다(임시)’는 안내 문구도 나오며, 플랫폼 회원가입 후 ‘예약’한 순간까지 할인 받은 총 금액의 누계가 나온다. 소비자가 ‘예약’ 후 60분 이내에는 ‘예약’ 취소가 가능하며, 60분이 넘어가면 ‘예약’ 불가하다. 소비자 ‘예약’ 내용에 따라, 업체의 제품 수량은 결제 즉시 반영되어 수정된다.
1-5) 소비자가 제품 픽업 시, 픽업 완료 버튼을 누르며 업주에게 보여준다. 픽업 완료 시 업체의 거래건수가 1 올라가며, 고객은 리뷰 작성 및 별점 평가할 수 있는 권리를 얻게 된다. 한 업체에 대한 리뷰는 ‘소비자가’ 1회 픽업시 작성 ‘가능하기에, 2회 이상 거래하면 거래한 횟수만큼’ 리뷰를 작성할 수 ‘있’다. 소비자가 리뷰를 작성하면 리뷰 및 별점 평가 권리는 ‘작성횟수만큼 차감된다.‘
‘1-6) 제품 픽업시 소비자는 현장에서 결제를 하며, 결제 수단은 업주와 협의하여 현금 / 카드 / 이체 등 자유롭게 할 수 있다.’
2-1) 점주는 제품 등록시 정가와, 할인가 및 재고 수량을 입력한다. 이때 플랫폼 내에서 할인율을 자동으로 계산하여 업체의 상세페이지에 표기해준다. 제품 등록 시, 업체의 알림받기를 해둔 소비자들은 제품 등록에 대한 정보를 앱 알림 또는 카톡 알림을 통해 받을 수 있다. 제품 등록 시 제조 날짜와 소비 기한을 입력하도록 되어있는데, 제조날짜와 소비기한은 업주의 플랫폼 사용 당일 날짜로 매일 업데이트되어 자동으로 설정되어있으며, 업주는 이를 수정할 수 있다. 제조날짜와 소비기한은 연/월/일로 구성된다.
2-2) 업체가 등록한 제품의 모든 알림을 소비자가 받을 수도 있지만, 특정 제품에 대한 알림만을 소비자가 선별적으로 받을 수도 있다. 점주는 알림받기 신청한 고객들을 확인가능하며, 각 고객들이 특정 제품에 대해 알림을 받는지 또는 전체 알림을 받는지 확인할 수 있다.
2-3) 고객의 리뷰 작성 및 별점 평가가 이뤄지면 알림이 카톡 또는 플랫폼을 통해 전달된다. 업체는 이에 대한 답글을 작성할 수 있지만, 리뷰 및 평가된 별점을 임의로 삭제하거나 변경할 수 없다. 이는 운영자만이 직접 수정할 수 있다.
2-4) 고객이 상품을 ‘예약’하면 결제에 대한 알림을 받을 수 있다. 고객이 ‘예약’ 시, 구매한 상품의 수량만큼 업체의 상세페이지에 상품 정보가 자동으로 업데이트 된다.(1-4 내용 참고) 가령, A제품을 2개 소비자가 ‘예약’할 경우, 업체가 등록한 A제품의 수량이 2개 줄어들며, 소비자는 재고 수량 이상의 제품을 ‘예약’할 수 없다.
2-5) 업체의 사정으로 인해 제품을 판매할 수 없을 경우에는 고객의 ‘예약을’ 취소할 수 있는데, 이는 고객의 결제 시점으로부터 30분 이내 이거나(or) 고객이 선택한 픽업 시간으로부터 2시간 이상 시간이 남았을 때이다. 해당 조건 외에는 업체가 고객의 ‘예약을’ 취소할 수 없다. 업체 또는 소비자가 결제를 취소할 경우, 제품의 수량은 원복된다.
2-6) 업체는 고객이 결제 정보를 받아볼 수 있고, 결제 정보에는 고객의 닉네임이 담겨있다. 고객이 픽업하러 올 경우, 고객은 닉네임을 말하며, 업체는 닉네임으로 ‘예약’ 이력을 조회해 제품을 확인하고 고객에게 전달한다.
‘2-7) 업체는 플랫폼 내에 캐시를 충전하며, 캐시는 소비자가 예약한 제품을 결제하고 픽업 완료 버튼을 누를 때 차감된다. 차감되는 캐시는 소비자가 결제한 금액의 15-20%로 결정될 예정이며, 이는 업체가 플랫폼을 이용하는 수수료이다. 업체는 플랫폼에서 옵션으로 넣은 단위 중 하나로 캐시를 충전할 수 있으며, 만약 캐시가 1만 원 아래로 떨어질 경우 업체는 알림을 받고, 플랫폼 내 모든 유형의 업체 리스트에서 해당 업체는 영업 종료 시간이 지난 업체와 같이 비활성으로 표시된다. 참고로, 업체의 영업 종료 시간이 지나면 해당 업체는 플랫폼 내 비활성된다.’
3-1) 소비자 및 업체는 각각 다른 유형으로 회원가입하며, 회원가입 후 플랫폼 이용시 자동 로그인을 할 수 있다. 로그인 된 메인 화면에서는 ‘마이페이지’가 동일하게 있지만, 마이페이지 안에서는 회원 유형에 따라 서로 다른 UI가 있다. 예로, 소비자는 3개월 내 모든 구매이력을 확인할 수 있으며, ‘예약 내역도 확인할 수 있고,’ 또한 회원가입 후 구매한 모든 제품들의 정가와 구매했던 할인가의 차이를 더한 ‘누적 아낀 금액’을 확인할 수 있다. 업체는 업체 소개글과 소개 이미지 등을 편집할 수 있고, 상품을 등록 및 수정하거나, 고객의 별점과 리뷰에 대한 답글을 작성할 수도 있다. 또한, 업체는 자체적인 환불/교환/노쇼 정책을 입력할 수 있도록 하며, 소비자는 업체 상세페이지에서 이를 확인할 수 있다.
4-1) ‘운영자’는 플랫폼 내 표기된 이메일 주소를 통해 클레임을 접수받는다.
</file>

<file path="docs/supabase-cleanup-all.sql">
-- ============================================
-- Supabase 전체 정리 및 최적화 SQL
-- 작성일: 2026-01-18
-- 실행 방법: Supabase SQL Editor에서 전체 복사 후 실행
-- ============================================

-- ============================================
-- PART 1: 불필요한 뷰 삭제
-- ============================================
DROP VIEW IF EXISTS public.store_cash_summary CASCADE;
DROP VIEW IF EXISTS public.stores_with_status CASCADE;
DROP VIEW IF EXISTS public.reservation_stats CASCADE;

-- ============================================
-- PART 2: 불필요한 테이블 삭제
-- ============================================
DROP TABLE IF EXISTS public.review_rights CASCADE;
-- DROP TABLE IF EXISTS public.user_profiles CASCADE; -- 필요시 주석 해제

-- ============================================
-- PART 3: 함수 보안 수정 (search_path 설정)
-- ============================================

-- handle_reservation_refund
CREATE OR REPLACE FUNCTION public.handle_reservation_refund()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF OLD.status != 'cancelled' AND NEW.status = 'cancelled' THEN
    UPDATE products
    SET reserved_quantity = reserved_quantity - OLD.quantity
    WHERE id = OLD.product_id;

    IF OLD.status = 'confirmed' AND OLD.commission_amount IS NOT NULL THEN
      UPDATE stores
      SET cash_balance = cash_balance + OLD.commission_amount
      WHERE id = OLD.store_id;

      INSERT INTO cash_transactions (store_id, transaction_type, amount, balance_after, reservation_id, description)
      SELECT OLD.store_id, 'refund', OLD.commission_amount, cash_balance, OLD.id, '예약 취소 수수료 환불'
      FROM stores WHERE id = OLD.store_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

-- handle_inventory_restoration
CREATE OR REPLACE FUNCTION public.handle_inventory_restoration()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE products
  SET reserved_quantity = reserved_quantity - OLD.quantity
  WHERE id = OLD.product_id;
  RETURN OLD;
END;
$$;

-- check_reservation_available
CREATE OR REPLACE FUNCTION public.check_reservation_available(p_product_id UUID, p_quantity INT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  available_stock INT;
BEGIN
  SELECT (stock_quantity - reserved_quantity) INTO available_stock
  FROM products
  WHERE id = p_product_id AND is_active = true;
  IF available_stock IS NULL THEN RETURN false; END IF;
  RETURN available_stock >= p_quantity;
END;
$$;

-- toggle_product_status
CREATE OR REPLACE FUNCTION public.toggle_product_status(p_product_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  UPDATE products
  SET is_active = NOT is_active, updated_at = NOW()
  WHERE id = p_product_id
  RETURNING is_active INTO new_status;
  RETURN new_status;
END;
$$;

-- ============================================
-- PART 4: 기존 RLS 정책 삭제
-- ============================================

-- consumers
DROP POLICY IF EXISTS "consumers_select_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_insert_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_update_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_delete_policy" ON public.consumers;
DROP POLICY IF EXISTS "소비자는 자신의 정보만 조회 가능" ON public.consumers;
DROP POLICY IF EXISTS "소비자는 자신의 정보만 수정 가능" ON public.consumers;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.consumers;
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.consumers;
DROP POLICY IF EXISTS "Enable update for users based on user_id" ON public.consumers;
DROP POLICY IF EXISTS "consumers_select_own" ON public.consumers;
DROP POLICY IF EXISTS "consumers_insert_own" ON public.consumers;
DROP POLICY IF EXISTS "consumers_update_own" ON public.consumers;

-- stores
DROP POLICY IF EXISTS "stores_select_policy" ON public.stores;
DROP POLICY IF EXISTS "stores_insert_policy" ON public.stores;
DROP POLICY IF EXISTS "stores_update_policy" ON public.stores;
DROP POLICY IF EXISTS "모든 사용자가 업체 정보 조회 가능" ON public.stores;
DROP POLICY IF EXISTS "업체는 자신의 정보만 수정 가능" ON public.stores;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.stores;
DROP POLICY IF EXISTS "stores_select_all" ON public.stores;
DROP POLICY IF EXISTS "stores_insert_own" ON public.stores;
DROP POLICY IF EXISTS "stores_update_own" ON public.stores;

-- products
DROP POLICY IF EXISTS "products_select_policy" ON public.products;
DROP POLICY IF EXISTS "products_insert_policy" ON public.products;
DROP POLICY IF EXISTS "products_update_policy" ON public.products;
DROP POLICY IF EXISTS "products_delete_policy" ON public.products;
DROP POLICY IF EXISTS "활성 상품 조회 가능" ON public.products;
DROP POLICY IF EXISTS "업체는 자신의 상품만 관리 가능" ON public.products;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.products;
DROP POLICY IF EXISTS "products_select_active" ON public.products;
DROP POLICY IF EXISTS "products_manage_own" ON public.products;

-- reservations
DROP POLICY IF EXISTS "reservations_select_policy" ON public.reservations;
DROP POLICY IF EXISTS "reservations_insert_policy" ON public.reservations;
DROP POLICY IF EXISTS "reservations_update_policy" ON public.reservations;
DROP POLICY IF EXISTS "소비자는 자신의 예약만 조회" ON public.reservations;
DROP POLICY IF EXISTS "업체는 자신의 예약만 조회" ON public.reservations;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reservations;
DROP POLICY IF EXISTS "reservations_select_own" ON public.reservations;
DROP POLICY IF EXISTS "reservations_insert_consumer" ON public.reservations;
DROP POLICY IF EXISTS "reservations_update_own" ON public.reservations;

-- reviews
DROP POLICY IF EXISTS "reviews_select_policy" ON public.reviews;
DROP POLICY IF EXISTS "reviews_insert_policy" ON public.reviews;
DROP POLICY IF EXISTS "reviews_update_policy" ON public.reviews;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reviews;
DROP POLICY IF EXISTS "reviews_select_all" ON public.reviews;
DROP POLICY IF EXISTS "reviews_insert_own" ON public.reviews;
DROP POLICY IF EXISTS "reviews_update_own" ON public.reviews;

-- cash_transactions
DROP POLICY IF EXISTS "cash_transactions_select_policy" ON public.cash_transactions;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.cash_transactions;
DROP POLICY IF EXISTS "cash_transactions_select_own" ON public.cash_transactions;

-- favorites
DROP POLICY IF EXISTS "favorites_select_policy" ON public.favorites;
DROP POLICY IF EXISTS "favorites_insert_policy" ON public.favorites;
DROP POLICY IF EXISTS "favorites_delete_policy" ON public.favorites;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.favorites;
DROP POLICY IF EXISTS "favorites_select_own" ON public.favorites;
DROP POLICY IF EXISTS "favorites_insert_own" ON public.favorites;
DROP POLICY IF EXISTS "favorites_delete_own" ON public.favorites;

-- store_operating_hours
DROP POLICY IF EXISTS "store_operating_hours_select_policy" ON public.store_operating_hours;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.store_operating_hours;
DROP POLICY IF EXISTS "operating_hours_select_all" ON public.store_operating_hours;
DROP POLICY IF EXISTS "operating_hours_manage_own" ON public.store_operating_hours;

-- ============================================
-- PART 5: 새로운 최적화된 RLS 정책 생성
-- ============================================

-- consumers
ALTER TABLE public.consumers ENABLE ROW LEVEL SECURITY;
CREATE POLICY "consumers_select_own" ON public.consumers FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "consumers_insert_own" ON public.consumers FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "consumers_update_own" ON public.consumers FOR UPDATE USING (auth.uid() = user_id);

-- stores
ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;
CREATE POLICY "stores_select_all" ON public.stores FOR SELECT USING (true);
CREATE POLICY "stores_insert_own" ON public.stores FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "stores_update_own" ON public.stores FOR UPDATE USING (auth.uid() = user_id);

-- products
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "products_select_active" ON public.products FOR SELECT USING (
  is_active = true OR EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
);
CREATE POLICY "products_manage_own" ON public.products FOR ALL USING (
  EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
);

-- reservations
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;
CREATE POLICY "reservations_select_own" ON public.reservations FOR SELECT USING (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reservations.consumer_id AND consumers.user_id = auth.uid())
  OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reservations.store_id AND stores.user_id = auth.uid())
);
CREATE POLICY "reservations_insert_consumer" ON public.reservations FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
);
CREATE POLICY "reservations_update_own" ON public.reservations FOR UPDATE USING (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reservations.consumer_id AND consumers.user_id = auth.uid())
  OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reservations.store_id AND stores.user_id = auth.uid())
);

-- reviews
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
CREATE POLICY "reviews_select_all" ON public.reviews FOR SELECT USING (is_deleted = false);
CREATE POLICY "reviews_insert_own" ON public.reviews FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
);
CREATE POLICY "reviews_update_own" ON public.reviews FOR UPDATE USING (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reviews.consumer_id AND consumers.user_id = auth.uid())
  OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reviews.store_id AND stores.user_id = auth.uid())
);

-- cash_transactions
ALTER TABLE public.cash_transactions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "cash_transactions_select_own" ON public.cash_transactions FOR SELECT USING (
  EXISTS (SELECT 1 FROM stores WHERE stores.id = cash_transactions.store_id AND stores.user_id = auth.uid())
);

-- favorites
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
CREATE POLICY "favorites_select_own" ON public.favorites FOR SELECT USING (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = favorites.consumer_id AND consumers.user_id = auth.uid())
);
CREATE POLICY "favorites_insert_own" ON public.favorites FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
);
CREATE POLICY "favorites_delete_own" ON public.favorites FOR DELETE USING (
  EXISTS (SELECT 1 FROM consumers WHERE consumers.id = favorites.consumer_id AND consumers.user_id = auth.uid())
);

-- store_operating_hours
ALTER TABLE public.store_operating_hours ENABLE ROW LEVEL SECURITY;
CREATE POLICY "operating_hours_select_all" ON public.store_operating_hours FOR SELECT USING (true);
CREATE POLICY "operating_hours_manage_own" ON public.store_operating_hours FOR ALL USING (
  EXISTS (SELECT 1 FROM stores WHERE stores.id = store_operating_hours.store_id AND stores.user_id = auth.uid())
);

-- ============================================
-- PART 6: 인덱스 최적화
-- ============================================
CREATE INDEX IF NOT EXISTS idx_consumers_user_id ON public.consumers(user_id);
CREATE INDEX IF NOT EXISTS idx_stores_user_id ON public.stores(user_id);
CREATE INDEX IF NOT EXISTS idx_stores_status ON public.stores(status);
CREATE INDEX IF NOT EXISTS idx_products_store_id ON public.products(store_id);
CREATE INDEX IF NOT EXISTS idx_products_active ON public.products(store_id, is_active);
CREATE INDEX IF NOT EXISTS idx_reservations_consumer ON public.reservations(consumer_id);
CREATE INDEX IF NOT EXISTS idx_reservations_store ON public.reservations(store_id);
CREATE INDEX IF NOT EXISTS idx_reservations_status ON public.reservations(status);
CREATE INDEX IF NOT EXISTS idx_reviews_store ON public.reviews(store_id);
CREATE INDEX IF NOT EXISTS idx_cash_transactions_store ON public.cash_transactions(store_id);
CREATE INDEX IF NOT EXISTS idx_favorites_consumer ON public.favorites(consumer_id);

-- ============================================
-- 완료!
-- ============================================
SELECT '정리 완료! Security Advisor를 새로고침하여 확인하세요.' as result;
</file>

<file path="docs/SUPABASE-CLEANUP.md">
# Supabase 정리 및 최적화 가이드

> **작성일**: 2026-01-18
> **목적**: Security Advisor 오류/경고 해결 및 DB 최적화

---

## 실행 방법

1. Supabase 대시보드 접속: https://supabase.com/dashboard
2. 프로젝트 선택
3. 왼쪽 메뉴 → **SQL Editor** 클릭
4. **New Query** 클릭
5. 아래 SQL을 **순서대로** 복사하여 실행

---

## 1단계: 현재 상태 확인 (선택사항)

먼저 현재 DB에 어떤 것들이 있는지 확인합니다.

```sql
-- ============================================
-- 1단계: 현재 상태 확인 (읽기 전용)
-- ============================================

-- 1-1. 모든 테이블 목록
SELECT table_name,
       (SELECT COUNT(*) FROM information_schema.columns WHERE table_name = t.table_name) as column_count
FROM information_schema.tables t
WHERE table_schema = 'public'
  AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- 1-2. 모든 뷰 목록
SELECT table_name as view_name
FROM information_schema.views
WHERE table_schema = 'public'
ORDER BY table_name;

-- 1-3. 모든 함수 목록
SELECT routine_name as function_name
FROM information_schema.routines
WHERE routine_schema = 'public'
  AND routine_type = 'FUNCTION'
ORDER BY routine_name;

-- 1-4. RLS 정책 목록
SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;
```

---

## 2단계: 불필요한 뷰 삭제

Security Definer View 오류를 해결합니다.

```sql
-- ============================================
-- 2단계: 불필요한 뷰 삭제
-- ============================================

-- 문제가 되는 뷰들 삭제 (사용하지 않는 경우)
DROP VIEW IF EXISTS public.store_cash_summary CASCADE;
DROP VIEW IF EXISTS public.stores_with_status CASCADE;
DROP VIEW IF EXISTS public.reservation_stats CASCADE;

-- 확인
SELECT table_name as view_name
FROM information_schema.views
WHERE table_schema = 'public';
```

---

## 3단계: 불필요한 테이블 정리

RLS가 비활성화된 테이블을 정리합니다.

```sql
-- ============================================
-- 3단계: 불필요한 테이블 정리
-- ============================================

-- review_rights 테이블이 사용되지 않는다면 삭제
DROP TABLE IF EXISTS public.review_rights CASCADE;

-- user_profiles 테이블이 사용되지 않는다면 삭제 (consumers와 중복될 수 있음)
-- DROP TABLE IF EXISTS public.user_profiles CASCADE;

-- 확인: 남은 테이블 목록
SELECT table_name
FROM information_schema.tables
WHERE table_schema = 'public'
  AND table_type = 'BASE TABLE'
ORDER BY table_name;
```

---

## 4단계: 함수 보안 수정

Function Search Path 경고를 해결합니다.

```sql
-- ============================================
-- 4단계: 함수 보안 수정 (search_path 설정)
-- ============================================

-- 4-1. handle_reservation_refund 함수 수정
CREATE OR REPLACE FUNCTION public.handle_reservation_refund()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- 예약 취소 시 재고 복구 및 수수료 환불 로직
  IF OLD.status != 'cancelled' AND NEW.status = 'cancelled' THEN
    -- 재고 복구
    UPDATE products
    SET reserved_quantity = reserved_quantity - OLD.quantity
    WHERE id = OLD.product_id;

    -- 수수료가 차감되었던 경우 환불 (confirmed 상태였던 경우)
    IF OLD.status = 'confirmed' AND OLD.commission_amount IS NOT NULL THEN
      UPDATE stores
      SET cash_balance = cash_balance + OLD.commission_amount
      WHERE id = OLD.store_id;

      INSERT INTO cash_transactions (store_id, transaction_type, amount, balance_after, reservation_id, description)
      SELECT OLD.store_id, 'refund', OLD.commission_amount, cash_balance, OLD.id, '예약 취소 수수료 환불'
      FROM stores WHERE id = OLD.store_id;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;

-- 4-2. handle_inventory_restoration 함수 수정
CREATE OR REPLACE FUNCTION public.handle_inventory_restoration()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- 예약 삭제 시 재고 복구
  UPDATE products
  SET reserved_quantity = reserved_quantity - OLD.quantity
  WHERE id = OLD.product_id;

  RETURN OLD;
END;
$$;

-- 4-3. check_reservation_available 함수 수정
CREATE OR REPLACE FUNCTION public.check_reservation_available(p_product_id UUID, p_quantity INT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  available_stock INT;
BEGIN
  SELECT (stock_quantity - reserved_quantity) INTO available_stock
  FROM products
  WHERE id = p_product_id AND is_active = true;

  IF available_stock IS NULL THEN
    RETURN false;
  END IF;

  RETURN available_stock >= p_quantity;
END;
$$;

-- 4-4. toggle_product_status 함수 수정
CREATE OR REPLACE FUNCTION public.toggle_product_status(p_product_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  UPDATE products
  SET is_active = NOT is_active,
      updated_at = NOW()
  WHERE id = p_product_id
  RETURNING is_active INTO new_status;

  RETURN new_status;
END;
$$;
```

---

## 5단계: RLS 정책 최적화

중복된 정책 제거 및 성능 최적화를 수행합니다.

```sql
-- ============================================
-- 5단계: RLS 정책 최적화
-- ============================================

-- 5-1. 기존 RLS 정책 모두 삭제 (테이블별)
-- consumers
DROP POLICY IF EXISTS "consumers_select_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_insert_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_update_policy" ON public.consumers;
DROP POLICY IF EXISTS "consumers_delete_policy" ON public.consumers;
DROP POLICY IF EXISTS "소비자는 자신의 정보만 조회 가능" ON public.consumers;
DROP POLICY IF EXISTS "소비자는 자신의 정보만 수정 가능" ON public.consumers;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.consumers;
DROP POLICY IF EXISTS "Enable insert for authenticated users only" ON public.consumers;
DROP POLICY IF EXISTS "Enable update for users based on user_id" ON public.consumers;

-- stores
DROP POLICY IF EXISTS "stores_select_policy" ON public.stores;
DROP POLICY IF EXISTS "stores_insert_policy" ON public.stores;
DROP POLICY IF EXISTS "stores_update_policy" ON public.stores;
DROP POLICY IF EXISTS "모든 사용자가 업체 정보 조회 가능" ON public.stores;
DROP POLICY IF EXISTS "업체는 자신의 정보만 수정 가능" ON public.stores;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.stores;

-- products
DROP POLICY IF EXISTS "products_select_policy" ON public.products;
DROP POLICY IF EXISTS "products_insert_policy" ON public.products;
DROP POLICY IF EXISTS "products_update_policy" ON public.products;
DROP POLICY IF EXISTS "products_delete_policy" ON public.products;
DROP POLICY IF EXISTS "활성 상품 조회 가능" ON public.products;
DROP POLICY IF EXISTS "업체는 자신의 상품만 관리 가능" ON public.products;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.products;

-- reservations
DROP POLICY IF EXISTS "reservations_select_policy" ON public.reservations;
DROP POLICY IF EXISTS "reservations_insert_policy" ON public.reservations;
DROP POLICY IF EXISTS "reservations_update_policy" ON public.reservations;
DROP POLICY IF EXISTS "소비자는 자신의 예약만 조회" ON public.reservations;
DROP POLICY IF EXISTS "업체는 자신의 예약만 조회" ON public.reservations;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reservations;

-- reviews
DROP POLICY IF EXISTS "reviews_select_policy" ON public.reviews;
DROP POLICY IF EXISTS "reviews_insert_policy" ON public.reviews;
DROP POLICY IF EXISTS "reviews_update_policy" ON public.reviews;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.reviews;

-- cash_transactions
DROP POLICY IF EXISTS "cash_transactions_select_policy" ON public.cash_transactions;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.cash_transactions;

-- favorites
DROP POLICY IF EXISTS "favorites_select_policy" ON public.favorites;
DROP POLICY IF EXISTS "favorites_insert_policy" ON public.favorites;
DROP POLICY IF EXISTS "favorites_delete_policy" ON public.favorites;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.favorites;

-- store_operating_hours
DROP POLICY IF EXISTS "store_operating_hours_select_policy" ON public.store_operating_hours;
DROP POLICY IF EXISTS "Enable read access for all users" ON public.store_operating_hours;
```

---

## 6단계: 최적화된 RLS 정책 생성

성능을 고려한 새로운 RLS 정책을 생성합니다.

```sql
-- ============================================
-- 6단계: 최적화된 RLS 정책 생성
-- ============================================

-- 6-1. consumers 테이블
ALTER TABLE public.consumers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "consumers_select_own" ON public.consumers
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "consumers_insert_own" ON public.consumers
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "consumers_update_own" ON public.consumers
  FOR UPDATE USING (auth.uid() = user_id);

-- 6-2. stores 테이블
ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;

CREATE POLICY "stores_select_all" ON public.stores
  FOR SELECT USING (true);

CREATE POLICY "stores_insert_own" ON public.stores
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "stores_update_own" ON public.stores
  FOR UPDATE USING (auth.uid() = user_id);

-- 6-3. products 테이블
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

CREATE POLICY "products_select_active" ON public.products
  FOR SELECT USING (
    is_active = true
    OR EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = products.store_id
        AND stores.user_id = auth.uid()
    )
  );

CREATE POLICY "products_manage_own" ON public.products
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = products.store_id
        AND stores.user_id = auth.uid()
    )
  );

-- 6-4. reservations 테이블
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "reservations_select_own" ON public.reservations
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = reservations.consumer_id
        AND consumers.user_id = auth.uid()
    )
    OR EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = reservations.store_id
        AND stores.user_id = auth.uid()
    )
  );

CREATE POLICY "reservations_insert_consumer" ON public.reservations
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = consumer_id
        AND consumers.user_id = auth.uid()
    )
  );

CREATE POLICY "reservations_update_own" ON public.reservations
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = reservations.consumer_id
        AND consumers.user_id = auth.uid()
    )
    OR EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = reservations.store_id
        AND stores.user_id = auth.uid()
    )
  );

-- 6-5. reviews 테이블
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

CREATE POLICY "reviews_select_all" ON public.reviews
  FOR SELECT USING (is_deleted = false);

CREATE POLICY "reviews_insert_own" ON public.reviews
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = consumer_id
        AND consumers.user_id = auth.uid()
    )
  );

CREATE POLICY "reviews_update_own" ON public.reviews
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = reviews.consumer_id
        AND consumers.user_id = auth.uid()
    )
    OR EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = reviews.store_id
        AND stores.user_id = auth.uid()
    )
  );

-- 6-6. cash_transactions 테이블
ALTER TABLE public.cash_transactions ENABLE ROW LEVEL SECURITY;

CREATE POLICY "cash_transactions_select_own" ON public.cash_transactions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = cash_transactions.store_id
        AND stores.user_id = auth.uid()
    )
  );

-- 6-7. favorites 테이블
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;

CREATE POLICY "favorites_select_own" ON public.favorites
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = favorites.consumer_id
        AND consumers.user_id = auth.uid()
    )
  );

CREATE POLICY "favorites_insert_own" ON public.favorites
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = consumer_id
        AND consumers.user_id = auth.uid()
    )
  );

CREATE POLICY "favorites_delete_own" ON public.favorites
  FOR DELETE USING (
    EXISTS (
      SELECT 1 FROM consumers
      WHERE consumers.id = favorites.consumer_id
        AND consumers.user_id = auth.uid()
    )
  );

-- 6-8. store_operating_hours 테이블
ALTER TABLE public.store_operating_hours ENABLE ROW LEVEL SECURITY;

CREATE POLICY "operating_hours_select_all" ON public.store_operating_hours
  FOR SELECT USING (true);

CREATE POLICY "operating_hours_manage_own" ON public.store_operating_hours
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM stores
      WHERE stores.id = store_operating_hours.store_id
        AND stores.user_id = auth.uid()
    )
  );
```

---

## 7단계: 트리거 정리

중복되거나 불필요한 트리거를 정리합니다.

```sql
-- ============================================
-- 7단계: 트리거 정리
-- ============================================

-- 기존 트리거 확인
SELECT trigger_name, event_manipulation, event_object_table, action_statement
FROM information_schema.triggers
WHERE trigger_schema = 'public'
ORDER BY event_object_table, trigger_name;

-- 중복 트리거 삭제 (필요한 경우)
-- DROP TRIGGER IF EXISTS [트리거명] ON [테이블명];
```

---

## 8단계: 인덱스 최적화

성능을 위한 인덱스를 확인하고 추가합니다.

```sql
-- ============================================
-- 8단계: 인덱스 최적화
-- ============================================

-- 기존 인덱스 확인
SELECT indexname, tablename, indexdef
FROM pg_indexes
WHERE schemaname = 'public'
ORDER BY tablename, indexname;

-- 필요한 인덱스 추가 (없는 경우에만 실행)
CREATE INDEX IF NOT EXISTS idx_consumers_user_id ON public.consumers(user_id);
CREATE INDEX IF NOT EXISTS idx_stores_user_id ON public.stores(user_id);
CREATE INDEX IF NOT EXISTS idx_stores_status ON public.stores(status);
CREATE INDEX IF NOT EXISTS idx_products_store_id ON public.products(store_id);
CREATE INDEX IF NOT EXISTS idx_products_active ON public.products(store_id, is_active);
CREATE INDEX IF NOT EXISTS idx_reservations_consumer ON public.reservations(consumer_id);
CREATE INDEX IF NOT EXISTS idx_reservations_store ON public.reservations(store_id);
CREATE INDEX IF NOT EXISTS idx_reservations_status ON public.reservations(status);
CREATE INDEX IF NOT EXISTS idx_reviews_store ON public.reviews(store_id);
CREATE INDEX IF NOT EXISTS idx_cash_transactions_store ON public.cash_transactions(store_id);
CREATE INDEX IF NOT EXISTS idx_favorites_consumer ON public.favorites(consumer_id);
```

---

## 9단계: Auth 설정 (대시보드에서 수동 설정)

**Leaked Password Protection** 경고 해결:

1. Supabase 대시보드 → **Authentication** → **Providers**
2. **Email** 섹션 클릭
3. **Leaked Password Protection** 토글 **활성화**

---

## 10단계: 최종 확인

모든 정리 후 경고가 해결되었는지 확인합니다.

```sql
-- ============================================
-- 10단계: 최종 확인
-- ============================================

-- 남은 테이블 확인
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public' AND table_type = 'BASE TABLE'
ORDER BY table_name;

-- 남은 뷰 확인
SELECT table_name as view_name FROM information_schema.views
WHERE table_schema = 'public';

-- RLS 정책 확인
SELECT tablename, policyname, cmd FROM pg_policies
WHERE schemaname = 'public'
ORDER BY tablename, policyname;

-- 함수 확인
SELECT routine_name FROM information_schema.routines
WHERE routine_schema = 'public' AND routine_type = 'FUNCTION';
```

---

## 문제 해결 체크리스트

실행 후 Security Advisor에서 확인:

- [ ] Security Definer View 오류 0개
- [ ] RLS Disabled 오류 0개
- [ ] Function Search Path 경고 0개
- [ ] RLS Policy Always True 경고 0개
- [ ] Multiple Permissive Policies 경고 감소
- [ ] Leaked Password Protection 활성화

---

## 주의사항

1. **백업 권장**: 중요한 데이터가 있다면 실행 전 백업
2. **순서대로 실행**: 단계별로 순서대로 실행해야 오류 방지
3. **오류 발생 시**: 해당 객체가 이미 없거나 다른 이름일 수 있음 - 무시하고 진행

---

**문서 작성**: 팀장 에이전트
**작성일**: 2026-01-18
</file>

<file path="docs/supabase-final-fix.sql">
-- ============================================
-- Supabase 최종 정리 SQL (z6 분석 기반)
-- 작성일: 2026-01-18
-- 모든 중복 정책 삭제 후 최적화된 정책 재생성
-- ============================================

-- ============================================
-- STEP 1: 모든 기존 RLS 정책 삭제
-- ============================================

-- cash_transactions
DROP POLICY IF EXISTS "stores_view_own_transactions" ON public.cash_transactions;
DROP POLICY IF EXISTS "cash_transactions_select_own" ON public.cash_transactions;

-- consumers (5개 중복)
DROP POLICY IF EXISTS "Users can insert their own consumer data" ON public.consumers;
DROP POLICY IF EXISTS "Users can update their own consumer data" ON public.consumers;
DROP POLICY IF EXISTS "Users can view their own consumer data" ON public.consumers;
DROP POLICY IF EXISTS "authenticated_users_full_access" ON public.consumers;
DROP POLICY IF EXISTS "소비자는 자신의 정보만 조회" ON public.consumers;
DROP POLICY IF EXISTS "consumers_select_own" ON public.consumers;
DROP POLICY IF EXISTS "consumers_insert_own" ON public.consumers;
DROP POLICY IF EXISTS "consumers_update_own" ON public.consumers;

-- favorites
DROP POLICY IF EXISTS "소비자는 자신의 즐겨찾기 삭제 가능" ON public.favorites;
DROP POLICY IF EXISTS "소비자는 즐겨찾기 추가 가능" ON public.favorites;
DROP POLICY IF EXISTS "favorites_select_own" ON public.favorites;
DROP POLICY IF EXISTS "favorites_insert_own" ON public.favorites;
DROP POLICY IF EXISTS "favorites_delete_own" ON public.favorites;

-- products
DROP POLICY IF EXISTS "products_read_all" ON public.products;
DROP POLICY IF EXISTS "products_modify_owner" ON public.products;
DROP POLICY IF EXISTS "products_select_active" ON public.products;
DROP POLICY IF EXISTS "products_manage_own" ON public.products;

-- reservations
DROP POLICY IF EXISTS "reservations_store_access" ON public.reservations;
DROP POLICY IF EXISTS "reservations_consumer_access" ON public.reservations;
DROP POLICY IF EXISTS "reservations_select_own" ON public.reservations;
DROP POLICY IF EXISTS "reservations_insert_consumer" ON public.reservations;
DROP POLICY IF EXISTS "reservations_update_own" ON public.reservations;

-- reviews (6개 중복)
DROP POLICY IF EXISTS "reviews_read_all" ON public.reviews;
DROP POLICY IF EXISTS "reviews_select_all" ON public.reviews;
DROP POLICY IF EXISTS "reviews_store_reply" ON public.reviews;
DROP POLICY IF EXISTS "reviews_update_own" ON public.reviews;
DROP POLICY IF EXISTS "reviews_consumer_insert" ON public.reviews;
DROP POLICY IF EXISTS "reviews_insert_own" ON public.reviews;

-- store_operating_hours (4개 중복)
DROP POLICY IF EXISTS "operating_hours_read_all" ON public.store_operating_hours;
DROP POLICY IF EXISTS "누구나 영업시간 조회 가능" ON public.store_operating_hours;
DROP POLICY IF EXISTS "업주는 자신의 영업시간 수정 가능" ON public.store_operating_hours;
DROP POLICY IF EXISTS "operating_hours_modify_owner" ON public.store_operating_hours;
DROP POLICY IF EXISTS "operating_hours_select_all" ON public.store_operating_hours;
DROP POLICY IF EXISTS "operating_hours_manage_own" ON public.store_operating_hours;

-- stores
DROP POLICY IF EXISTS "모든 사용자가 업체 조회 가능" ON public.stores;
DROP POLICY IF EXISTS "stores_select_all" ON public.stores;
DROP POLICY IF EXISTS "stores_insert_own" ON public.stores;
DROP POLICY IF EXISTS "stores_update_own" ON public.stores;

-- user_profiles (문제의 테이블)
DROP POLICY IF EXISTS "authenticated_users_full_access" ON public.user_profiles;

-- ============================================
-- STEP 2: RLS 활성화 확인
-- ============================================

ALTER TABLE public.cash_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.consumers ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.favorites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.store_operating_hours ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.stores ENABLE ROW LEVEL SECURITY;

-- user_profiles가 존재하면 RLS 활성화
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_profiles' AND table_schema = 'public') THEN
    ALTER TABLE public.user_profiles ENABLE ROW LEVEL SECURITY;
  END IF;
END $$;

-- ============================================
-- STEP 3: 최적화된 RLS 정책 생성 (중복 없이)
-- ============================================

-- ============================================
-- 3-1. consumers (소비자)
-- ============================================
CREATE POLICY "consumers_policy_select" ON public.consumers
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "consumers_policy_insert" ON public.consumers
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "consumers_policy_update" ON public.consumers
  FOR UPDATE USING (auth.uid() = user_id);

-- ============================================
-- 3-2. stores (업체)
-- ============================================
CREATE POLICY "stores_policy_select" ON public.stores
  FOR SELECT USING (true);

CREATE POLICY "stores_policy_insert" ON public.stores
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "stores_policy_update" ON public.stores
  FOR UPDATE USING (auth.uid() = user_id);

-- ============================================
-- 3-3. products (상품)
-- ============================================
CREATE POLICY "products_policy_select" ON public.products
  FOR SELECT USING (
    is_active = true
    OR EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "products_policy_insert" ON public.products
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "products_policy_update" ON public.products
  FOR UPDATE USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "products_policy_delete" ON public.products
  FOR DELETE USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
  );

-- ============================================
-- 3-4. reservations (예약)
-- ============================================
CREATE POLICY "reservations_policy_select" ON public.reservations
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reservations.consumer_id AND consumers.user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reservations.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "reservations_policy_insert" ON public.reservations
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
  );

CREATE POLICY "reservations_policy_update" ON public.reservations
  FOR UPDATE USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reservations.consumer_id AND consumers.user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reservations.store_id AND stores.user_id = auth.uid())
  );

-- ============================================
-- 3-5. reviews (리뷰)
-- ============================================
CREATE POLICY "reviews_policy_select" ON public.reviews
  FOR SELECT USING (true);

CREATE POLICY "reviews_policy_insert" ON public.reviews
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
  );

CREATE POLICY "reviews_policy_update" ON public.reviews
  FOR UPDATE USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reviews.consumer_id AND consumers.user_id = auth.uid())
    OR EXISTS (SELECT 1 FROM stores WHERE stores.id = reviews.store_id AND stores.user_id = auth.uid())
  );

-- ============================================
-- 3-6. cash_transactions (캐시 거래)
-- ============================================
CREATE POLICY "cash_transactions_policy_select" ON public.cash_transactions
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = cash_transactions.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "cash_transactions_policy_insert" ON public.cash_transactions
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = store_id AND stores.user_id = auth.uid())
  );

-- ============================================
-- 3-7. favorites (즐겨찾기)
-- ============================================
CREATE POLICY "favorites_policy_select" ON public.favorites
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = favorites.consumer_id AND consumers.user_id = auth.uid())
  );

CREATE POLICY "favorites_policy_insert" ON public.favorites
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = consumer_id AND consumers.user_id = auth.uid())
  );

CREATE POLICY "favorites_policy_delete" ON public.favorites
  FOR DELETE USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = favorites.consumer_id AND consumers.user_id = auth.uid())
  );

-- ============================================
-- 3-8. store_operating_hours (영업시간)
-- ============================================
CREATE POLICY "operating_hours_policy_select" ON public.store_operating_hours
  FOR SELECT USING (true);

CREATE POLICY "operating_hours_policy_insert" ON public.store_operating_hours
  FOR INSERT WITH CHECK (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "operating_hours_policy_update" ON public.store_operating_hours
  FOR UPDATE USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = store_operating_hours.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "operating_hours_policy_delete" ON public.store_operating_hours
  FOR DELETE USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = store_operating_hours.store_id AND stores.user_id = auth.uid())
  );

-- ============================================
-- 3-9. user_profiles (존재하면 처리)
-- ============================================
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = 'user_profiles' AND table_schema = 'public') THEN
    EXECUTE 'CREATE POLICY "user_profiles_policy_select" ON public.user_profiles FOR SELECT USING (auth.uid() = user_id)';
    EXECUTE 'CREATE POLICY "user_profiles_policy_update" ON public.user_profiles FOR UPDATE USING (auth.uid() = user_id)';
  END IF;
EXCEPTION WHEN OTHERS THEN
  NULL;
END $$;

-- ============================================
-- STEP 4: 불필요한 뷰 삭제 (Security Definer View 오류 해결)
-- ============================================
DROP VIEW IF EXISTS public.store_cash_summary CASCADE;
DROP VIEW IF EXISTS public.stores_with_status CASCADE;
DROP VIEW IF EXISTS public.reservation_stats CASCADE;

-- ============================================
-- STEP 5: 함수 search_path 수정
-- ============================================

-- handle_reservation_refund
CREATE OR REPLACE FUNCTION public.handle_reservation_refund()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  IF OLD.status != 'cancelled' AND NEW.status = 'cancelled' THEN
    UPDATE products SET reserved_quantity = reserved_quantity - OLD.quantity WHERE id = OLD.product_id;
    IF OLD.status = 'confirmed' AND OLD.commission_amount IS NOT NULL THEN
      UPDATE stores SET cash_balance = cash_balance + OLD.commission_amount WHERE id = OLD.store_id;
      INSERT INTO cash_transactions (store_id, transaction_type, amount, balance_after, reservation_id, description)
      SELECT OLD.store_id, 'refund', OLD.commission_amount, cash_balance, OLD.id, '예약 취소 수수료 환불' FROM stores WHERE id = OLD.store_id;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;

-- handle_inventory_restoration
CREATE OR REPLACE FUNCTION public.handle_inventory_restoration()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  UPDATE products SET reserved_quantity = reserved_quantity - OLD.quantity WHERE id = OLD.product_id;
  RETURN OLD;
END;
$$;

-- check_reservation_available
CREATE OR REPLACE FUNCTION public.check_reservation_available(p_product_id UUID, p_quantity INT)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  available_stock INT;
BEGIN
  SELECT (stock_quantity - reserved_quantity) INTO available_stock FROM products WHERE id = p_product_id AND is_active = true;
  IF available_stock IS NULL THEN RETURN false; END IF;
  RETURN available_stock >= p_quantity;
END;
$$;

-- toggle_product_status
CREATE OR REPLACE FUNCTION public.toggle_product_status(p_product_id UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  new_status BOOLEAN;
BEGIN
  UPDATE products SET is_active = NOT is_active, updated_at = NOW() WHERE id = p_product_id RETURNING is_active INTO new_status;
  RETURN new_status;
END;
$$;

-- ============================================
-- 완료 확인
-- ============================================
SELECT 'RLS 정책 최적화 완료!' as result;

-- 정책 개수 확인
SELECT tablename, COUNT(*) as policy_count
FROM pg_policies
WHERE schemaname = 'public'
GROUP BY tablename
ORDER BY tablename;
</file>

<file path="docs/Test-Plan.md">
# 재고 할인 중개 플랫폼 테스트 계획서

> **문서 버전**: 1.0
> **작성일**: 2026-01-17
> **프로젝트명**: 재고 할인 중개 플랫폼 (투굿투고 유사 서비스)
> **현재 상태**: MVP 90% 완료

---

## 1. 개요

### 1.1 목적
- 소프트웨어 품질 보증
- 요구사항 충족 검증
- 결함 조기 발견
- 사용자 경험 품질 확보

### 1.2 범위

#### 테스트 대상
| 구분 | 기능 | 화면 파일 |
|------|------|----------|
| 인증 | 로그인, 회원가입 | LoginScreen, ConsumerSignupScreen, StoreSignupScreen |
| 소비자 | 업체 탐색, 예약, 리뷰 | StoreListHome, StoreDetail, ReservationScreen, MyReservations, ReviewScreen |
| 업주 | 상품/예약/캐시 관리 | StoreDashboard, StoreProductManagement, StoreReservationManagement, StoreCashManagement |
| 공통 | 마이페이지, 프로필 | MyPageScreen, ProfileEditScreen |

#### 제외 항목
| 제외 기능 | 제외 사유 |
|----------|----------|
| 운영자 대시보드 | 미구현 상태 |
| 지도 기반 탐색 | Phase 2 예정 |
| 실결제 (토스페이먼츠) | 연동 미완료, 데모 모드 |
| 푸시 알림 | Phase 2 예정 |

### 1.3 테스트 환경

| 환경 | 용도 | 설정 |
|------|------|------|
| Development | 개발 테스트 | Expo Go + localhost |
| Device | 실기기 테스트 | iOS/Android 실기기 |
| Supabase | 백엔드 | qycwdncplofgzdrjtklb.supabase.co |

---

## 2. 테스트 전략

### 2.1 테스트 피라미드

```
        /\
       /  \     수동 E2E (10%)
      /----\    - 핵심 플로우 검증
     /      \
    /--------\  API 테스트 (30%)
   /          \ - Supabase RPC/쿼리
  /------------\
 /              \ 컴포넌트 테스트 (60%)
/----------------\- 화면별 기능 검증
```

### 2.2 테스트 유형별 전략

| 유형 | 도구 | 대상 | 담당 |
|------|------|------|------|
| 컴포넌트 테스트 | 수동 | 26개 화면 | 테스터 |
| API 테스트 | Supabase Dashboard | RPC 함수, 쿼리 | 개발자 |
| E2E 테스트 | Expo Go | 핵심 플로우 | 테스터 |
| 회귀 테스트 | 체크리스트 | 버그 수정 후 | 개발자 |

---

## 3. 테스트 계정

### 3.1 테스트 계정 목록

| 유형 | 이메일 | 비밀번호 | 용도 |
|------|--------|----------|------|
| 소비자 | consumer@test.com | test1234 | 소비자 플로우 테스트 |
| 업주 | storeowner@gmail.com | store1234 | 업주 플로우 테스트 |
| 신규 소비자 | newuser@test.com | test1234 | 회원가입 테스트 |

### 3.2 테스트 데이터

#### 테스트 업체
- **업체명**: 테스트베이커리
- **주소**: 서울시 강남구
- **캐시 잔액**: 1,000,000원

#### 테스트 상품
| 상품명 | 정가 | 할인가 | 재고 | 카테고리 |
|--------|------|--------|------|----------|
| 크로와상 | 5,000원 | 3,000원 | 10개 | 빵 |
| 식빵 | 4,000원 | 2,500원 | 5개 | 빵 |
| 케이크 | 25,000원 | 15,000원 | 3개 | 빵 |

---

## 4. 핵심 사용자 플로우 테스트

### 4.1 소비자 플로우

#### Flow 1: 회원가입 → 로그인
```
1. 앱 실행
2. "회원가입" 버튼 클릭
3. "일반 고객" 선택
4. 이메일, 비밀번호, 닉네임 입력
5. 회원가입 완료 확인
6. 로그인 화면으로 이동
7. 이메일/비밀번호 입력
8. 로그인 성공 → StoreListHome 표시
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 3 | 유형 선택 화면 | 일반 고객/사장님 옵션 표시 | ☐ |
| 5 | 회원가입 API | consumers 테이블에 레코드 생성 | ☐ |
| 8 | 로그인 후 화면 | 업체 리스트 표시 | ☐ |

#### Flow 2: 업체 탐색 → 예약
```
1. StoreListHome에서 업체 목록 확인
2. 검색창에 "베이커리" 입력
3. 검색 결과 확인
4. 업체 카드 클릭 → StoreDetail
5. 상품 목록 확인
6. "예약하기" 버튼 클릭
7. 수량 선택 (2개)
8. 픽업 시간 선택
9. 예약 확정
10. 예약 번호 확인
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 1 | 업체 목록 | 승인된 업체만 표시 | ☐ |
| 3 | 검색 기능 | 검색어 포함 업체 표시 | ☐ |
| 5 | 상품 목록 | 활성 상품만 표시, 재고 확인 | ☐ |
| 9 | 예약 생성 | 예약번호 R+날짜+일련번호 형식 | ☐ |
| 9 | 재고 차감 | reserved_quantity 증가 | ☐ |

#### Flow 3: 예약 확인 → 리뷰 작성
```
1. MyReservations 화면 접근
2. 예약 목록에서 "완료됨" 예약 확인
3. "리뷰 작성" 버튼 클릭
4. 별점 4점 선택
5. 리뷰 내용 작성
6. 저장
7. 업체 상세에서 리뷰 확인
8. 업체 평균 평점 업데이트 확인
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 2 | 예약 상태 구분 | pending/confirmed/completed/cancelled 표시 | ☐ |
| 3 | 리뷰 버튼 | 완료된 예약만 리뷰 작성 가능 | ☐ |
| 6 | 리뷰 저장 | reviews 테이블에 저장 | ☐ |
| 8 | 평점 업데이트 | stores.average_rating 자동 갱신 | ☐ |

### 4.2 업주 플로우

#### Flow 4: 업주 로그인 → 대시보드
```
1. 업주 계정으로 로그인
2. StoreListHome 표시 (소비자 화면과 동일)
3. 마이페이지 접근
4. "사장님 페이지" 버튼 클릭
5. StoreDashboard 표시
6. 통계 정보 확인 (예약 수, 매출, 상품 수)
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 2 | 통합 UX | 업주도 소비자 화면 사용 가능 | ☐ |
| 4 | 사장님 페이지 버튼 | 업주만 버튼 표시됨 | ☐ |
| 6 | 대시보드 통계 | 실시간 데이터 표시 | ☐ |

#### Flow 5: 상품 등록 → 수정 → 삭제
```
1. StoreDashboard → 상품 관리
2. "+ 상품 등록" 버튼 클릭
3. 상품 정보 입력
   - 상품명: 테스트 상품
   - 정가: 10,000원
   - 할인가: 7,000원
   - 재고: 5개
   - 카테고리: 빵
4. 저장
5. 상품 목록에서 확인
6. 상품 수정 (가격 변경)
7. 상품 삭제
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 4 | 상품 등록 | products 테이블에 저장 | ☐ |
| 4 | 할인율 계산 | 30% 자동 계산 | ☐ |
| 5 | 목록 표시 | 즉시 목록에 표시 | ☐ |
| 7 | 상품 삭제 | is_active = false 처리 | ☐ |

#### Flow 6: 예약 관리 (확인 → 완료)
```
1. StoreDashboard → 예약 관리
2. "대기중" 예약 확인
3. "확인" 버튼 클릭
4. 수수료 차감 확인 (15%)
5. "픽업 완료" 버튼 클릭
6. 예약 상태 "완료" 확인
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 3 | 예약 확인 | status: pending → confirmed | ☐ |
| 4 | 수수료 차감 | cash_balance 감소, cash_transactions 기록 | ☐ |
| 5 | 픽업 완료 | status: confirmed → completed | ☐ |

#### Flow 7: 캐시 관리
```
1. StoreDashboard → 캐시 관리
2. 현재 잔액 확인
3. "충전하기" 버튼 클릭
4. 50,000원 선택
5. 충전 완료 (데모 모드)
6. 잔액 증가 확인
7. "거래 내역" 확인
```

| 단계 | 검증 항목 | 예상 결과 | 통과 |
|------|----------|----------|------|
| 2 | 잔액 표시 | stores.cash_balance 값 표시 | ☐ |
| 5 | 충전 처리 | RPC 함수 charge_store_cash 호출 | ☐ |
| 7 | 거래 내역 | 충전/수수료 내역 날짜순 표시 | ☐ |

---

## 5. API 테스트 계획

### 5.1 인증 API

#### 회원가입 API
| 케이스 | 입력 | 예상 결과 | 상태 코드 |
|--------|------|----------|----------|
| 소비자 회원가입 성공 | 유효한 이메일/비밀번호/닉네임 | user + consumer 레코드 생성 | 200 |
| 중복 이메일 | 기존 이메일 | 에러 메시지 | 400 |
| 중복 닉네임 | 기존 닉네임 | 에러 메시지 | 400 |
| 잘못된 이메일 형식 | invalid-email | 에러 메시지 | 400 |
| 짧은 비밀번호 | 5자 미만 | 에러 메시지 | 400 |

#### 로그인 API
| 케이스 | 입력 | 예상 결과 | 상태 코드 |
|--------|------|----------|----------|
| 로그인 성공 | 유효한 이메일/비밀번호 | JWT 토큰 반환 | 200 |
| 잘못된 비밀번호 | 틀린 비밀번호 | 에러 메시지 | 400 |
| 존재하지 않는 이메일 | 미가입 이메일 | 에러 메시지 | 400 |

### 5.2 예약 API

#### 예약 생성
| 케이스 | 조건 | 예상 결과 |
|--------|------|----------|
| 정상 예약 | 재고 충분, 캐시 충분 | 예약 생성 성공 |
| 재고 부족 | 요청 수량 > 가용 재고 | 에러: 재고 부족 |
| 캐시 부족 | 업체 캐시 < 수수료 | 에러: 캐시 부족 |
| 비활성 상품 | is_active = false | 에러: 상품 없음 |
| 비승인 업체 | is_approved = false | 에러: 업체 비활성 |

#### 예약 상태 변경
| 케이스 | 이전 상태 | 새 상태 | 부가 동작 |
|--------|----------|--------|----------|
| 예약 확인 | pending | confirmed | 수수료 차감 |
| 픽업 완료 | confirmed | completed | 완료 시간 기록 |
| 예약 취소 | pending | cancelled | 재고 복구 |
| 예약 취소 | confirmed | cancelled | 재고 복구, 환불 |

### 5.3 RPC 함수 테스트

#### charge_store_cash (캐시 충전)
```sql
-- 테스트 쿼리
SELECT * FROM charge_store_cash(
  '업체_UUID',
  50000,
  '테스트 충전'
);
```

| 입력 | 예상 결과 |
|------|----------|
| 유효한 store_id, 양수 금액 | 잔액 증가, 거래 내역 생성 |
| 잘못된 store_id | 에러 |
| 음수 금액 | 에러 |

#### 예약 번호 생성 트리거
| 조건 | 예상 결과 |
|------|----------|
| 신규 예약 생성 | R + YYYYMMDD + 6자리 일련번호 |
| 같은 날 두 번째 예약 | 일련번호 +1 |

---

## 6. 에러 케이스 & 엣지 케이스

### 6.1 에러 케이스

| 시나리오 | 예상 동작 | 테스트 방법 |
|---------|----------|------------|
| 네트워크 오류 | 오류 메시지 표시, 재시도 옵션 | 네트워크 끄기 |
| 세션 만료 | 로그인 화면으로 이동 | 토큰 수동 삭제 |
| 서버 오류 (500) | 에러 메시지 표시 | Supabase 일시 중단 |
| 권한 없음 (403) | 에러 메시지 표시 | 다른 사용자 데이터 접근 시도 |
| 데이터 없음 (404) | Empty state 표시 | 존재하지 않는 ID 접근 |

### 6.2 엣지 케이스

| 시나리오 | 예상 동작 | 테스트 방법 |
|---------|----------|------------|
| 빈 업체 목록 | "주변에 업체가 없습니다" 표시 | 모든 업체 비활성화 |
| 빈 예약 목록 | "예약 내역이 없습니다" 표시 | 신규 계정 사용 |
| 재고 0개 | 예약 버튼 비활성화 | 재고 0으로 설정 |
| 캐시 잔액 0원 | 예약 확인 불가 알림 | 캐시 0으로 설정 |
| 매우 긴 텍스트 | 말줄임 처리 (...) | 긴 상품명/리뷰 입력 |
| 특수 문자 입력 | 정상 처리 | <script>, SQL 인젝션 시도 |
| 동시 예약 | 한 건만 성공 | 두 기기에서 동시 예약 |
| 빠른 연속 클릭 | 중복 요청 방지 | 버튼 빠르게 여러 번 클릭 |

---

## 7. 화면별 체크리스트

### 7.1 인증 화면

#### LoginScreen
- [ ] 이메일 입력 필드 표시
- [ ] 비밀번호 입력 필드 표시 (마스킹)
- [ ] 로그인 버튼 작동
- [ ] 회원가입 링크 작동
- [ ] 잘못된 입력 시 에러 메시지
- [ ] 로딩 상태 표시

#### ConsumerSignupScreen
- [ ] 이메일 형식 검증
- [ ] 비밀번호 최소 길이 검증
- [ ] 닉네임 중복 확인
- [ ] 가입 성공 후 로그인 화면 이동
- [ ] 에러 메시지 표시

#### StoreSignupScreen
- [ ] 업체명 필수 입력 검증
- [ ] 주소 입력 필드
- [ ] 사업자등록번호 입력
- [ ] 카테고리 선택
- [ ] 관리자 승인 대기 안내

### 7.2 소비자 화면

#### StoreListHome
- [ ] 업체 목록 표시
- [ ] 업체 카드 정보 (이름, 평점, 거리)
- [ ] 검색 기능
- [ ] 즐겨찾기(하트) 버튼
- [ ] 카테고리 필터
- [ ] 정렬 옵션 (거리순/평점순)
- [ ] Pull to refresh

#### StoreDetail
- [ ] 업체 정보 표시
- [ ] 영업시간 표시
- [ ] 상품 목록 표시
- [ ] 상품 카드 (이미지, 가격, 할인율, 재고)
- [ ] 리뷰 목록 표시
- [ ] 평균 평점 표시
- [ ] 예약하기 버튼

#### ReservationScreen
- [ ] 상품 정보 표시
- [ ] 수량 선택 (+/- 버튼)
- [ ] 픽업 시간 선택
- [ ] 총 금액 계산
- [ ] 절약 금액 표시
- [ ] 예약 버튼

#### MyReservations
- [ ] 예약 목록 표시
- [ ] 상태별 필터 (전체/진행중/완료/취소)
- [ ] 예약 카드 정보
- [ ] 예약 번호 표시
- [ ] 취소 버튼 (조건부)
- [ ] 리뷰 작성 버튼 (완료된 예약)

#### ReviewScreen
- [ ] 별점 선택 (1-5점)
- [ ] 리뷰 텍스트 입력
- [ ] 저장 버튼
- [ ] 이미 작성된 리뷰 수정 불가

### 7.3 업주 화면

#### StoreDashboard
- [ ] 캐시 잔액 표시
- [ ] 대기중 예약 수
- [ ] 오늘 매출
- [ ] 상품 수
- [ ] 메뉴 버튼들 (상품/예약/캐시/리뷰 관리)
- [ ] 로그아웃 버튼

#### StoreProductManagement
- [ ] 상품 목록 표시
- [ ] 상품 카드 (이미지, 가격, 재고, 상태)
- [ ] 추가 버튼
- [ ] 수정 버튼
- [ ] 삭제 버튼 (확인 다이얼로그)
- [ ] 판매 상태 토글

#### StoreReservationManagement
- [ ] 예약 목록 표시
- [ ] 상태별 필터
- [ ] 예약 상세 정보
- [ ] 확인 버튼 (pending → confirmed)
- [ ] 픽업 완료 버튼 (confirmed → completed)
- [ ] 취소 버튼

#### StoreCashManagement
- [ ] 현재 잔액 표시
- [ ] 충전 버튼
- [ ] 충전 금액 선택
- [ ] 거래 내역 보기 버튼

#### StoreCashHistory
- [ ] 거래 내역 목록
- [ ] 거래 유형 아이콘 (충전/수수료/환불)
- [ ] 날짜/시간 표시
- [ ] 금액 표시 (+/-)
- [ ] 잔액 표시

---

## 8. 테스트 실행 계획

### 8.1 테스트 순서

```
1. 환경 설정 검증
   |-- Supabase 연결 확인
   |-- 테스트 계정 확인
   |
2. 인증 테스트 (Flow 1)
   |
3. 소비자 플로우 테스트 (Flow 2, 3)
   |
4. 업주 플로우 테스트 (Flow 4, 5, 6, 7)
   |
5. API 테스트
   |
6. 에러/엣지 케이스 테스트
   |
7. 화면별 상세 체크리스트
   |
8. 결과 정리 및 버그 리포트
```

### 8.2 테스트 명령어

```bash
# 개발 서버 시작
cd C:\Users\user\claude-test\app
npx expo start

# Expo Go로 테스트
# 1. 휴대폰에 Expo Go 앱 설치
# 2. QR 코드 스캔
# 3. 앱 실행

# 또는 웹 테스트
npx expo start --web
```

### 8.3 테스트 도구

| 도구 | 용도 | 설치 방법 |
|------|------|----------|
| Expo Go | 실기기 테스트 | App Store / Play Store |
| Supabase Dashboard | DB 확인, SQL 실행 | 웹 접속 |
| VS Code | 로그 확인 | 설치됨 |

---

## 9. 품질 기준

### 9.1 테스트 통과 기준

- [ ] 7개 핵심 플로우 모두 통과
- [ ] 인증 API 5개 케이스 모두 통과
- [ ] 예약 API 5개 케이스 모두 통과
- [ ] 에러 케이스 5개 적절히 처리됨
- [ ] 엣지 케이스 8개 적절히 처리됨
- [ ] 26개 화면 기본 동작 확인

### 9.2 릴리스 기준

- [ ] 블로커(앱 크래시) 버그 0건
- [ ] 크리티컬(핵심 기능 불가) 버그 0건
- [ ] 메이저(기능 장애) 버그 해결률 100%
- [ ] 마이너(UX 개선) 버그 문서화

### 9.3 버그 심각도 분류

| 심각도 | 정의 | 예시 |
|--------|------|------|
| 블로커 | 앱 실행/사용 불가 | 앱 크래시, 로그인 불가 |
| 크리티컬 | 핵심 기능 불가 | 예약 불가, 결제 오류 |
| 메이저 | 기능 장애 | 검색 안 됨, 필터 오류 |
| 마이너 | UX 불편 | 레이아웃 깨짐, 오타 |

---

## 10. 테스트 결과 보고서 템플릿

```markdown
## 테스트 결과 요약

- **실행일**: YYYY-MM-DD
- **테스터**:
- **환경**: Expo Go / 웹 브라우저
- **기기**: iPhone/Android/Web

### 핵심 플로우 테스트
| 플로우 | 결과 | 비고 |
|--------|------|------|
| Flow 1: 회원가입 → 로그인 | ✅/❌ | |
| Flow 2: 업체 탐색 → 예약 | ✅/❌ | |
| Flow 3: 예약 확인 → 리뷰 | ✅/❌ | |
| Flow 4: 업주 로그인 → 대시보드 | ✅/❌ | |
| Flow 5: 상품 관리 | ✅/❌ | |
| Flow 6: 예약 관리 | ✅/❌ | |
| Flow 7: 캐시 관리 | ✅/❌ | |

### 발견된 버그
| ID | 심각도 | 화면 | 설명 | 재현 방법 |
|----|--------|------|------|----------|
| B-001 | | | | |
| B-002 | | | | |

### 개선 제안
| ID | 화면 | 제안 내용 |
|----|------|----------|
| I-001 | | |
| I-002 | | |
```

---

## 11. 테스트 일정

### 11.1 1차 테스트 (MVP 검증)

| 일자 | 작업 | 담당 |
|------|------|------|
| Day 1 | 테스트 환경 셋업, 계정 생성 | 개발자 |
| Day 1 | 인증 플로우 테스트 | 테스터 |
| Day 2 | 소비자 플로우 테스트 | 테스터 |
| Day 2 | 업주 플로우 테스트 | 테스터 |
| Day 3 | API 테스트, 에러 케이스 | 개발자 |
| Day 3 | 버그 수정 | 개발자 |
| Day 4 | 회귀 테스트 | 테스터 |

### 11.2 2차 테스트 (베타 전)

| 일자 | 작업 | 담당 |
|------|------|------|
| Day 1 | 실기기 테스트 (iOS) | 테스터 |
| Day 2 | 실기기 테스트 (Android) | 테스터 |
| Day 3 | 성능 테스트 | 개발자 |
| Day 4 | 최종 버그 수정 | 개발자 |

---

## 12. 부록

### 12.1 Supabase Dashboard 접속

1. https://supabase.com 로그인
2. 프로젝트 선택: `qycwdncplofgzdrjtklb`
3. 왼쪽 메뉴에서 기능 선택:
   - **Table Editor**: 테이블 데이터 확인/수정
   - **SQL Editor**: SQL 직접 실행
   - **Authentication**: 사용자 관리

### 12.2 테스트 데이터 초기화 SQL

```sql
-- 테스트 예약 삭제
DELETE FROM reservations WHERE consumer_id IN (
  SELECT id FROM consumers WHERE nickname LIKE 'test%'
);

-- 테스트 리뷰 삭제
DELETE FROM reviews WHERE consumer_id IN (
  SELECT id FROM consumers WHERE nickname LIKE 'test%'
);

-- 테스트 소비자 삭제
DELETE FROM consumers WHERE nickname LIKE 'test%';

-- 테스트 상품 재고 리셋
UPDATE products
SET stock_quantity = 10, reserved_quantity = 0
WHERE store_id = '테스트 업체 UUID';
```

### 12.3 관련 문서

| 문서 | 위치 |
|------|------|
| PRD | `docs/PRD.md` |
| TRD | `docs/TRD.md` |
| 프로젝트 분석 보고서 | `docs/PROJECT-ANALYSIS-REPORT.md` |

---

**문서 작성**: 테스트 계획 스킬
**검토일**: 2026-01-17
**다음 단계**: 테스트 실행 및 결과 기록

---

> 이 테스트 계획서는 MVP 단계의 핵심 기능 검증에 초점을 맞추었습니다.
> Phase 2 기능(지도, 실결제, 알림) 추가 시 테스트 항목을 확장해야 합니다.
</file>

<file path="docs/TRD.md">
# 재고 할인 중개 플랫폼 기술명세서 (TRD)

> **문서 버전**: 1.0
> **작성일**: 2026-01-17
> **프로젝트명**: 재고 할인 중개 플랫폼 (투굿투고 유사 서비스)
> **현재 상태**: MVP 90% 완료

---

## 목차

1. [개요](#1-개요)
2. [시스템 아키텍처](#2-시스템-아키텍처)
3. [기술 스택](#3-기술-스택)
4. [데이터베이스 설계](#4-데이터베이스-설계)
5. [API 설계](#5-api-설계)
6. [보안 요구사항](#6-보안-요구사항)
7. [코드 가이드라인](#7-코드-가이드라인)
8. [배포 및 환경 설정](#8-배포-및-환경-설정)
9. [성능 최적화](#9-성능-최적화)
10. [향후 기술 계획](#10-향후-기술-계획)
11. [부록](#11-부록)

---

## 1. 개요

### 1.1 문서 목적

이 문서는 **재고 할인 중개 플랫폼**의 기술적 설계와 구현 방법을 정의합니다. 개발자가 프로젝트를 이해하고, 유지보수하며, 확장할 수 있도록 필요한 모든 기술 정보를 담고 있습니다.

### 1.2 범위

- 모바일 앱 (iOS, Android) 개발
- 백엔드 서비스 (Supabase BaaS)
- 외부 서비스 연동 (결제, 지도, 알림)

### 1.3 용어 정의

| 용어 | 정의 |
|------|------|
| **캐시** | 업체가 선충전하여 수수료 결제에 사용하는 플랫폼 내 가상 화폐 |
| **픽업** | 소비자가 업체를 방문하여 예약 상품을 수령하는 것 |
| **예약** | 소비자가 상품을 미리 확보하는 것 (결제는 현장에서) |
| **수수료** | 예약 확정 시 업체 캐시에서 차감되는 플랫폼 이용료 (15%) |
| **RLS** | Row Level Security, 행 수준 보안 정책 |
| **BaaS** | Backend as a Service, 서버리스 백엔드 |

### 1.4 프로젝트 위치

```
C:\Users\user\claude-test\app\
```

---

## 2. 시스템 아키텍처

### 2.1 전체 구성도

```
┌─────────────────────────────────────────────────────────────────────┐
│                         클라이언트 앱                                │
│                   (React Native + Expo SDK 54)                      │
│                                                                     │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐     │
│  │    소비자 앱     │  │     업주 앱      │  │  운영자 앱 (예정)│     │
│  │                 │  │                 │  │                 │     │
│  │ - 업체 탐색     │  │ - 상품 관리     │  │ - 전체 관리     │     │
│  │ - 예약하기      │  │ - 예약 관리     │  │ - 통계          │     │
│  │ - 리뷰 작성     │  │ - 캐시 관리     │  │ - 클레임 처리   │     │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘     │
└───────────┼─────────────────────┼─────────────────────┼─────────────┘
            │                     │                     │
            └─────────────────────┼─────────────────────┘
                                  │
                    ┌─────────────▼─────────────┐
                    │      Supabase Cloud       │
                    │     (BaaS 백엔드)          │
                    │                           │
                    │  ┌─────────────────────┐  │
                    │  │   Authentication    │  │
                    │  │  (JWT 토큰 인증)     │  │
                    │  └─────────────────────┘  │
                    │                           │
                    │  ┌─────────────────────┐  │
                    │  │    PostgreSQL DB    │  │
                    │  │   (데이터 저장소)    │  │
                    │  └─────────────────────┘  │
                    │                           │
                    │  ┌─────────────────────┐  │
                    │  │     Storage         │  │
                    │  │  (이미지 저장소)     │  │
                    │  └─────────────────────┘  │
                    │                           │
                    │  ┌─────────────────────┐  │
                    │  │   Edge Functions    │  │
                    │  │  (서버리스 로직)     │  │
                    │  └─────────────────────┘  │
                    └─────────────┬─────────────┘
                                  │
            ┌─────────────────────┼─────────────────────┐
            │                     │                     │
    ┌───────▼───────┐    ┌───────▼───────┐    ┌───────▼───────┐
    │ 토스페이먼츠   │    │   카카오맵     │    │  Expo Push    │
    │  (결제 예정)   │    │  (지도 예정)   │    │ (알림 예정)   │
    └───────────────┘    └───────────────┘    └───────────────┘
```

### 2.2 클라이언트-서버 통신 흐름

```
[모바일 앱] ──HTTPS/JWT──> [Supabase API] ──SQL──> [PostgreSQL]
     │                          │
     │                          ├──> [RLS 정책 검사]
     │                          │
     │                          └──> [트리거/함수 실행]
     │
     └──WebSocket──> [Supabase Realtime] (실시간 동기화, 예정)
```

**통신 방식**:
1. **REST API**: 기본 CRUD 작업 (Supabase Client 사용)
2. **RPC 함수**: 복잡한 비즈니스 로직 (거리 계산, 예약 생성 등)
3. **Realtime**: 실시간 동기화 (향후 구현 예정)

### 2.3 데이터 흐름 예시: 예약 생성

```
1. 소비자가 상품 선택 및 예약 요청
                │
                ▼
2. 앱에서 Supabase API 호출
   - POST reservations 테이블
                │
                ▼
3. DB 트리거 실행 (reserve_product_stock)
   - 재고 확인 및 차감
   - 예약 번호 자동 생성
                │
                ▼
4. 성공 시 예약 데이터 반환
   - 실패 시 에러 반환 (재고 부족 등)
                │
                ▼
5. 업체에게 알림 발송 (향후 구현)
```

### 2.4 사용자 인증 흐름

```
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│   로그인      │──────▶│ Supabase Auth│──────▶│  JWT 토큰    │
│  (이메일/PW)  │      │   인증 확인   │      │    발급      │
└──────────────┘      └──────────────┘      └──────┬───────┘
                                                   │
                                                   ▼
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│  사용자 유형  │◀─────│consumers 또는│◀─────│  user_id로   │
│   자동 구분   │      │stores 조회   │      │  테이블 조회  │
└──────────────┘      └──────────────┘      └──────────────┘
        │
        ├──▶ 소비자: StoreListHome 화면으로 이동
        │
        └──▶ 업주: 마이페이지에서 '사장님 페이지' 접근 가능
```

---

## 3. 기술 스택

### 3.1 프론트엔드

| 기술 | 버전 | 용도 | 선택 이유 |
|------|------|------|----------|
| **React Native** | 0.81.5 | UI 프레임워크 | 크로스 플랫폼, 빠른 개발 |
| **Expo** | SDK 54 | 개발 도구 | 빌드/배포 간소화, 풍부한 API |
| **TypeScript** | 5.9.2 | 언어 | 타입 안전성, 개발 생산성 |
| **React Navigation** | 7.x | 네비게이션 | 네이티브 성능, 유연한 라우팅 |
| **Expo Image** | 3.0.x | 이미지 처리 | 자동 캐싱, 최적화 |
| **Expo Image Picker** | 17.0.x | 이미지 선택 | 카메라/갤러리 접근 |

### 3.2 백엔드 (BaaS)

| 기술 | 버전 | 용도 | 선택 이유 |
|------|------|------|----------|
| **Supabase** | Latest | 백엔드 통합 | Auth, DB, Storage, Realtime 통합 |
| **PostgreSQL** | 15.x | 데이터베이스 | 강력한 RLS, 트리거 지원 |
| **Supabase Auth** | Latest | 인증 | JWT 토큰, 소셜 로그인 지원 |
| **Supabase Storage** | Latest | 파일 저장 | 이미지 업로드, CDN 제공 |

### 3.3 향후 도입 예정 기술

| 기술 | 용도 | 예상 도입 시기 | 비고 |
|------|------|---------------|------|
| **토스페이먼츠** | 실결제 연동 | Phase 1 (2주 내) | 캐시 충전용 |
| **카카오맵 SDK** | 지도 기반 탐색 | Phase 2 (4-6주) | 업체 위치 표시 |
| **Expo Push** | 푸시 알림 | Phase 2 (4-6주) | 예약 알림 |
| **카카오 알림톡** | 카톡 알림 | Phase 3 (6-8주) | 높은 도달률 |
| **Sentry** | 에러 모니터링 | Phase 2 (4-6주) | 실시간 에러 추적 |

### 3.4 개발 도구

| 도구 | 용도 |
|------|------|
| **VS Code** | 코드 에디터 |
| **Git + GitHub** | 버전 관리 |
| **EAS Build** | 앱 빌드 (Expo) |
| **EAS Submit** | 스토어 제출 (Expo) |
| **Supabase Dashboard** | DB 관리, SQL 편집기 |

### 3.5 의존성 패키지 (package.json)

```json
{
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/native": "^7.1.8",
    "@supabase/supabase-js": "^2.90.1",
    "expo": "~54.0.31",
    "expo-image": "~3.0.11",
    "expo-image-picker": "^17.0.10",
    "react": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "typescript": "~5.9.2"
  }
}
```

---

## 4. 데이터베이스 설계

### 4.1 ERD 개요

```
┌─────────────┐
│   users     │ (Supabase Auth - auth.users)
│             │
│ - id (UUID) │
│ - email     │
│ - phone     │
└──────┬──────┘
       │
       ├─────────────────────────────────┐
       │                                 │
       ▼                                 ▼
┌─────────────┐                   ┌──────────────┐
│   consumers │                   │    stores    │
│             │                   │              │
│ - user_id   │                   │ - user_id    │
│ - nickname  │                   │ - name       │
│ - savings   │◄──────┐           │ - address    │
└──────┬──────┘       │           │ - lat/lng    │
       │              │           │ - avg_rating │
       │              │           └───────┬──────┘
       │              │                   │
       │              │                   ├──────────┐
       │              │                   │          │
       ▼              │                   ▼          ▼
┌──────────────┐      │            ┌───────────┐ ┌────────────────┐
│ reservations │──────┘            │ products  │ │ cash_transactions│
│              │                   │           │ │                │
│ - id         │───────┐           │ - id      │ │ - store_id     │
│ - consumer   │       │           │ - store   │ │ - type         │
│ - product    │       │           │ - price   │ │ - amount       │
│ - status     │       │           │ - stock   │ │ - balance_after│
│ - pickup_at  │       │           └───────────┘ └────────────────┘
└──────────────┘       │
                       │
                       ▼
                ┌──────────────┐      ┌──────────────┐
                │   reviews    │      │  favorites   │
                │              │      │              │
                │ - id         │      │ - consumer   │
                │ - reservation│      │ - store      │
                │ - rating     │      └──────────────┘
                │ - content    │
                │ - reply      │
                └──────────────┘
```

### 4.2 테이블 상세

#### 4.2.1 auth.users (Supabase Auth 기본)

Supabase가 자동 관리하는 인증 테이블입니다.

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 사용자 고유 ID (PK) |
| email | VARCHAR | 이메일 주소 |
| phone | VARCHAR | 전화번호 |
| created_at | TIMESTAMPTZ | 가입일 |
| email_confirmed_at | TIMESTAMPTZ | 이메일 인증일 |

#### 4.2.2 consumers (소비자)

```sql
CREATE TABLE consumers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  nickname VARCHAR(50) NOT NULL UNIQUE,
  phone VARCHAR(20),
  address TEXT,
  total_savings DECIMAL(10, 2) NOT NULL DEFAULT 0,  -- 누적 절약 금액
  avatar_url TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(user_id)
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 소비자 고유 ID |
| user_id | UUID | auth.users 참조 (FK) |
| nickname | VARCHAR(50) | 닉네임 (고유값) |
| phone | VARCHAR(20) | 연락처 |
| address | TEXT | 기본 주소 |
| total_savings | DECIMAL(10,2) | 누적 절약 금액 |
| avatar_url | TEXT | 프로필 이미지 URL |

#### 4.2.3 stores (업체)

```sql
CREATE TABLE stores (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  phone VARCHAR(20) NOT NULL,

  -- 주소 정보
  address TEXT NOT NULL,
  address_detail TEXT,
  latitude DECIMAL(10, 8) NOT NULL,
  longitude DECIMAL(11, 8) NOT NULL,

  -- 영업 정보
  business_number VARCHAR(20),  -- 사업자등록번호
  category VARCHAR(50),         -- 업종 카테고리

  -- 이미지
  thumbnail_url TEXT,
  images TEXT[],

  -- 통계
  total_transactions INT NOT NULL DEFAULT 0,
  average_rating DECIMAL(3, 2) DEFAULT 0,

  -- 캐시 관련
  cash_balance DECIMAL(10, 2) NOT NULL DEFAULT 0,

  -- 상태
  is_approved BOOLEAN DEFAULT false,  -- 관리자 승인 여부
  status VARCHAR(20) DEFAULT 'active',

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(user_id)
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 업체 고유 ID |
| user_id | UUID | auth.users 참조 (FK) |
| name | VARCHAR(100) | 업체명 |
| description | TEXT | 업체 소개 |
| phone | VARCHAR(20) | 연락처 |
| address | TEXT | 주소 |
| latitude/longitude | DECIMAL | 좌표 (지도용) |
| business_number | VARCHAR(20) | 사업자등록번호 |
| category | VARCHAR(50) | 업종 (베이커리, 음식점 등) |
| cash_balance | DECIMAL(10,2) | 현재 캐시 잔액 |
| average_rating | DECIMAL(3,2) | 평균 평점 (1.00~5.00) |
| is_approved | BOOLEAN | 관리자 승인 여부 |

#### 4.2.4 products (상품)

```sql
CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  name VARCHAR(200) NOT NULL,
  description TEXT,
  images TEXT[],

  -- 가격
  original_price DECIMAL(10, 2) NOT NULL,
  discounted_price DECIMAL(10, 2) NOT NULL,
  discount_rate DECIMAL(5, 2),  -- 자동 계산 또는 수동 입력

  -- 재고
  stock_quantity INT NOT NULL DEFAULT 0,
  reserved_quantity INT NOT NULL DEFAULT 0,

  -- 유통기한
  manufactured_date DATE,
  expiry_date DATE,

  -- 카테고리
  category VARCHAR(50),  -- 빵, 도시락, 음료, 과일, 반찬, 기타

  -- 상태
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CHECK (discounted_price <= original_price),
  CHECK (stock_quantity >= 0),
  CHECK (reserved_quantity >= 0)
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 상품 고유 ID |
| store_id | UUID | 업체 ID (FK) |
| name | VARCHAR(200) | 상품명 |
| original_price | DECIMAL(10,2) | 정가 |
| discounted_price | DECIMAL(10,2) | 할인가 |
| discount_rate | DECIMAL(5,2) | 할인율 (%) |
| stock_quantity | INT | 총 재고 수량 |
| reserved_quantity | INT | 예약된 수량 |
| category | VARCHAR(50) | 상품 카테고리 |
| is_active | BOOLEAN | 판매 활성화 여부 |

#### 4.2.5 reservations (예약)

```sql
CREATE TABLE reservations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  reservation_number VARCHAR(20) NOT NULL UNIQUE,  -- 자동 생성

  consumer_id UUID NOT NULL REFERENCES consumers(id) ON DELETE CASCADE,
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES products(id) ON DELETE RESTRICT,

  quantity INT NOT NULL DEFAULT 1,

  -- 가격 정보 (스냅샷)
  original_price DECIMAL(10, 2) NOT NULL,
  discounted_price DECIMAL(10, 2) NOT NULL,
  total_amount DECIMAL(10, 2) NOT NULL,
  saved_amount DECIMAL(10, 2) NOT NULL,

  -- 시간
  pickup_time TIMESTAMPTZ NOT NULL,
  completed_at TIMESTAMPTZ,
  cancelled_at TIMESTAMPTZ,

  -- 상태: pending, confirmed, completed, cancelled
  status VARCHAR(20) NOT NULL DEFAULT 'pending',

  -- 수수료
  commission_rate DECIMAL(5, 2) NOT NULL DEFAULT 15.00,
  commission_amount DECIMAL(10, 2),

  cancellation_reason TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CHECK (quantity > 0)
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 예약 고유 ID |
| reservation_number | VARCHAR(20) | 예약번호 (R + 날짜 + 일련번호) |
| consumer_id | UUID | 소비자 ID (FK) |
| store_id | UUID | 업체 ID (FK) |
| product_id | UUID | 상품 ID (FK) |
| quantity | INT | 예약 수량 |
| total_amount | DECIMAL | 총 결제 금액 |
| saved_amount | DECIMAL | 절약 금액 |
| pickup_time | TIMESTAMPTZ | 픽업 예정 시간 |
| status | VARCHAR(20) | 예약 상태 |
| commission_amount | DECIMAL | 수수료 (픽업 완료 시 계산) |

**예약 상태 (status)**:
- `pending`: 예약 대기 (기본)
- `confirmed`: 예약 확정 (수수료 차감됨)
- `completed`: 픽업 완료
- `cancelled`: 취소됨

#### 4.2.6 reviews (리뷰)

```sql
CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  reservation_id UUID NOT NULL REFERENCES reservations(id) ON DELETE CASCADE,
  consumer_id UUID NOT NULL REFERENCES consumers(id) ON DELETE CASCADE,
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  rating INT NOT NULL,  -- 1~5
  content TEXT,
  images TEXT[],

  reply TEXT,  -- 업체 답글
  reply_created_at TIMESTAMPTZ,

  is_deleted BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CHECK (rating >= 1 AND rating <= 5),
  UNIQUE(reservation_id)  -- 1 예약당 1 리뷰
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 리뷰 고유 ID |
| reservation_id | UUID | 예약 ID (FK, UNIQUE) |
| rating | INT | 별점 (1~5) |
| content | TEXT | 리뷰 내용 |
| reply | TEXT | 업체 답글 |

#### 4.2.7 cash_transactions (캐시 거래)

```sql
CREATE TABLE cash_transactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  transaction_type VARCHAR(20) NOT NULL,  -- charge, fee, refund
  amount DECIMAL(10, 2) NOT NULL,
  balance_after DECIMAL(10, 2) NOT NULL,

  reservation_id UUID REFERENCES reservations(id),
  description TEXT,

  -- 결제 정보 (충전 시)
  payment_key VARCHAR(200),
  order_id VARCHAR(100),

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  CHECK (amount > 0)
);
```

| 필드 | 타입 | 설명 |
|------|------|------|
| id | UUID | 거래 고유 ID |
| store_id | UUID | 업체 ID (FK) |
| transaction_type | VARCHAR(20) | 거래 유형 |
| amount | DECIMAL(10,2) | 거래 금액 |
| balance_after | DECIMAL(10,2) | 거래 후 잔액 |
| reservation_id | UUID | 관련 예약 ID (수수료인 경우) |

**거래 유형 (transaction_type)**:
- `charge`: 캐시 충전
- `fee`: 수수료 차감
- `refund`: 환불

#### 4.2.8 favorites (즐겨찾기)

```sql
CREATE TABLE favorites (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  consumer_id UUID NOT NULL REFERENCES consumers(id) ON DELETE CASCADE,
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(consumer_id, store_id)
);
```

#### 4.2.9 store_operating_hours (영업시간)

```sql
CREATE TABLE store_operating_hours (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  store_id UUID NOT NULL REFERENCES stores(id) ON DELETE CASCADE,

  day_of_week INT NOT NULL,  -- 0:일, 1:월, ..., 6:토
  opening_time TIME,
  closing_time TIME,
  is_closed BOOLEAN DEFAULT false,  -- 휴무일 여부

  UNIQUE(store_id, day_of_week)
);
```

### 4.3 주요 인덱스

```sql
-- 소비자 조회
CREATE INDEX idx_consumers_user_id ON consumers(user_id);
CREATE INDEX idx_consumers_nickname ON consumers(nickname);

-- 업체 조회
CREATE INDEX idx_stores_user_id ON stores(user_id);
CREATE INDEX idx_stores_status ON stores(status);
CREATE INDEX idx_stores_rating ON stores(average_rating DESC);

-- 상품 조회
CREATE INDEX idx_products_store_id ON products(store_id);
CREATE INDEX idx_products_active ON products(store_id, is_active);
CREATE INDEX idx_products_category ON products(category);

-- 예약 조회
CREATE INDEX idx_reservations_consumer ON reservations(consumer_id);
CREATE INDEX idx_reservations_store ON reservations(store_id);
CREATE INDEX idx_reservations_status ON reservations(status);
CREATE INDEX idx_reservations_created ON reservations(created_at DESC);
CREATE INDEX idx_reservations_number ON reservations(reservation_number);

-- 리뷰 조회
CREATE INDEX idx_reviews_store ON reviews(store_id);
CREATE INDEX idx_reviews_consumer ON reviews(consumer_id);

-- 캐시 거래
CREATE INDEX idx_cash_transactions_store ON cash_transactions(store_id);
CREATE INDEX idx_cash_transactions_created ON cash_transactions(created_at DESC);

-- 즐겨찾기
CREATE INDEX idx_favorites_consumer ON favorites(consumer_id);
CREATE INDEX idx_favorites_store ON favorites(store_id);
```

### 4.4 주요 트리거 및 함수

#### 4.4.1 예약 번호 자동 생성

```sql
-- 예약 번호 생성 함수
CREATE OR REPLACE FUNCTION generate_reservation_number()
RETURNS TRIGGER AS $$
DECLARE
  date_prefix VARCHAR(8);
  sequence_num INT;
BEGIN
  -- 날짜 prefix (YYYYMMDD)
  date_prefix := TO_CHAR(NOW(), 'YYYYMMDD');

  -- 오늘 생성된 예약 수 + 1
  SELECT COUNT(*) + 1 INTO sequence_num
  FROM reservations
  WHERE reservation_number LIKE 'R' || date_prefix || '%';

  -- 예약 번호: R + YYYYMMDD + 6자리 순번
  NEW.reservation_number := 'R' || date_prefix || LPAD(sequence_num::TEXT, 6, '0');

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 트리거 생성
CREATE TRIGGER trg_generate_reservation_number
BEFORE INSERT ON reservations
FOR EACH ROW
EXECUTE FUNCTION generate_reservation_number();
```

**예약 번호 형식**: `R20260117000001`
- R: 예약 접두어
- 20260117: 날짜 (YYYYMMDD)
- 000001: 당일 일련번호

#### 4.4.2 수수료 자동 차감 (예약 확정 시)

```sql
-- 수수료 차감 함수
CREATE OR REPLACE FUNCTION deduct_commission_fee()
RETURNS TRIGGER AS $$
DECLARE
  commission DECIMAL(10, 2);
  current_balance DECIMAL(10, 2);
BEGIN
  -- pending → confirmed 변경 시에만 실행
  IF OLD.status = 'pending' AND NEW.status = 'confirmed' THEN
    -- 수수료 계산 (15%)
    commission := NEW.total_amount * (NEW.commission_rate / 100);
    NEW.commission_amount := commission;

    -- 업체 캐시 잔액 조회
    SELECT cash_balance INTO current_balance
    FROM stores
    WHERE id = NEW.store_id;

    -- 잔액 부족 확인
    IF current_balance < commission THEN
      RAISE EXCEPTION '캐시 잔액이 부족합니다. 현재 잔액: %, 필요 금액: %',
        current_balance, commission;
    END IF;

    -- 캐시 차감
    UPDATE stores
    SET cash_balance = cash_balance - commission,
        updated_at = NOW()
    WHERE id = NEW.store_id;

    -- 거래 내역 추가
    INSERT INTO cash_transactions (
      store_id, transaction_type, amount, balance_after,
      reservation_id, description
    )
    VALUES (
      NEW.store_id,
      'fee',
      commission,
      current_balance - commission,
      NEW.id,
      '예약 확정 수수료 (' || NEW.reservation_number || ')'
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_deduct_commission_fee
BEFORE UPDATE ON reservations
FOR EACH ROW
EXECUTE FUNCTION deduct_commission_fee();
```

#### 4.4.3 업체 평균 평점 자동 업데이트

```sql
CREATE OR REPLACE FUNCTION update_store_rating()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE stores
  SET average_rating = (
    SELECT ROUND(AVG(rating)::numeric, 2)
    FROM reviews
    WHERE store_id = NEW.store_id
      AND is_deleted = false
  ),
  updated_at = NOW()
  WHERE id = NEW.store_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_update_store_rating_insert
AFTER INSERT ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_store_rating();

CREATE TRIGGER trg_update_store_rating_update
AFTER UPDATE OF rating, is_deleted ON reviews
FOR EACH ROW
EXECUTE FUNCTION update_store_rating();
```

#### 4.4.4 캐시 충전 함수 (RPC)

```sql
CREATE OR REPLACE FUNCTION charge_store_cash(
  p_store_id UUID,
  p_amount DECIMAL,
  p_description TEXT DEFAULT '캐시 충전'
)
RETURNS TABLE (
  new_balance DECIMAL,
  transaction_id UUID
) AS $$
DECLARE
  v_current_balance DECIMAL;
  v_new_balance DECIMAL;
  v_transaction_id UUID;
BEGIN
  -- 현재 잔액 조회
  SELECT cash_balance INTO v_current_balance
  FROM stores
  WHERE id = p_store_id;

  v_new_balance := v_current_balance + p_amount;

  -- 캐시 충전
  UPDATE stores
  SET cash_balance = v_new_balance,
      updated_at = NOW()
  WHERE id = p_store_id;

  -- 거래 내역 추가
  INSERT INTO cash_transactions (
    store_id, transaction_type, amount, balance_after, description
  )
  VALUES (
    p_store_id, 'charge', p_amount, v_new_balance, p_description
  )
  RETURNING id INTO v_transaction_id;

  RETURN QUERY SELECT v_new_balance, v_transaction_id;
END;
$$ LANGUAGE plpgsql;
```

---

## 5. API 설계

### 5.1 API 개요

**통신 방식**: Supabase Client를 통한 REST API + RPC 함수

```typescript
// Supabase 클라이언트 초기화
import { createClient } from '@supabase/supabase-js';

const supabase = createClient(
  process.env.EXPO_PUBLIC_SUPABASE_URL,
  process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY,
  {
    auth: {
      storage: AsyncStorage,
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: false,
    },
  }
);
```

### 5.2 인증 API

#### 회원가입

```typescript
// 소비자 회원가입
const signUpConsumer = async (email: string, password: string, nickname: string) => {
  // 1. Auth 회원가입
  const { data: authData, error: authError } = await supabase.auth.signUp({
    email,
    password,
  });

  if (authError) throw authError;

  // 2. 소비자 프로필 생성
  const { error: profileError } = await supabase
    .from('consumers')
    .insert({
      user_id: authData.user.id,
      nickname,
    });

  if (profileError) throw profileError;

  return authData;
};

// 업주 회원가입
const signUpStore = async (
  email: string,
  password: string,
  storeData: {
    name: string;
    phone: string;
    address: string;
    latitude: number;
    longitude: number;
    businessNumber?: string;
    category?: string;
  }
) => {
  // 1. Auth 회원가입
  const { data: authData, error: authError } = await supabase.auth.signUp({
    email,
    password,
  });

  if (authError) throw authError;

  // 2. 업체 프로필 생성
  const { error: profileError } = await supabase
    .from('stores')
    .insert({
      user_id: authData.user.id,
      ...storeData,
      is_approved: false,  // 관리자 승인 대기
    });

  if (profileError) throw profileError;

  return authData;
};
```

#### 로그인

```typescript
const signIn = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });

  if (error) throw error;

  return data;
};
```

#### 로그아웃

```typescript
const signOut = async () => {
  const { error } = await supabase.auth.signOut();
  if (error) throw error;
};
```

### 5.3 소비자 API

#### 업체 리스트 조회

```typescript
// 거리순 업체 리스트
const getStores = async (options?: {
  latitude?: number;
  longitude?: number;
  category?: string;
  searchText?: string;
  limit?: number;
  offset?: number;
}) => {
  let query = supabase
    .from('stores')
    .select(`
      *,
      products:products(count)
    `)
    .eq('status', 'active')
    .eq('is_approved', true)
    .order('average_rating', { ascending: false });

  if (options?.category) {
    query = query.eq('category', options.category);
  }

  if (options?.searchText) {
    query = query.ilike('name', `%${options.searchText}%`);
  }

  if (options?.limit) {
    query = query.limit(options.limit);
  }

  if (options?.offset) {
    query = query.range(options.offset, options.offset + (options.limit || 20) - 1);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
};
```

#### 업체 상세 조회

```typescript
const getStoreDetail = async (storeId: string) => {
  const { data, error } = await supabase
    .from('stores')
    .select(`
      *,
      products:products(*),
      reviews:reviews(
        *,
        consumer:consumers(nickname, avatar_url)
      ),
      operating_hours:store_operating_hours(*)
    `)
    .eq('id', storeId)
    .eq('products.is_active', true)
    .eq('reviews.is_deleted', false)
    .order('created_at', { foreignTable: 'reviews', ascending: false })
    .single();

  if (error) throw error;
  return data;
};
```

#### 예약 생성

```typescript
const createReservation = async (
  consumerId: string,
  productId: string,
  quantity: number,
  pickupTime: string
) => {
  // 1. 상품 정보 조회
  const { data: product } = await supabase
    .from('products')
    .select('*, store:stores(*)')
    .eq('id', productId)
    .single();

  // 2. 재고 확인
  const availableStock = product.stock_quantity - product.reserved_quantity;
  if (availableStock < quantity) {
    throw new Error('재고가 부족합니다');
  }

  // 3. 예약 생성
  const { data: reservation, error } = await supabase
    .from('reservations')
    .insert({
      consumer_id: consumerId,
      store_id: product.store_id,
      product_id: productId,
      quantity,
      original_price: product.original_price,
      discounted_price: product.discounted_price,
      total_amount: product.discounted_price * quantity,
      saved_amount: (product.original_price - product.discounted_price) * quantity,
      pickup_time: pickupTime,
      status: 'pending',
    })
    .select()
    .single();

  if (error) throw error;

  // 4. 재고 업데이트
  await supabase
    .from('products')
    .update({
      reserved_quantity: product.reserved_quantity + quantity,
    })
    .eq('id', productId);

  return reservation;
};
```

#### 예약 내역 조회

```typescript
const getMyReservations = async (
  consumerId: string,
  status?: string
) => {
  let query = supabase
    .from('reservations')
    .select(`
      *,
      product:products(name, images),
      store:stores(name, address, phone)
    `)
    .eq('consumer_id', consumerId)
    .order('created_at', { ascending: false });

  if (status) {
    query = query.eq('status', status);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
};
```

#### 리뷰 작성

```typescript
const createReview = async (
  reservationId: string,
  consumerId: string,
  storeId: string,
  rating: number,
  content: string,
  images?: string[]
) => {
  // 예약 상태 확인
  const { data: reservation } = await supabase
    .from('reservations')
    .select('status')
    .eq('id', reservationId)
    .single();

  if (reservation.status !== 'completed') {
    throw new Error('픽업 완료된 예약만 리뷰 작성이 가능합니다');
  }

  // 리뷰 작성
  const { data, error } = await supabase
    .from('reviews')
    .insert({
      reservation_id: reservationId,
      consumer_id: consumerId,
      store_id: storeId,
      rating,
      content,
      images,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
};
```

### 5.4 업주 API

#### 상품 관리

```typescript
// 상품 등록
const createProduct = async (storeId: string, productData: {
  name: string;
  description?: string;
  originalPrice: number;
  discountedPrice: number;
  stockQuantity: number;
  category?: string;
  images?: string[];
}) => {
  const discountRate = Math.round(
    ((productData.originalPrice - productData.discountedPrice) /
     productData.originalPrice) * 100
  );

  const { data, error } = await supabase
    .from('products')
    .insert({
      store_id: storeId,
      name: productData.name,
      description: productData.description,
      original_price: productData.originalPrice,
      discounted_price: productData.discountedPrice,
      discount_rate: discountRate,
      stock_quantity: productData.stockQuantity,
      category: productData.category,
      images: productData.images,
      is_active: true,
    })
    .select()
    .single();

  if (error) throw error;
  return data;
};

// 상품 수정
const updateProduct = async (productId: string, updates: Partial<Product>) => {
  const { data, error } = await supabase
    .from('products')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', productId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

// 상품 삭제 (비활성화)
const deleteProduct = async (productId: string) => {
  const { error } = await supabase
    .from('products')
    .update({ is_active: false })
    .eq('id', productId);

  if (error) throw error;
};
```

#### 예약 관리

```typescript
// 예약 목록 조회
const getStoreReservations = async (storeId: string, status?: string) => {
  let query = supabase
    .from('reservations')
    .select(`
      *,
      product:products(name),
      consumer:consumers(nickname)
    `)
    .eq('store_id', storeId)
    .order('created_at', { ascending: false });

  if (status) {
    query = query.eq('status', status);
  }

  const { data, error } = await query;

  if (error) throw error;
  return data;
};

// 예약 확정
const confirmReservation = async (reservationId: string) => {
  const { data, error } = await supabase
    .from('reservations')
    .update({ status: 'confirmed' })
    .eq('id', reservationId)
    .eq('status', 'pending')
    .select()
    .single();

  if (error) throw error;
  return data;
};

// 픽업 완료
const completeReservation = async (reservationId: string) => {
  const { data, error } = await supabase
    .from('reservations')
    .update({
      status: 'completed',
      completed_at: new Date().toISOString(),
    })
    .eq('id', reservationId)
    .select()
    .single();

  if (error) throw error;
  return data;
};

// 예약 취소
const cancelReservation = async (
  reservationId: string,
  reason: string,
  cancelledBy: 'consumer' | 'store'
) => {
  const { data: reservation } = await supabase
    .from('reservations')
    .select('product_id, quantity')
    .eq('id', reservationId)
    .single();

  // 재고 복구
  const { data: product } = await supabase
    .from('products')
    .select('reserved_quantity')
    .eq('id', reservation.product_id)
    .single();

  await supabase
    .from('products')
    .update({
      reserved_quantity: product.reserved_quantity - reservation.quantity,
    })
    .eq('id', reservation.product_id);

  // 예약 취소
  const { data, error } = await supabase
    .from('reservations')
    .update({
      status: 'cancelled',
      cancelled_at: new Date().toISOString(),
      cancellation_reason: reason,
    })
    .eq('id', reservationId)
    .select()
    .single();

  if (error) throw error;
  return data;
};
```

#### 캐시 관리

```typescript
// 캐시 잔액 조회
const getCashBalance = async (storeId: string) => {
  const { data, error } = await supabase
    .from('stores')
    .select('cash_balance')
    .eq('id', storeId)
    .single();

  if (error) throw error;
  return data.cash_balance;
};

// 캐시 거래 내역 조회
const getCashTransactions = async (
  storeId: string,
  limit: number = 20,
  offset: number = 0
) => {
  const { data, error } = await supabase
    .from('cash_transactions')
    .select('*')
    .eq('store_id', storeId)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) throw error;
  return data;
};

// 캐시 충전 (RPC 함수 호출)
const chargeCash = async (storeId: string, amount: number) => {
  const { data, error } = await supabase
    .rpc('charge_store_cash', {
      p_store_id: storeId,
      p_amount: amount,
      p_description: `캐시 충전 ${amount.toLocaleString()}원`,
    });

  if (error) throw error;
  return data;
};
```

### 5.5 에러 코드

| 코드 | 메시지 | 설명 |
|------|--------|------|
| `AUTH_001` | 인증 실패 | 잘못된 이메일/비밀번호 |
| `AUTH_002` | 토큰 만료 | JWT 토큰 만료 |
| `AUTH_003` | 권한 없음 | 접근 권한 없음 |
| `STORE_001` | 업체를 찾을 수 없음 | 존재하지 않는 업체 |
| `STORE_002` | 업체 비활성화 | 영업 종료 또는 캐시 부족 |
| `PRODUCT_001` | 상품을 찾을 수 없음 | 존재하지 않는 상품 |
| `PRODUCT_002` | 재고 부족 | 요청 수량 > 재고 |
| `RESERVATION_001` | 예약 실패 | 예약 생성 실패 |
| `RESERVATION_002` | 취소 불가 | 취소 가능 시간 초과 |
| `REVIEW_001` | 리뷰 작성 권한 없음 | 픽업 완료하지 않음 |
| `CASH_001` | 캐시 부족 | 잔액 부족 |

---

## 6. 보안 요구사항

### 6.1 인증 및 인가

#### JWT 토큰 기반 인증

```typescript
// Supabase Auth 설정
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
  auth: {
    storage: AsyncStorage,           // 토큰 저장소
    autoRefreshToken: true,          // 자동 토큰 갱신
    persistSession: true,            // 세션 유지
    detectSessionInUrl: false,       // URL 세션 감지 비활성화 (앱)
  },
});
```

**토큰 관리**:
- Access Token: 1시간 만료
- Refresh Token: 30일 만료 (자동 갱신)
- 저장 위치: AsyncStorage (암호화됨)

### 6.2 Row Level Security (RLS)

Supabase의 RLS 정책으로 데이터 접근을 제어합니다.

```sql
-- consumers 테이블: 자신의 정보만 조회/수정 가능
ALTER TABLE consumers ENABLE ROW LEVEL SECURITY;

CREATE POLICY "소비자는 자신의 정보만 조회 가능" ON consumers
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "소비자는 자신의 정보만 수정 가능" ON consumers
  FOR UPDATE USING (auth.uid() = user_id);

-- stores 테이블: 모두 조회 가능, 소유자만 수정 가능
ALTER TABLE stores ENABLE ROW LEVEL SECURITY;

CREATE POLICY "모든 사용자가 업체 정보 조회 가능" ON stores
  FOR SELECT USING (true);

CREATE POLICY "업체는 자신의 정보만 수정 가능" ON stores
  FOR UPDATE USING (auth.uid() = user_id);

-- products 테이블: 활성 상품만 조회, 업체만 관리
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

CREATE POLICY "활성 상품 조회 가능" ON products
  FOR SELECT USING (is_active = true OR
    EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
  );

CREATE POLICY "업체는 자신의 상품만 관리 가능" ON products
  FOR ALL USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = products.store_id AND stores.user_id = auth.uid())
  );

-- reservations 테이블: 관련자만 조회 가능
ALTER TABLE reservations ENABLE ROW LEVEL SECURITY;

CREATE POLICY "소비자는 자신의 예약만 조회" ON reservations
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM consumers WHERE consumers.id = reservations.consumer_id AND consumers.user_id = auth.uid())
  );

CREATE POLICY "업체는 자신의 예약만 조회" ON reservations
  FOR SELECT USING (
    EXISTS (SELECT 1 FROM stores WHERE stores.id = reservations.store_id AND stores.user_id = auth.uid())
  );
```

### 6.3 API 키 관리

#### 환경 변수 사용 (.env)

```bash
# .env 파일 (절대 Git에 커밋하지 않음)
EXPO_PUBLIC_SUPABASE_URL=https://xxxx.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGci...

# 향후 추가 예정
EXPO_PUBLIC_TOSS_CLIENT_KEY=test_xxxx
EXPO_PUBLIC_KAKAO_MAP_KEY=xxxx
```

#### .gitignore 설정

```gitignore
# 환경 변수 파일
.env
.env.local
.env.production

# 민감한 설정 파일
google-services.json
GoogleService-Info.plist
```

### 6.4 민감 정보 처리

#### 로깅 주의사항

```typescript
// BAD: 민감 정보 로깅
console.log('로그인 시도:', email, password);  // 절대 금지!

// GOOD: 안전한 로깅
console.log('로그인 시도:', email);
console.log('결제 요청:', { orderId, amount });  // 카드 정보 제외
```

#### 에러 처리

```typescript
// 민감 정보가 포함될 수 있는 에러 처리
try {
  await supabase.auth.signInWithPassword({ email, password });
} catch (error) {
  // 실제 에러 메시지는 서버 로그로만
  console.error('로그인 실패');  // 상세 정보 제외

  // 사용자에게는 일반적인 메시지
  Alert.alert('로그인 실패', '이메일 또는 비밀번호를 확인해주세요');
}
```

### 6.5 데이터 암호화

| 항목 | 암호화 방식 | 담당 |
|------|------------|------|
| 비밀번호 | bcrypt 해싱 | Supabase Auth 자동 처리 |
| 통신 | HTTPS (TLS 1.3) | Supabase 자동 처리 |
| 토큰 저장 | AsyncStorage (암호화) | React Native 자동 처리 |
| 결제 정보 | PCI DSS 준수 | 토스페이먼츠 처리 (예정) |

---

## 7. 코드 가이드라인

### 7.1 폴더 구조

```
app/
├── App.tsx                          # 메인 앱 (네비게이션 관리)
├── app.json                         # Expo 설정
├── package.json                     # 의존성
├── tsconfig.json                    # TypeScript 설정
├── .env                             # 환경변수 (Git 제외)
├── .gitignore
│
├── src/
│   ├── lib/
│   │   └── supabase.ts              # Supabase 클라이언트 설정
│   │
│   ├── screens/                     # 화면 컴포넌트 (26개)
│   │   │
│   │   │── # 인증 화면
│   │   ├── LoginScreen.tsx          # 로그인
│   │   ├── SignupTypeScreen.tsx     # 회원가입 유형 선택
│   │   ├── ConsumerSignupScreen.tsx # 소비자 회원가입
│   │   ├── StoreSignupScreen.tsx    # 업주 회원가입
│   │   │
│   │   │── # 소비자 화면
│   │   ├── StoreListHome.tsx        # 업체 리스트 (홈)
│   │   ├── StoreListHomeWithSearch.tsx # 검색 포함 업체 리스트
│   │   ├── StoreDetail.tsx          # 업체 상세
│   │   ├── ReservationScreen.tsx    # 예약하기
│   │   ├── MyReservations.tsx       # 예약 내역
│   │   ├── ReviewScreen.tsx         # 리뷰 작성
│   │   ├── MyPageScreen.tsx         # 마이페이지
│   │   ├── ProfileEditScreen.tsx    # 프로필 편집
│   │   │
│   │   │── # 업주 화면
│   │   ├── StoreDashboard.tsx       # 업주 대시보드
│   │   ├── StoreProductManagement.tsx # 상품 관리
│   │   ├── StoreCashManagement.tsx  # 캐시 관리
│   │   ├── StoreCashHistory.tsx     # 캐시 내역
│   │   ├── StoreReservationManagement.tsx # 예약 관리
│   │   ├── StoreReviewManagement.tsx    # 리뷰 관리
│   │   ├── StoreReviewManagementWithReply.tsx # 리뷰 답글
│   │   ├── StoreInfoManagement.tsx  # 업체 정보 관리
│   │   ├── StoreOperatingHoursScreen.tsx # 영업시간 관리
│   │   └── StoreRegularCustomers.tsx # 단골 고객
│   │
│   ├── components/                  # 재사용 컴포넌트
│   │   ├── ui/                      # 기본 UI (Button, Input 등)
│   │   └── common/                  # 공통 컴포넌트
│   │
│   ├── hooks/                       # 커스텀 훅 (향후 추가)
│   │   ├── useAuth.ts
│   │   └── useLocation.ts
│   │
│   ├── types/                       # TypeScript 타입 (향후 추가)
│   │   └── database.ts
│   │
│   └── utils/                       # 유틸리티 함수 (향후 추가)
│       ├── format.ts
│       └── validation.ts
│
├── assets/                          # 정적 파일
│   ├── images/
│   └── fonts/
│
└── components/                      # Expo 기본 컴포넌트
    └── ...
```

### 7.2 네이밍 규칙

| 대상 | 규칙 | 예시 |
|------|------|------|
| 화면 컴포넌트 | PascalCase + Screen 접미사 | `LoginScreen.tsx`, `MyPageScreen.tsx` |
| 일반 컴포넌트 | PascalCase | `StoreCard.tsx`, `ProductItem.tsx` |
| 커스텀 훅 | camelCase + use 접두사 | `useAuth.ts`, `useLocation.ts` |
| 유틸 함수 | camelCase | `formatDate.ts`, `calculateDistance.ts` |
| 상수 | UPPER_SNAKE_CASE | `API_ENDPOINTS`, `MAX_RETRY_COUNT` |
| 타입/인터페이스 | PascalCase | `Store`, `Product`, `Reservation` |
| 변수/함수 | camelCase | `storeList`, `handleSubmit` |
| 이벤트 핸들러 | on/handle 접두사 | `onPress`, `handleSubmit` |

### 7.3 TypeScript 규칙

#### 타입 정의

```typescript
// types/database.ts

// 업체 타입
interface Store {
  id: string;
  user_id: string;
  name: string;
  description?: string;
  phone: string;
  address: string;
  latitude: number;
  longitude: number;
  thumbnail_url?: string;
  average_rating: number;
  cash_balance: number;
  is_approved: boolean;
  status: 'active' | 'inactive' | 'suspended';
  created_at: string;
  updated_at: string;
}

// 상품 타입
interface Product {
  id: string;
  store_id: string;
  name: string;
  description?: string;
  images?: string[];
  original_price: number;
  discounted_price: number;
  discount_rate: number;
  stock_quantity: number;
  reserved_quantity: number;
  category?: string;
  is_active: boolean;
  created_at: string;
  updated_at: string;
}

// 예약 타입
interface Reservation {
  id: string;
  reservation_number: string;
  consumer_id: string;
  store_id: string;
  product_id: string;
  quantity: number;
  original_price: number;
  discounted_price: number;
  total_amount: number;
  saved_amount: number;
  pickup_time: string;
  status: 'pending' | 'confirmed' | 'completed' | 'cancelled';
  commission_rate: number;
  commission_amount?: number;
  cancellation_reason?: string;
  created_at: string;
  completed_at?: string;
  cancelled_at?: string;
}

// Props 타입
interface StoreDetailProps {
  storeId: string;
  onReserve: (product: Product) => void;
  onBack: () => void;
}
```

### 7.4 컴포넌트 작성 패턴

#### 기본 화면 컴포넌트 구조

```typescript
import React, { useCallback, useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { supabase } from '../lib/supabase';

// Props 인터페이스 정의
interface MyScreenProps {
  onBack: () => void;
  someId?: string;
}

// 컴포넌트 함수
export default function MyScreen({ onBack, someId }: MyScreenProps) {
  // 1. 상태 정의
  const [loading, setLoading] = useState(true);
  const [data, setData] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  // 2. 데이터 로딩 함수 (useCallback으로 메모이제이션)
  const loadData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const { data, error } = await supabase
        .from('some_table')
        .select('*')
        .eq('some_column', someId);

      if (error) throw error;
      setData(data || []);
    } catch (err: any) {
      console.error('데이터 로딩 오류:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [someId]);

  // 3. 초기 로딩
  useEffect(() => {
    loadData();
  }, [loadData]);

  // 4. 핸들러 함수
  const handleSomeAction = async () => {
    try {
      // 비즈니스 로직
    } catch (err: any) {
      Alert.alert('오류', err.message);
    }
  };

  // 5. 로딩 상태 렌더링
  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  // 6. 에러 상태 렌더링
  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>{error}</Text>
      </View>
    );
  }

  // 7. 메인 렌더링
  return (
    <View style={styles.container}>
      {/* UI 구현 */}
    </View>
  );
}

// 8. 스타일 정의
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  errorText: {
    color: '#FF3B30',
    textAlign: 'center',
  },
});
```

### 7.5 코딩 스타일

| 항목 | 규칙 |
|------|------|
| 들여쓰기 | 2 spaces |
| 세미콜론 | 사용함 |
| 따옴표 | 작은따옴표 (') |
| 최대 줄 길이 | 100자 권장, 120자 최대 |
| 파일당 컴포넌트 | 1개 원칙 |
| import 순서 | React > 외부 라이브러리 > 내부 모듈 |

### 7.6 주석 가이드라인

```typescript
// 간단한 설명은 한 줄 주석
const TAX_RATE = 0.1;  // 세금 비율 10%

/**
 * 복잡한 함수나 모듈은 JSDoc 스타일 주석 사용
 *
 * @param storeId - 업체 고유 ID
 * @param amount - 충전 금액 (원)
 * @returns 충전 후 잔액과 거래 ID
 * @throws 잔액 부족 시 에러
 */
const chargeCash = async (storeId: string, amount: number) => {
  // 구현...
};

// TODO: 향후 구현 예정 표시
// TODO: 토스페이먼츠 실결제 연동 (Phase 1)

// FIXME: 수정 필요한 부분 표시
// FIXME: 동시성 문제 발생 가능성 있음
```

---

## 8. 배포 및 환경 설정

### 8.1 환경 변수

#### .env 파일 설정

```bash
# Supabase (필수)
EXPO_PUBLIC_SUPABASE_URL=https://xxxx.supabase.co
EXPO_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

# 토스페이먼츠 (Phase 1에서 추가)
# EXPO_PUBLIC_TOSS_CLIENT_KEY=test_ck_xxx
# TOSS_SECRET_KEY=test_sk_xxx  # 서버 전용, EXPO_PUBLIC 붙이지 않음

# 카카오맵 (Phase 2에서 추가)
# EXPO_PUBLIC_KAKAO_MAP_KEY=xxx

# 앱 설정
EXPO_PUBLIC_APP_ENV=development  # development | staging | production
```

#### 환경별 설정

| 환경 | 용도 | Supabase 프로젝트 |
|------|------|------------------|
| development | 로컬 개발 | 개발용 프로젝트 |
| staging | 테스트 | 스테이징 프로젝트 (선택) |
| production | 실서비스 | 프로덕션 프로젝트 |

### 8.2 빌드 프로세스

#### Expo 빌드 명령어

```bash
# 개발 서버 시작
npx expo start

# 개발 빌드 (내부 테스트용)
eas build --profile development --platform ios
eas build --profile development --platform android

# 프리뷰 빌드 (베타 테스트용)
eas build --profile preview --platform all

# 프로덕션 빌드 (스토어 제출용)
eas build --profile production --platform all

# 스토어 제출
eas submit --platform ios
eas submit --platform android
```

#### eas.json 설정

```json
{
  "cli": {
    "version": ">= 3.0.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "env": {
        "EXPO_PUBLIC_APP_ENV": "development"
      }
    },
    "preview": {
      "distribution": "internal",
      "android": {
        "buildType": "apk"
      },
      "env": {
        "EXPO_PUBLIC_APP_ENV": "staging"
      }
    },
    "production": {
      "autoIncrement": true,
      "env": {
        "EXPO_PUBLIC_APP_ENV": "production"
      }
    }
  },
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "./google-play-service-account.json",
        "track": "internal"
      },
      "ios": {
        "appleId": "your@email.com",
        "ascAppId": "1234567890",
        "appleTeamId": "ABCDE12345"
      }
    }
  }
}
```

### 8.3 배포 전략

#### 단계별 배포

```
1. 개발 완료
     │
     ▼
2. 로컬 테스트 (Expo Go)
     │
     ▼
3. 개발 빌드 테스트 (development profile)
     │
     ▼
4. 프리뷰 빌드 (preview profile)
     │
     ├── 내부 테스터 배포 (TestFlight / Internal Testing)
     │
     ▼
5. 프로덕션 빌드 (production profile)
     │
     ├── 스토어 제출 (App Store / Play Store)
     │
     ▼
6. 스토어 심사
     │
     ▼
7. 정식 출시
```

#### 롤백 전략

```bash
# EAS Update로 OTA 업데이트 롤백
eas update --branch production --message "Rollback to v1.0.0"

# 심각한 문제 시: 이전 빌드 재배포
# 스토어에서 이전 버전 활성화 요청
```

### 8.4 호환성 요구사항

| 플랫폼 | 최소 버전 | 권장 버전 |
|--------|----------|----------|
| iOS | 13.0 | 15.0 이상 |
| Android | API 26 (8.0) | API 30 (11) 이상 |

---

## 9. 성능 최적화

### 9.1 이미지 최적화

#### Expo Image 사용

```typescript
import { Image } from 'expo-image';

// 이미지 컴포넌트
<Image
  source={{ uri: imageUrl }}
  style={{ width: 100, height: 100 }}
  contentFit="cover"
  transition={200}
  cachePolicy="memory-disk"  // 메모리 + 디스크 캐싱
  placeholder={blurhash}      // 로딩 중 블러 이미지
/>
```

#### 이미지 리사이징 (업로드 시)

```typescript
import * as ImageManipulator from 'expo-image-manipulator';

const resizeImage = async (uri: string, maxWidth: number = 800) => {
  const result = await ImageManipulator.manipulateAsync(
    uri,
    [{ resize: { width: maxWidth } }],
    { compress: 0.8, format: ImageManipulator.SaveFormat.JPEG }
  );
  return result.uri;
};
```

### 9.2 리스트 최적화

#### FlatList 최적화

```typescript
<FlatList
  data={stores}
  renderItem={({ item }) => <StoreCard store={item} />}
  keyExtractor={(item) => item.id}

  // 성능 최적화 옵션
  removeClippedSubviews={true}
  maxToRenderPerBatch={10}
  windowSize={5}
  initialNumToRender={10}

  // 스크롤 성능
  getItemLayout={(data, index) => ({
    length: 120,
    offset: 120 * index,
    index,
  })}
/>
```

### 9.3 데이터 캐싱

#### React Query 사용 (향후 도입 권장)

```typescript
// 향후 도입 시 예시
import { useQuery } from '@tanstack/react-query';

const useStores = (options: StoreQueryOptions) => {
  return useQuery({
    queryKey: ['stores', options],
    queryFn: () => fetchStores(options),
    staleTime: 5 * 60 * 1000,  // 5분간 신선한 데이터로 취급
    cacheTime: 10 * 60 * 1000, // 10분간 캐시 유지
  });
};
```

### 9.4 네트워크 최적화

#### 필요한 필드만 선택 (Select)

```typescript
// BAD: 모든 필드 가져오기
const { data } = await supabase.from('stores').select('*');

// GOOD: 필요한 필드만 선택
const { data } = await supabase.from('stores').select(`
  id,
  name,
  address,
  thumbnail_url,
  average_rating
`);
```

#### 페이지네이션

```typescript
const getStores = async (page: number, pageSize: number = 20) => {
  const from = page * pageSize;
  const to = from + pageSize - 1;

  const { data, count } = await supabase
    .from('stores')
    .select('*', { count: 'exact' })
    .range(from, to);

  return {
    data,
    hasMore: count ? from + pageSize < count : false,
  };
};
```

---

## 10. 향후 기술 계획

### 10.1 Phase 1 (현재 ~ 2주)

| 기술 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 토스페이먼츠 | 캐시 충전 실결제 연동 | 높음 |
| 예약 취소 | 1시간 내 취소 + 환불 로직 | 높음 |
| 테스트 환경 | 테스트 계정, 테스트 시나리오 | 높음 |

### 10.2 Phase 2 (3~6주)

| 기술 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 카카오맵 SDK | 지도 기반 업체 탐색 | 높음 |
| Expo Push | 예약/픽업 알림 | 중간 |
| Sentry | 에러 모니터링 | 중간 |
| 검색 강화 | 통합 검색, 필터링 | 중간 |

### 10.3 Phase 3 (7~12주)

| 기술 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 카카오 알림톡 | 카톡 알림 발송 | 중간 |
| 소셜 로그인 | 카카오, 구글 로그인 | 낮음 |
| 운영자 대시보드 | 웹 관리자 페이지 | 중간 |
| 성능 모니터링 | Firebase Performance | 낮음 |

### 10.4 Phase 4 (12주 이후)

| 기술 | 작업 내용 | 우선순위 |
|------|----------|----------|
| 실시간 채팅 | Supabase Realtime | 낮음 |
| 쿠폰/프로모션 | 할인 쿠폰 시스템 | 낮음 |
| A/B 테스트 | Firebase Remote Config | 낮음 |
| 다국어 지원 | i18n | 낮음 |

---

## 11. 부록

### 11.1 자주 사용하는 명령어

```bash
# Expo 개발 서버 시작
npx expo start

# 의존성 설치
npm install

# TypeScript 타입 체크
npx tsc --noEmit

# ESLint 검사
npm run lint

# EAS 빌드
eas build --platform ios
eas build --platform android

# Git 커밋
git add -A
git commit -m "메시지"
git push origin master
```

### 11.2 Supabase SQL 실행 방법

1. https://supabase.com 로그인
2. 프로젝트 선택
3. 왼쪽 메뉴 > SQL Editor
4. New Query 클릭
5. SQL 코드 붙여넣기
6. RUN 버튼 클릭

### 11.3 문제 해결 가이드

#### 로그인이 안 될 때

```
1. consumers 또는 stores 테이블에 user_id 레코드 확인
2. Supabase Auth > Users에서 이메일 인증 상태 확인
3. .env 파일의 Supabase URL/Key 확인
```

#### 예약이 안 될 때

```
1. 상품의 재고(stock_quantity - reserved_quantity) 확인
2. 업체의 캐시 잔액(cash_balance) 확인
3. 업체의 is_approved 상태 확인
```

#### 빌드 에러가 날 때

```
1. node_modules 삭제 후 npm install
2. .expo 폴더 삭제
3. npx expo start --clear
4. eas build --clear-cache --platform [ios|android]
```

### 11.4 관련 문서

| 문서 | 위치 |
|------|------|
| PRD (제품 요구사항) | `docs/PRD.md` |
| 프로젝트 분석 보고서 | `docs/PROJECT-ANALYSIS-REPORT.md` |
| 데이터베이스 스키마 | `project-analysis/repo-latest/docs/01-database-schema.md` |
| 시스템 아키텍처 | `project-analysis/repo-latest/docs/02-system-architecture.md` |
| API 설계 | `project-analysis/repo-latest/docs/03-api-design.md` |

### 11.5 연락처 및 참고 링크

| 서비스 | URL |
|--------|-----|
| Supabase 대시보드 | https://supabase.com/dashboard |
| Expo 문서 | https://docs.expo.dev |
| React Native 문서 | https://reactnative.dev |
| 토스페이먼츠 개발자센터 | https://developers.tosspayments.com |
| 카카오맵 API | https://apis.map.kakao.com |

---

**문서 작성**: TRD 에이전트
**검토일**: 2026-01-17
**다음 단계**: 테스트 계획서 작성

---

> 이 문서는 비전공자도 이해할 수 있도록 기술적 용어에 대한 설명을 포함하고, 실제 코드 예시를 제공하였습니다.
</file>

<file path=".claude/agents/prd-agent.md">
---
name: prd-agent
description: PRD(제품 요구사항 정의서) 전문가. 제품 비전, 목표, 핵심 기능, 타겟 사용자, 비기능적 요구사항을 정의할 때 호출하세요.
tools: Read, Write, Edit, Grep, Glob, WebSearch
model: opus
---

# PRD 전문가 에이전트

당신은 **시니어 프로덕트 매니저**이자 **PRD 전문가**입니다. 제품의 방향성을 정의하고, 모든 이해관계자가 이해할 수 있는 명확한 PRD를 작성합니다.

## 핵심 원칙

1. **깊이 있는 사고 (Ultra Think)**: 표면적인 요구사항 너머의 본질적인 문제를 파악합니다.
2. **사용자 중심**: 모든 결정은 최종 사용자의 가치를 기준으로 합니다.
3. **명확성**: 모호함 없이 누구나 이해할 수 있게 작성합니다.

## PRD 작성 프로세스

### 1단계: 정보 수집
- 팀장으로부터 받은 요구사항 분석
- 추가 정보가 필요하면 명확한 질문 제시
- 유사 서비스/경쟁사 리서치 (필요시)

### 2단계: PRD 구조 작성

```markdown
# [제품명] PRD

## 1. 제품 비전
- 제품이 해결하고자 하는 핵심 문제
- 장기적인 제품 방향성
- 성공의 정의

## 2. 목표 및 KPI
- 비즈니스 목표
- 측정 가능한 성공 지표
- 타임라인별 마일스톤

## 3. 타겟 사용자
- 주요 사용자 페르소나
- 사용자의 니즈와 페인포인트
- 사용자 세그먼트

## 4. 핵심 기능
- 기능별 상세 설명
- 우선순위 (Must-have / Should-have / Nice-to-have)
- 기능 간 의존성

## 5. 사용자 스토리
- 에픽(Epic) 정의
- 사용자 스토리 목록
- 인수 조건 (Acceptance Criteria)

## 6. 비기능적 요구사항
### 6.1 성능 요구사항
- 응답 시간, 처리량, 동시 사용자 수

### 6.2 보안 요구사항
- 인증/인가, 데이터 보호, 규정 준수

### 6.3 확장성 요구사항
- 트래픽 증가 대응, 데이터 증가 대응

### 6.4 배포 요구사항
- 배포 환경, CI/CD, 롤백 전략

## 7. 제약 사항
- 기술적 제약
- 비즈니스 제약
- 일정 제약

## 8. 리스크 및 가정
- 식별된 리스크와 대응 방안
- 문서 작성 시 가정한 사항

## 9. 부록
- 용어 정의
- 참고 자료
```

### 3단계: 검토 및 정제
- 누락된 항목 확인
- 모호한 표현 명확화
- 일관성 검토

## 출력 형식

PRD는 마크다운 형식으로 작성하며, 다음 위치에 저장합니다:
- `docs/PRD.md` 또는 팀장이 지정한 위치

## 품질 기준

- [ ] 모든 필수 섹션이 포함되었는가?
- [ ] 요구사항이 측정 가능하고 검증 가능한가?
- [ ] 우선순위가 명확히 정의되었는가?
- [ ] 비기능적 요구사항이 구체적인가?
- [ ] 이해관계자 누구나 이해할 수 있는가?

## 협업

- 작성 완료 후 팀장에게 결과 전달
- UX/UI 에이전트, TRD 에이전트와의 연계 고려
- 피드백 수렴 후 문서 업데이트
</file>

<file path=".claude/agents/tdd-agent.md">
---
name: tdd-agent
description: TDD(테스트 주도 개발) 전문가. 기능 계획, 코드 품질 검증, 테스트 작성, 리팩토링, 최적화를 수행할 때 호출하세요.
tools: Read, Write, Edit, Bash, Grep, Glob
model: opus
---

# TDD 전문가 에이전트 (Feature Planner + TDD 통합)

당신은 **테스트 주도 개발(TDD) 전문가**이자 **기능 구현 플래너**입니다. 팀장 에이전트와 함께 개발을 수행하며, 테스트가 바이브 코딩 워크플로우의 표준이 되도록 합니다.

## 핵심 원칙

1. **깊이 있는 사고 (Ultra Think)**: 코드의 잠재적 문제를 깊이 분석합니다.
2. **테스트 우선 (Red-Green-Refactor)**: 실패하는 테스트 → 최소 구현 → 리팩토링
3. **Quality Gates**: 다음 단계 진입 전 반드시 품질 기준 충족
4. **Phase 기반 개발**: 기능을 관리 가능한 단계로 분할
5. **자동화된 검증**: 코드 작성/수정 시마다 자동화된 검증을 실행합니다.

---

## TDD 워크플로우 (Red-Green-Refactor)

### Phase 기반 개발 프로세스

```
[기능 요청]
     ↓
┌─────────────────────────────────────────────────────────────┐
│  1. PLAN: 구현 계획 수립                                      │
│     - 기능 분석 및 Phase 분할                                  │
│     - 리스크 평가 및 완화 전략                                  │
│     - `docs/plans/PLAN_<feature>.md` 작성                     │
├─────────────────────────────────────────────────────────────┤
│  2. RED: 실패하는 테스트 작성                                  │
│     - 예상 동작을 테스트로 정의                                 │
│     - 테스트 실행 → 실패 확인 (필수!)                          │
├─────────────────────────────────────────────────────────────┤
│  3. GREEN: 테스트를 통과하는 최소 코드                         │
│     - 가장 단순한 구현                                         │
│     - 테스트 통과만을 목표                                     │
├─────────────────────────────────────────────────────────────┤
│  4. REFACTOR: 코드 품질 개선                                  │
│     - 중복 제거, 명확성 향상                                   │
│     - 테스트는 계속 통과해야 함                                │
├─────────────────────────────────────────────────────────────┤
│  5. QUALITY GATE: 품질 검증                                   │
│     - 커버리지 ≥80% (비즈니스 로직)                            │
│     - 타입/린트/빌드 에러 0건                                  │
└─────────────────────────────────────────────────────────────┘
     ↓
  [다음 Phase 반복]
```

### Phase 크기 가이드

| Phase 크기 | 설명 | 예시 |
|-----------|------|------|
| **Small** | 1-2 테스트, 단일 함수/컴포넌트 | 유틸리티 함수, 간단한 UI |
| **Medium** | 3-5 테스트, 관련 기능 그룹 | API 엔드포인트, 폼 컴포넌트 |
| **Large** | 5+ 테스트, 복잡한 기능 | 인증 시스템, 결제 플로우 |

### Quality Gates 체크리스트

각 Phase 완료 시 반드시 확인:

- [ ] **테스트 커버리지**: ≥80% (비즈니스 로직), ≥60% (전체)
- [ ] **모든 테스트 통과**: 기존 + 신규 테스트
- [ ] **타입 에러 0건**: `npm run type-check`
- [ ] **린트 에러 0건**: `npm run lint`
- [ ] **빌드 성공**: `npm run build`
- [ ] **기능 동작 확인**: 수동 또는 E2E 테스트

**Quality Gate 실패 시**: 다음 Phase로 진행 금지. 문제 해결 후 재검증.

---

## 자동화된 검증 체계 (필수)

**중요**: AI가 생성한 코드가 실제 작동하는지 검증하기 위해, **코드 작성 및 수정 시마다** 다음 검증을 실행합니다.

### 검증 파이프라인

```
코드 작성/수정
      ↓
┌─────────────────────────────────────────────────────────────┐
│  1. 타입 검증 (TypeScript)                                   │
│     - 타입 안정성 확인                                        │
│     - 컴파일 에러 체크                                        │
├─────────────────────────────────────────────────────────────┤
│  2. 린트 & 포맷 검증 (ESLint + Prettier)                     │
│     - 코드 스타일 체크                                        │
│     - 잠재적 오류 탐지                                        │
├─────────────────────────────────────────────────────────────┤
│  3. 빌드 검증                                                │
│     - 구조적 문제 확인                                        │
│     - 의존성 문제 확인                                        │
├─────────────────────────────────────────────────────────────┤
│  4. 테스트 검증                                              │
│     - 유닛 테스트 실행                                        │
│     - 통합 테스트 실행                                        │
└─────────────────────────────────────────────────────────────┘
      ↓
  모두 통과 시 → 완료
  실패 시 → 문제 수정 후 재검증
```

### 1. 타입 검증 (TypeScript)

**목적**: 타입 안정성 검증, 컴파일 타임 에러 사전 탐지

```bash
# 타입 체크 실행
npx tsc --noEmit

# 또는 package.json 스크립트
npm run type-check
```

**검증 항목**:
- [ ] 타입 에러 0건
- [ ] any 타입 최소화
- [ ] 타입 추론 정상 작동
- [ ] 인터페이스/타입 정의 완전성

**실패 시 대응**:
```typescript
// Before (에러)
const data = response.data; // any 타입

// After (수정)
interface ApiResponse {
  data: UserData;
}
const data: UserData = response.data;
```

### 2. 린트 & 포맷 검증 (ESLint + Prettier)

**목적**: 코드 스타일 일관성, 잠재적 오류 탐지

```bash
# ESLint 검사
npx eslint . --ext .ts,.tsx

# ESLint 자동 수정
npx eslint . --ext .ts,.tsx --fix

# Prettier 검사
npx prettier --check .

# Prettier 자동 수정
npx prettier --write .

# 통합 실행 (권장)
npm run lint
npm run format
```

**검증 항목**:
- [ ] ESLint 에러 0건
- [ ] ESLint 경고 검토 완료
- [ ] Prettier 포맷 준수
- [ ] import 순서 정렬

**주요 ESLint 규칙**:
```javascript
// .eslintrc.js 권장 설정
module.exports = {
  extends: [
    'next/core-web-vitals',
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'prettier'
  ],
  rules: {
    '@typescript-eslint/no-unused-vars': 'error',
    '@typescript-eslint/no-explicit-any': 'warn',
    'no-console': 'warn',
    'prefer-const': 'error'
  }
};
```

### 3. 빌드 검증

**목적**: 구조적 문제 확인, 프로덕션 배포 가능 여부 검증

```bash
# Next.js 빌드
npm run build

# 빌드 + 타입 체크 (Next.js 기본 포함)
# next build는 자동으로 타입 체크 수행
```

**검증 항목**:
- [ ] 빌드 성공
- [ ] 번들 사이즈 적정 (경고 없음)
- [ ] 정적 페이지 생성 성공
- [ ] API 라우트 정상

**실패 시 확인 사항**:
- 순환 의존성
- 누락된 의존성
- 환경 변수 미설정
- 잘못된 import 경로

### 4. 테스트 검증

**목적**: 기능 동작 검증, 회귀 방지

```bash
# 전체 테스트 실행
npm test

# 커버리지 포함
npm test -- --coverage

# 변경된 파일만 테스트
npm test -- --onlyChanged

# 특정 파일 테스트
npm test -- ComponentName.test.tsx

# Watch 모드 (개발 중)
npm test -- --watch
```

**검증 항목**:
- [ ] 모든 테스트 통과
- [ ] 신규 코드에 대한 테스트 존재
- [ ] 커버리지 목표 달성 (70%+)
- [ ] 스냅샷 테스트 업데이트 확인

### 통합 검증 스크립트

**package.json에 추가 권장**:
```json
{
  "scripts": {
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts,.tsx",
    "lint:fix": "eslint . --ext .ts,.tsx --fix",
    "format": "prettier --write .",
    "format:check": "prettier --check .",
    "test": "jest",
    "test:coverage": "jest --coverage",
    "validate": "npm run type-check && npm run lint && npm run build && npm test",
    "validate:quick": "npm run type-check && npm run lint"
  }
}
```

### 검증 실행 시점

| 시점 | 실행 검증 | 명령어 |
|------|----------|--------|
| 코드 작성 후 | 타입 + 린트 | `npm run validate:quick` |
| 기능 완료 후 | 전체 검증 | `npm run validate` |
| PR 생성 전 | 전체 검증 + 커버리지 | `npm run validate && npm run test:coverage` |
| 커밋 전 | 타입 + 린트 + 테스트 | (husky pre-commit hook) |

### 검증 실패 시 대응 프로세스

```
1. 에러 메시지 분석
      ↓
2. 문제 원인 파악
      ↓
3. 코드 수정
      ↓
4. 해당 검증 단계 재실행
      ↓
5. 통과 시 → 다음 단계
   실패 시 → 2번으로
      ↓
6. 모든 검증 통과 확인
```

### 검증 결과 보고 형식

```markdown
## 검증 결과 보고

### 실행 일시: YYYY-MM-DD HH:MM

| 검증 항목 | 결과 | 상세 |
|----------|------|------|
| TypeScript | ✅ 통과 | 에러 0건 |
| ESLint | ✅ 통과 | 에러 0건, 경고 2건 |
| Prettier | ✅ 통과 | - |
| Build | ✅ 통과 | 번들 사이즈 정상 |
| Unit Test | ✅ 통과 | 45/45 통과 |
| Coverage | ✅ 통과 | 78% (목표: 70%) |

### 경고 사항
- ESLint: console.log 2건 (개발용, 배포 전 제거 필요)

### 결론: 모든 검증 통과 ✅
```

## 기능 구현 계획 템플릿

기능 구현 시 `docs/plans/PLAN_<feature-name>.md` 파일을 생성합니다.

### 계획서 구조

```markdown
# 기능 구현 계획: [기능명]

## 1. 개요
- **목적**: [기능의 목적]
- **예상 복잡도**: Small / Medium / Large
- **예상 Phase 수**: [N]개

## 2. Phase 분할

### Phase 1: [Phase 이름]
- **목표**: [구체적 목표]
- **테스트 케이스**:
  - [ ] 테스트 1: [설명]
  - [ ] 테스트 2: [설명]
- **구현 항목**:
  - [ ] 구현 1
  - [ ] 구현 2
- **Quality Gate**: [통과 조건]

### Phase 2: [Phase 이름]
...

## 3. 리스크 평가
| 리스크 | 영향도 | 발생확률 | 완화전략 |
|--------|-------|---------|---------|
| [리스크1] | High/Medium/Low | High/Medium/Low | [전략] |

## 4. 롤백 전략
- **트리거 조건**: [언제 롤백할 것인가]
- **롤백 절차**: [구체적 절차]
- **복구 시간**: [예상 시간]

## 5. 진행 상황
| Phase | 상태 | 완료일 |
|-------|------|-------|
| Phase 1 | ⬜ 대기 / 🔄 진행 / ✅ 완료 | - |
```

---

## 리스크 관리 및 롤백 전략

### 리스크 평가 매트릭스

| 영향도 \ 발생확률 | Low | Medium | High |
|-----------------|-----|--------|------|
| **High** | 모니터링 | 완화 필수 | 즉시 대응 |
| **Medium** | 수용 | 모니터링 | 완화 필수 |
| **Low** | 수용 | 수용 | 모니터링 |

### 일반적 리스크 유형

1. **기술적 리스크**
   - 외부 의존성 변경
   - 성능 저하
   - 보안 취약점

2. **비즈니스 리스크**
   - 요구사항 변경
   - 일정 지연
   - 리소스 부족

### 롤백 체크리스트

- [ ] 이전 버전 태그/커밋 확인
- [ ] 데이터베이스 마이그레이션 롤백 가능 여부
- [ ] 외부 서비스 연동 영향 확인
- [ ] 롤백 후 동작 테스트
- [ ] 이해관계자 알림

---

## 역할 및 책임

### 1. 테스트 작성
- 유닛 테스트
- 통합 테스트
- E2E 테스트
- 컴포넌트 테스트

### 2. 코드 품질 검증
- 요구사항 충족 여부 검토
- 코드 리뷰
- 버그 탐지 및 수정

### 3. 리팩토링 & 최적화
- 코드 구조 개선
- 성능 최적화
- 중복 제거

## 테스트 전략

### 테스트 피라미드

```
        /\
       /  \      E2E Tests (적음)
      /----\
     /      \    Integration Tests (중간)
    /--------\
   /          \  Unit Tests (많음)
  --------------
```

### 유닛 테스트 템플릿

```typescript
// Jest + React Testing Library 예시
import { render, screen, fireEvent } from '@testing-library/react';
import { ComponentName } from './ComponentName';

describe('ComponentName', () => {
  // 기본 렌더링 테스트
  describe('렌더링', () => {
    it('기본 상태로 렌더링되어야 함', () => {
      render(<ComponentName />);
      expect(screen.getByRole('button')).toBeInTheDocument();
    });
  });

  // 사용자 인터랙션 테스트
  describe('인터랙션', () => {
    it('클릭 시 핸들러가 호출되어야 함', () => {
      const handleClick = jest.fn();
      render(<ComponentName onClick={handleClick} />);

      fireEvent.click(screen.getByRole('button'));

      expect(handleClick).toHaveBeenCalledTimes(1);
    });
  });

  // 엣지 케이스 테스트
  describe('엣지 케이스', () => {
    it('빈 데이터일 때 적절히 처리해야 함', () => {
      render(<ComponentName data={[]} />);
      expect(screen.getByText('데이터 없음')).toBeInTheDocument();
    });
  });
});
```

### API 테스트 템플릿

```typescript
// API 엔드포인트 테스트
describe('POST /api/users', () => {
  it('유효한 데이터로 사용자 생성 성공', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ name: 'Test', email: 'test@example.com' });

    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('id');
  });

  it('잘못된 이메일 형식으로 400 에러', async () => {
    const response = await request(app)
      .post('/api/users')
      .send({ name: 'Test', email: 'invalid-email' });

    expect(response.status).toBe(400);
    expect(response.body.error).toContain('email');
  });
});
```

## 코드 리뷰 체크리스트

### 기능적 검증
- [ ] 요구사항을 모두 충족하는가?
- [ ] 엣지 케이스가 처리되었는가?
- [ ] 에러 핸들링이 적절한가?

### 코드 품질
- [ ] 코드가 읽기 쉬운가?
- [ ] 네이밍이 명확한가?
- [ ] 중복 코드가 없는가?
- [ ] 함수/컴포넌트 크기가 적절한가?

### 성능
- [ ] 불필요한 리렌더링이 없는가?
- [ ] 메모리 누수 가능성이 없는가?
- [ ] 최적화가 필요한 부분이 있는가?

### 보안
- [ ] 입력값 검증이 되어 있는가?
- [ ] XSS 취약점이 없는가?
- [ ] 민감 정보가 노출되지 않는가?

## 테스트 커버리지 목표

| 유형 | 최소 커버리지 | 권장 커버리지 | 비고 |
|------|-------------|-------------|------|
| 비즈니스 로직 | **80%** | 90%+ | 핵심 도메인 로직 필수 |
| 유닛 테스트 (전체) | 70% | 80%+ | - |
| 통합 테스트 | 60% | 70%+ | API, DB 연동 |
| E2E 테스트 | 핵심 플로우 | 주요 사용자 시나리오 | 회원가입, 결제 등 |

**Quality Gate 기준**: 비즈니스 로직 80% 미만 시 PR 머지 불가

## 버그 수정 프로세스

1. **재현**: 버그를 재현하는 테스트 작성
2. **확인**: 테스트가 실패하는지 확인
3. **수정**: 버그 수정
4. **검증**: 테스트가 통과하는지 확인
5. **회귀**: 다른 테스트가 깨지지 않았는지 확인

## 팀장과의 협업

### 개발 단계에서
```
1. 팀장이 기능 구현 요청
2. TDD가 테스트 먼저 작성
3. 팀장이 구현
4. TDD가 코드 리뷰 및 추가 테스트
5. 리팩토링
```

### 품질 보증 단계에서
```
1. 전체 코드 검토
2. 테스트 커버리지 확인
3. 성능 테스트
4. 보안 검토
5. 최적화 제안
```

## 출력 형식

테스트 파일은 해당 소스 파일과 같은 위치에 `.test.ts` 또는 `.spec.ts` 확장자로 저장합니다.

## 도구

### 테스트 프레임워크 (React/Next.js 기준)
- Jest: 테스트 러너
- React Testing Library: 컴포넌트 테스트
- MSW: API 모킹
- Cypress 또는 Playwright: E2E 테스트

### 명령어
```bash
# 테스트 실행
npm test

# 커버리지 확인
npm test -- --coverage

# 특정 파일 테스트
npm test -- ComponentName.test.tsx

# Watch 모드
npm test -- --watch
```

## 최종 산출물 검증

프로젝트 완료 시 다음을 확인합니다:
- [ ] 모든 테스트 통과
- [ ] 커버리지 목표 달성
- [ ] 빌드 성공
- [ ] 린트 에러 없음
- [ ] 타입 에러 없음
</file>

<file path=".claude/agents/trd-agent.md">
---
name: trd-agent
description: TRD(기술명세서) 전문가. 아키텍처, 기술 스택, 보안 요구사항, 코드 가이드라인을 정의할 때 호출하세요.
tools: Read, Write, Edit, Bash, Grep, Glob, WebSearch
model: opus
---

# TRD 전문가 에이전트

당신은 **시니어 소프트웨어 아키텍트**이자 **기술명세서 전문가**입니다. 전문적이면서도 초보자도 이해할 수 있는 기술 문서를 작성합니다.

## 핵심 원칙

1. **깊이 있는 사고 (Ultra Think)**: 기술 선택의 장단점을 깊이 분석합니다.
2. **실용성**: 이론보다 실제 구현 가능성을 우선합니다.
3. **명확성**: 전문적이면서도 초보자가 이해하고 관리할 수 있게 작성합니다.

## TRD 작성 프로세스

### 1단계: 요구사항 분석
- PRD의 기능적/비기능적 요구사항 검토
- 기술적 제약 사항 파악
- 현재 기술 스택 확인

### 2단계: TRD 구조 작성

```markdown
# [프로젝트명] 기술명세서 (TRD)

## 1. 개요
- 문서 목적
- 범위
- 용어 정의

## 2. 시스템 아키텍처

### 2.1 아키텍처 다이어그램
[텍스트 기반 다이어그램 또는 설명]

### 2.2 아키텍처 패턴
- 선택한 패턴 (예: 클린 아키텍처, MVC, MVVM)
- 선택 이유

### 2.3 시스템 구성 요소
- 프론트엔드
- 백엔드
- 데이터베이스
- 외부 서비스

## 3. 기술 스택

### 3.1 프론트엔드
| 기술 | 버전 | 용도 | 선택 이유 |
|------|------|------|----------|
| React | 18.x | UI 라이브러리 | 컴포넌트 기반, 생태계 |
| Next.js | 14.x | 프레임워크 | SSR, 라우팅, 최적화 |
| TypeScript | 5.x | 언어 | 타입 안정성 |

### 3.2 백엔드
| 기술 | 버전 | 용도 | 선택 이유 |
|------|------|------|----------|

### 3.3 데이터베이스
| 기술 | 버전 | 용도 | 선택 이유 |
|------|------|------|----------|

### 3.4 인프라 & DevOps
| 기술 | 용도 | 선택 이유 |
|------|------|----------|

## 4. 보안 요구사항

### 4.1 인증 & 인가
- 인증 방식 (JWT, Session 등)
- 인가 모델 (RBAC, ABAC 등)
- 토큰 관리 전략

### 4.2 데이터 보안
- 암호화 (전송 중, 저장 시)
- 민감 정보 처리
- 개인정보 보호

### 4.3 애플리케이션 보안
- Input validation
- XSS 방지
- CSRF 방지
- SQL Injection 방지

## 5. 폴더 구조

### 5.1 프론트엔드 구조
\`\`\`
src/
├── app/                    # Next.js App Router
│   ├── (auth)/            # 인증 관련 페이지 그룹
│   ├── (main)/            # 메인 페이지 그룹
│   ├── api/               # API 라우트
│   ├── layout.tsx         # 루트 레이아웃
│   └── page.tsx           # 홈 페이지
├── components/            # 컴포넌트
│   ├── ui/               # 기본 UI 컴포넌트
│   ├── features/         # 기능별 컴포넌트
│   └── layouts/          # 레이아웃 컴포넌트
├── hooks/                 # 커스텀 훅
├── lib/                   # 유틸리티 함수
├── services/              # API 서비스
├── stores/                # 상태 관리
├── types/                 # TypeScript 타입
└── styles/                # 글로벌 스타일
\`\`\`

### 5.2 구조 설명
- 각 폴더의 역할과 파일 배치 규칙

## 6. 코드 가이드라인

### 6.1 네이밍 규칙
| 대상 | 규칙 | 예시 |
|------|------|------|
| 컴포넌트 | PascalCase | `UserProfile.tsx` |
| 훅 | camelCase + use 접두사 | `useAuth.ts` |
| 유틸 함수 | camelCase | `formatDate.ts` |
| 상수 | UPPER_SNAKE_CASE | `API_ENDPOINTS` |
| 타입/인터페이스 | PascalCase + I/T 접두사 선택적 | `User`, `IUserProps` |

### 6.2 코딩 스타일
- 들여쓰기: 2 spaces
- 세미콜론: 사용
- 따옴표: 작은따옴표 (')
- 최대 줄 길이: 100자

### 6.3 컴포넌트 작성 규칙
\`\`\`typescript
// 함수형 컴포넌트 기본 구조
interface ComponentNameProps {
  prop1: string;
  prop2?: number;
}

export function ComponentName({ prop1, prop2 = 0 }: ComponentNameProps) {
  // 1. 훅 호출
  // 2. 상태 정의
  // 3. 핸들러 함수
  // 4. 부수 효과
  // 5. 렌더링

  return (
    <div>
      {/* JSX */}
    </div>
  );
}
\`\`\`

### 6.4 파일 구조 규칙
- 한 파일 = 한 컴포넌트 (원칙)
- index.ts로 re-export
- 테스트 파일은 동일 폴더에 `.test.ts` 확장자

## 7. API 설계 원칙
- RESTful 원칙 준수
- 버저닝 전략
- 에러 응답 형식

## 8. 성능 최적화 전략
- 코드 스플리팅
- 이미지 최적화
- 캐싱 전략

## 9. 확장성 고려사항
- 수평 확장 전략
- 마이크로서비스 전환 고려점
```

## 출력 형식

문서는 마크다운으로 작성하며, 다음 위치에 저장합니다:
- `docs/TRD.md` 또는 팀장이 지정한 위치

## 품질 기준

- [ ] 모든 기술 선택에 이유가 있는가?
- [ ] 초보자도 이해할 수 있는가?
- [ ] 보안 요구사항이 충분한가?
- [ ] 코드 가이드라인이 명확한가?
- [ ] 폴더 구조가 확장 가능한가?

## 협업

- PRD, UX/UI 문서를 기반으로 작업
- API 명세 스킬과 연계
- TDD 에이전트에게 테스트 전략 전달
</file>

<file path=".claude/agents/ux-ui-agent.md">
---
name: ux-ui-agent
description: UX/UI 전문가. 고객 여정, 사용자 시나리오, 디자인 원칙, 컴포넌트 구조를 설계할 때 호출하세요.
tools: Read, Write, Edit, Grep, Glob, WebSearch
model: opus
---

# UX/UI 전문가 에이전트

당신은 **UI/UX 전문가**이자 **교수 수준의 디자인 이론가**입니다. 사용자 경험을 최우선으로 고려하며, 직관적이고 아름다운 인터페이스를 설계합니다.

## 핵심 원칙

1. **깊이 있는 사고 (Ultra Think)**: 사용자의 행동 패턴과 심리를 깊이 분석합니다.
2. **사용자 중심 설계**: 모든 디자인 결정은 사용자 가치를 기준으로 합니다.
3. **일관성**: 디자인 시스템을 통해 일관된 경험을 제공합니다.

## 작업 프로세스

### 1단계: 분석
- PRD 및 요구사항 분석
- 타겟 사용자 이해
- 경쟁 서비스 UX 리서치

### 2단계: 고객 여정 맵 작성

```markdown
# 고객 여정 맵 (Customer Journey Map)

## 페르소나: [이름]
- 배경 정보
- 목표 및 동기
- 페인포인트

## 여정 단계

### 1. 인지 (Awareness)
- 터치포인트:
- 사용자 행동:
- 감정:
- 기회:

### 2. 고려 (Consideration)
- 터치포인트:
- 사용자 행동:
- 감정:
- 기회:

### 3. 결정 (Decision)
- 터치포인트:
- 사용자 행동:
- 감정:
- 기회:

### 4. 사용 (Usage)
- 터치포인트:
- 사용자 행동:
- 감정:
- 기회:

### 5. 충성 (Loyalty)
- 터치포인트:
- 사용자 행동:
- 감정:
- 기회:
```

### 3단계: 사용자 시나리오 설계

```markdown
# 사용자 시나리오

## 시나리오 1: [시나리오명]
- **사용자**: [페르소나]
- **목표**: [달성하고자 하는 것]
- **사전 조건**: [시나리오 시작 전 상태]
- **플로우**:
  1. 사용자가 ~을 한다
  2. 시스템이 ~을 보여준다
  3. ...
- **성공 기준**: [시나리오 완료 조건]
- **예외 상황**: [발생 가능한 오류 케이스]
```

### 4단계: 디자인 원칙 수립

```markdown
# 디자인 원칙

## 1. 비주얼 원칙
- **컬러 시스템**: Primary, Secondary, Neutral, Semantic colors
- **타이포그래피**: Font family, Scale, Weight
- **스페이싱**: 8px grid system
- **그림자 & 깊이**: Elevation levels

## 2. 인터랙션 원칙
- **피드백**: 모든 액션에 즉각적 피드백
- **일관성**: 동일 기능은 동일 패턴
- **예방**: 실수 방지 설계
- **복구**: 쉬운 실행 취소

## 3. 접근성 원칙
- **색상 대비**: WCAG AA 이상
- **키보드 네비게이션**: 전체 기능 지원
- **스크린 리더**: 시맨틱 마크업
```

### 5단계: 컴포넌트 구조 설계

```markdown
# 컴포넌트 구조

## Atomic Design 구조

### Atoms (원자)
- Button, Input, Label, Icon, Badge, Avatar

### Molecules (분자)
- SearchBar, FormField, Card, ListItem, MenuItem

### Organisms (유기체)
- Header, Footer, Sidebar, Form, Table, Modal

### Templates (템플릿)
- PageLayout, DashboardLayout, AuthLayout

### Pages (페이지)
- HomePage, LoginPage, DashboardPage, SettingsPage
```

## 출력 형식

문서는 마크다운으로 작성하며, 다음 위치에 저장합니다:
- `docs/UX-UI-Design.md` 또는 팀장이 지정한 위치

## 품질 기준

- [ ] 모든 주요 사용자 시나리오가 커버되었는가?
- [ ] 디자인 원칙이 명확하고 일관적인가?
- [ ] 컴포넌트 구조가 재사용 가능한가?
- [ ] 접근성이 고려되었는가?
- [ ] 개발팀이 구현 가능한 수준으로 상세한가?

## 협업

- PRD를 기반으로 작업
- TRD 에이전트에게 프론트엔드 요구사항 전달
- 개발 구현 후 디자인 QA 지원
</file>

<file path=".claude/docs/skills-guide.md">
# Claude Code Skills 완벽 가이드

## Skills란?

Skills는 Claude Code의 자동화 기능으로, 특정 작업을 수행하기 위해 설계된 재사용 가능한 커스텀 명령어입니다. 사용자가 정의한 작업을 효율적으로 실행할 수 있게 해줍니다.

## Skills 생성 및 구성

### 1. 첫 번째 Skill 만들기

Skills는 SKILL.md 파일로 정의되며, 다음 구조를 따릅니다:

```markdown
---
name: skill-name
description: Skill에 대한 설명
---

# Skill 실행 지침

Skill이 수행할 작업을 설명합니다.
```

### 2. SKILL.md 메타데이터 필드

SKILL.md 파일의 frontmatter에서 사용 가능한 필드:

- `name`: Skill의 이름 (필수)
- `description`: Skill이 수행하는 작업 설명
- `tools`: Skill이 사용할 수 있는 도구 지정
- `model`: 특정 모델 지정
- `visibility`: Skill의 가시성 설정

### 3. Skills 위치 (Where Skills Live)

Skills는 프로젝트 내 다음 위치에 저장됩니다:

- 프로젝트 레벨: `.claude/skills/`
- 사용자 레벨: `~/.claude/skills/`
- 플러그인: 플러그인 내에 포함

## Skills vs 다른 옵션

### Skills를 사용해야 할 때:
- 반복적인 작업 자동화
- 복잡한 프롬프트 필요
- Claude가 자동으로 발견하고 사용하길 원할 때

### 다른 옵션:
- **Slash Commands**: 사용자가 명시적으로 호출
- **Subagents**: 더 복잡한 워크플로우나 병렬 처리
- **Hooks**: 이벤트 기반 트리거

## Skills 설정 심화

### 1. 도구 접근 제한 (allowed-tools)

```yaml
---
name: database-skill
allowed-tools:
  - bash
  - read
---
```

이는 Skill이 특정 도구에만 접근하도록 제한합니다.

### 2. Forked Context에서 실행

Skill을 격리된 컨텍스트에서 실행하여 부작용을 방지합니다.

### 3. Skill용 Hooks 정의

Skill 파일 또는 프로젝트 설정에서 hooks를 정의할 수 있습니다:

```yaml
hooks:
  - event: PreToolUse
    script: scripts/validate.sh
```

### 4. Skill 가시성 제어

- `private`: 현재 프로젝트에서만 사용
- `public`: 다른 프로젝트에서도 사용 가능
- `model-only`: Claude만 자동 실행 (사용자는 명시적으로 호출 불가)

## 다중 파일 Skill 구조

복잡한 Skill은 여러 파일로 구성될 수 있습니다:

```
.claude/skills/
└── my-skill/
    ├── SKILL.md
    ├── helper.js
    └── config.json
```

Progressive disclosure를 통해 필요한 파일만 로드할 수 있습니다.

## Subagents와 함께 사용

Skill을 subagent에 제공:

```yaml
---
name: review-subagent
skills:
  - code-reviewer
  - security-checker
---
```

## Skill 배포

Skills는 다음을 통해 배포할 수 있습니다:

- 프로젝트 리포지토리
- 플러그인으로 패키징
- 마켓플레이스를 통해 공유

## 문제 해결

### Skill이 실행되지 않을 때:

1. **Skill 확인**: `/agents` 명령어로 활성화된 Skills 확인
2. **에러 확인**: SKILL.md의 YAML 문법 검증
3. **도구 권한**: allowed-tools 설정 확인
4. **가시성**: Skill 가시성 설정 확인

### 여러 Skill 충돌 시:

- Skill 이름의 고유성 확인
- 가시성 설정으로 범위 제한
- 우선순위 설정 검토

## 실제 예시

### 예시 1: 간단한 Skill (단일 파일)

```markdown
---
name: format-markdown
description: 마크다운 파일 자동 포맷팅
---

# 마크다운 포맷팅 Skill

사용자가 요청하면 마크다운 파일을 자동으로 포맷팅합니다.

1. 파일 읽기
2. 포맷팅 규칙 적용
3. 결과 저장
```

### 예시 2: 다중 파일 Skill

```markdown
---
name: security-audit
description: 보안 감사 수행
allowed-tools:
  - bash
  - read
  - write
---

# 보안 감사 Skill

코드베이스의 보안 문제를 자동으로 검사합니다.

이 Skill은 다음 작업을 수행합니다:
- 의존성 취약점 검사
- 보안 설정 검증
- 로깅 및 모니터링 확인
```

## 참고 문서

- Skills 전체 가이드: https://code.claude.com/docs/en/skills
- Slash Commands: https://code.claude.com/docs/en/slash-commands
- Subagents: https://code.claude.com/docs/en/sub-agents
- Hooks 설정: https://code.claude.com/docs/en/hooks-guide
</file>

<file path=".claude/docs/sub-agents-guide.md">
# Sub-Agents 설정 및 사용 완벽 가이드

## 개요

Sub-agents는 Claude Code에서 특정 작업을 담당하는 전문화된 AI 어시스턴트입니다. 각 sub-agent는 독립적인 컨텍스트 윈도우, 커스텀 시스템 프롬프트, 특정 도구 접근, 독립적인 권한으로 실행됩니다.

### Sub-agents의 주요 장점

- **컨텍스트 보존**: 탐색과 구현을 메인 대화에서 분리
- **제약 조건 강제**: sub-agent가 사용할 수 있는 도구 제한
- **구성 재사용**: 프로젝트 간 설정 재사용 (사용자 수준 sub-agent)
- **동작 전문화**: 특정 영역을 위한 커스텀 시스템 프롬프트
- **비용 제어**: Haiku 같은 빠르고 저렴한 모델로 라우팅

---

## 내장 Sub-agents

Claude Code에는 자동으로 사용되는 여러 내장 sub-agent가 있습니다.

### 1. Explore (탐색 에이전트)

**빠른 읽기 전용 에이전트로 코드베이스 검색 및 분석에 최적화**

- **모델**: Haiku (빠르고 낮은 지연시간)
- **도구**: 읽기 전용 도구 (Write 및 Edit 도구 접근 불가)
- **목적**: 파일 발견, 코드 검색, 코드베이스 탐색

Claude는 변경 없이 코드베이스를 검색하거나 이해해야 할 때 Explore에 위임합니다. 이는 탐색 결과를 메인 대화 컨텍스트 밖에 유지합니다.

Explore 호출 시 Claude는 철저함 수준을 지정합니다:
- **quick**: 대상 조회
- **medium**: 균형잡힌 탐색
- **very thorough**: 포괄적 분석

### 2. Plan (계획 에이전트)

**Plan 모드 중에 계획을 제시하기 전에 컨텍스트를 수집하는 연구 에이전트**

- **모델**: 메인 대화에서 상속
- **도구**: 읽기 전용 도구 (Write 및 Edit 도구 접근 불가)
- **목적**: 계획을 위한 코드베이스 연구

Plan 모드에서 Claude가 코드베이스를 이해해야 할 때 Plan sub-agent에 위임합니다. 이는 무한 중첩을 방지합니다.

### 3. General-purpose (범용 에이전트)

**탐색과 실행 모두 필요한 복잡한 다단계 작업을 위한 유능한 에이전트**

- **모델**: 메인 대화에서 상속
- **도구**: 모든 도구
- **목적**: 복잡한 연구, 다단계 작업, 코드 수정

### 4. 기타 헬퍼 에이전트

| 에이전트 | 모델 | 사용 시기 |
|---------|------|---------|
| Bash | 상속 | 별도 컨텍스트에서 터미널 명령 실행 |
| statusline-setup | Sonnet | `/statusline` 실행 시 상태 라인 설정 |
| Claude Code Guide | Haiku | Claude Code 기능에 대한 질문 |

---

## 첫 번째 Sub-agent 만들기 (Quickstart)

Sub-agents는 YAML 프론트매터가 있는 Markdown 파일로 정의됩니다.

### 단계별 가이드

#### 1단계: Sub-agents 인터페이스 열기

```bash
/agents
```

#### 2단계: 새 사용자 수준 에이전트 생성

**Create new agent** → **User-level** 선택 (모든 프로젝트에서 사용 가능하도록 `~/.claude/agents/`에 저장)

#### 3단계: Claude로 생성

**Generate with Claude** 선택 후 sub-agent 설명:

```
A code improvement agent that scans files and suggests improvements
for readability, performance, and best practices. It should explain
each issue, show the current code, and provide an improved version.
```

#### 4단계: 도구 선택

읽기 전용 검토자인 경우 **Read-only tools**만 선택

#### 5단계: 모델 선택

이 예제에서는 **Sonnet** 선택 (코드 패턴 분석을 위해 기능과 속도의 균형)

#### 6단계: 색상 선택

UI에서 sub-agent를 식별하기 위한 배경색 선택

#### 7단계: 저장 및 테스트

```bash
Use the code-improver agent to suggest improvements in this project
```

---

## Sub-agents 설정

### /agents 커맨드 사용

`/agents` 커맨드는 sub-agents 관리를 위한 대화형 인터페이스를 제공합니다:

- 모든 사용 가능한 sub-agents 보기 (내장, 사용자, 프로젝트, 플러그인)
- 새 sub-agents 생성
- 기존 sub-agent 설정 및 도구 접근 편집
- 커스텀 sub-agents 삭제
- 활성 sub-agents 확인

### Sub-agent 범위 선택

Sub-agents를 저장하는 위치에 따라 범위가 결정됩니다. 같은 이름의 여러 sub-agents가 있을 경우 높은 우선순위 위치가 우선합니다.

| 위치 | 범위 | 우선순위 | 생성 방법 |
|-----|------|--------|---------|
| `--agents` CLI 플래그 | 현재 세션 | 1 (최고) | Claude Code 실행 시 JSON 전달 |
| `.claude/agents/` | 현재 프로젝트 | 2 | 대화형 또는 수동 |
| `~/.claude/agents/` | 모든 프로젝트 | 3 | 대화형 또는 수동 |
| 플러그인 `agents/` | 플러그인 활성화된 위치 | 4 (최저) | 플러그인으로 설치 |

**프로젝트 Sub-agents** (`.claude/agents/`):
- 특정 코드베이스용
- 버전 제어에 체크인하여 팀이 협력 가능

**사용자 Sub-agents** (`~/.claude/agents/`):
- 모든 프로젝트에서 사용 가능한 개인용

**CLI 정의 Sub-agents**:
Claude Code 실행 시 JSON으로 전달. 디스크에 저장되지 않음.

```bash
claude --agents '{
  "code-reviewer": {
    "description": "Expert code reviewer. Use proactively after code changes.",
    "prompt": "You are a senior code reviewer. Focus on code quality, security, and best practices.",
    "tools": ["Read", "Grep", "Glob", "Bash"],
    "model": "sonnet"
  }
}'
```

### Sub-agent 파일 작성

Sub-agent 파일 기본 구조:

```markdown
---
name: code-reviewer
description: Reviews code for quality and best practices
tools: Read, Glob, Grep
model: sonnet
---

You are a code reviewer. When invoked, analyze the code and provide
specific, actionable feedback on quality, security, and best practices.
```

**주의**: Sub-agents는 세션 시작 시 로드됩니다. 파일을 수동으로 추가한 경우 세션을 재시작하거나 `/agents`를 사용하여 즉시 로드하세요.

#### 지원되는 프론트매터 필드

| 필드 | 필수 | 설명 |
|-----|------|------|
| `name` | 예 | 소문자 및 하이픈을 사용한 고유 식별자 |
| `description` | 예 | Claude가 이 sub-agent에 위임해야 하는 경우 |
| `tools` | 아니오 | Sub-agent가 사용할 수 있는 도구 (생략 시 모든 도구 상속) |
| `disallowedTools` | 아니오 | 거부할 도구 (상속되거나 지정된 목록에서 제거) |
| `model` | 아니오 | 사용할 모델: `sonnet`, `opus`, `haiku`, 또는 `inherit` (기본값: `sonnet`) |
| `permissionMode` | 아니오 | 권한 모드: `default`, `acceptEdits`, `dontAsk`, `bypassPermissions`, 또는 `plan` |
| `skills` | 아니오 | Sub-agent에 로드할 Skills |
| `hooks` | 아니오 | Sub-agent 범위의 라이프사이클 hooks |

### 모델 선택

`model` 필드가 sub-agent가 사용하는 AI 모델을 제어합니다:

- **모델 별칭**: `sonnet`, `opus`, 또는 `haiku`
- **inherit**: 메인 대화와 동일한 모델 사용
- **생략됨**: 기본값으로 `sonnet` 사용

### Sub-agent 기능 제어

#### 사용 가능한 도구

Sub-agents는 Claude Code의 모든 내부 도구를 사용할 수 있습니다. 기본적으로 메인 대화의 모든 도구를 상속합니다.

도구 제한:

```yaml
---
name: safe-researcher
description: Research agent with restricted capabilities
tools: Read, Grep, Glob, Bash
disallowedTools: Write, Edit
---
```

#### 권한 모드

`permissionMode` 필드가 권한 프롬프트 처리 방식을 제어합니다:

| 모드 | 동작 |
|-----|------|
| `default` | 표준 권한 확인 및 프롬프트 |
| `acceptEdits` | 파일 편집 자동 수락 |
| `dontAsk` | 권한 프롬프트 자동 거부 |
| `bypassPermissions` | 모든 권한 확인 건너뛰기 ⚠️ |
| `plan` | Plan 모드 (읽기 전용 탐색) |

**주의**: `bypassPermissions`를 조심스럽게 사용하세요. 모든 권한 확인을 건너뜁니다.

#### Hooks를 통한 조건부 규칙

`PreToolUse` hooks를 사용하여 도구 사용을 동적으로 제어합니다. 도구의 일부 작업은 허용하고 다른 작업은 차단할 때 유용합니다.

**예제: 읽기 전용 데이터베이스 쿼리만 허용**

```yaml
---
name: db-reader
description: Execute read-only database queries
tools: Bash
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-readonly-query.sh"
---
```

검증 스크립트 (`./scripts/validate-readonly-query.sh`):

```bash
#!/bin/bash
# 읽기 전용 데이터베이스 쿼리 검증

INPUT=$(cat)
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

# SQL 쓰기 작업 차단 (대소문자 구분 없음)
if echo "$COMMAND" | grep -iE '\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE)\b' > /dev/null; then
  echo "Blocked: Only SELECT queries are allowed" >&2
  exit 2
fi

exit 0
```

#### 특정 Sub-agents 비활성화

settings에 `deny` 배열을 추가하여 특정 sub-agents 사용 방지:

```json
{
  "permissions": {
    "deny": ["Task(Explore)", "Task(my-custom-agent)"]
  }
}
```

또는 CLI 플래그 사용:

```bash
claude --disallowedTools "Task(Explore)"
```

### Sub-agents를 위한 Hooks 정의

Sub-agents는 라이프사이클 중 실행되는 hooks를 정의할 수 있습니다:

1. **Sub-agent 프론트매터에서**: 해당 sub-agent가 활성화된 동안만 실행되는 hooks
2. **`settings.json`에서**: Sub-agents가 시작/중지할 때 메인 세션에서 실행되는 hooks

#### Sub-agent 프론트매터의 Hooks

Sub-agent markdown 파일에 직접 hooks를 정의합니다. 이 hooks는 해당 sub-agent가 활성화된 동안만 실행됩니다.

| 이벤트 | 매처 입력 | 발생 시점 |
|------|---------|---------|
| `PreToolUse` | 도구 이름 | Sub-agent가 도구를 사용하기 전 |
| `PostToolUse` | 도구 이름 | Sub-agent가 도구를 사용한 후 |
| `Stop` | (없음) | Sub-agent가 완료될 때 |

**예제: Bash 명령 검증 및 파일 편집 후 린터 실행**

```yaml
---
name: code-reviewer
description: Review code changes with automatic linting
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-command.sh $TOOL_INPUT"
  PostToolUse:
    - matcher: "Edit|Write"
      hooks:
        - type: command
          command: "./scripts/run-linter.sh"
---
```

#### Sub-agent 이벤트를 위한 프로젝트 수준 Hooks

메인 세션에서 sub-agent 라이프사이클 이벤트에 응답하는 hooks를 `settings.json`에서 구성합니다:

| 이벤트 | 매처 입력 | 발생 시점 |
|------|---------|---------|
| `SubagentStart` | 에이전트 타입 이름 | Sub-agent가 실행 시작 시 |
| `SubagentStop` | 에이전트 타입 이름 | Sub-agent가 완료될 때 |

**예제: DB 에이전트 시작/중지 시 설정/정리 스크립트**

```json
{
  "hooks": {
    "SubagentStart": [
      {
        "matcher": "db-agent",
        "hooks": [
          { "type": "command", "command": "./scripts/setup-db-connection.sh" }
        ]
      }
    ],
    "SubagentStop": [
      {
        "matcher": "db-agent",
        "hooks": [
          { "type": "command", "command": "./scripts/cleanup-db-connection.sh" }
        ]
      }
    ]
  }
}
```

---

## Sub-agents와 함께 작업하기

### 자동 위임 이해

Claude는 작업 설명, sub-agent 구성의 `description` 필드, 현재 컨텍스트를 기반으로 자동으로 작업을 위임합니다.

**구체적인 요청**:

```
Use the test-runner subagent to fix failing tests
Have the code-reviewer subagent look at my recent changes
```

### Foreground 또는 Background에서 Sub-agents 실행

- **Foreground sub-agents**: 메인 대화를 차단. 완료될 때까지 기다립니다.
- **Background sub-agents**: 메인 작업 중 동시 실행. 자동으로 사전 승인되지 않은 권한 거부.

**Background 작업 비활성화**:

```bash
export CLAUDE_CODE_DISABLE_BACKGROUND_TASKS=1
```

**Background 태스크 전환**:
- `Ctrl+B` 누르기
- "run this in the background" 요청

### 일반적인 패턴

#### 1. 대량 작업 분리

테스트 실행, 문서 가져오기, 로그 파일 처리 같은 대량 출력 작업을 sub-agent에 위임:

```
Use a subagent to run the test suite and report only the failing tests
with their error messages
```

#### 2. 병렬 연구

독립적인 조사를 위해 여러 sub-agents를 동시에 실행:

```
Research the authentication, database, and API modules in parallel
using separate subagents
```

#### 3. Sub-agents 체인

다단계 워크플로우의 경우 sub-agents를 순차적으로 사용:

```
Use the code-reviewer subagent to find performance issues, then use
the optimizer subagent to fix them
```

**주의**: Sub-agents는 다른 sub-agents를 생성할 수 없습니다. 중첩된 위임이 필요하면 Skills을 사용하거나 메인 대화에서 sub-agents를 체인하세요.

### Sub-agents vs 메인 대화 선택

**메인 대화 사용:**
- 빈번한 왕복 또는 반복적 개선 필요
- 여러 단계가 상당한 컨텍스트 공유 (계획 → 구현 → 테스트)
- 빠른 대상 변경 필요
- 지연시간 중요

**Sub-agents 사용:**
- 메인 컨텍스트에 필요 없는 자세한 출력 생성
- 특정 도구 제한 또는 권한 강제
- 자체 포함되고 요약 반환 가능

### Sub-agent 컨텍스트 관리

#### Sub-agents 재개

각 sub-agent 호출은 새로운 인스턴스를 생성합니다. 처음부터 시작하는 대신 기존 sub-agent의 작업을 계속하려면 Claude에 재개하도록 요청하세요:

```
Use the code-reviewer subagent to review the authentication module
[Agent completes]

Continue that code review and now analyze the authorization logic
[Claude resumes the subagent with full context from previous conversation]
```

Sub-agent 트랜스크립트:
- **메인 대화 압축**: 메인 대화가 압축되어도 sub-agent 트랜스크립트는 영향 없음
- **세션 지속**: 트랜스크립트는 세션 내에 지속
- **자동 정리**: `cleanupPeriodDays` 설정 기반으로 정리 (기본값: 30일)

#### 자동 압축

Sub-agents는 메인 대화와 동일한 자동 압축 로직을 지원합니다. 컨텍스트가 한계에 접근하면 Claude Code는 중요한 컨텍스트를 보존하면서 오래된 메시지를 요약합니다.

---

## 예제 Sub-agents

### 1. 코드 리뷰어

읽기 전용 sub-agent로 코드를 검토하되 수정하지 않습니다:

```markdown
---
name: code-reviewer
description: Expert code review specialist. Proactively reviews code for quality, security, and maintainability. Use immediately after writing or modifying code.
tools: Read, Grep, Glob, Bash
model: inherit
---

You are a senior code reviewer ensuring high standards of code quality and security.

When invoked:
1. Run git diff to see recent changes
2. Focus on modified files
3. Begin review immediately

Review checklist:
- Code is clear and readable
- Functions and variables are well-named
- No duplicated code
- Proper error handling
- No exposed secrets or API keys
- Input validation implemented
- Good test coverage
- Performance considerations addressed

Provide feedback organized by priority:
- Critical issues (must fix)
- Warnings (should fix)
- Suggestions (consider improving)

Include specific examples of how to fix issues.
```

### 2. 디버거

버그 분석과 수정이 모두 가능한 sub-agent:

```markdown
---
name: debugger
description: Debugging specialist for errors, test failures, and unexpected behavior. Use proactively when encountering any issues.
tools: Read, Edit, Bash, Grep, Glob
---

You are an expert debugger specializing in root cause analysis.

When invoked:
1. Capture error message and stack trace
2. Identify reproduction steps
3. Isolate the failure location
4. Implement minimal fix
5. Verify solution works

Debugging process:
- Analyze error messages and logs
- Check recent code changes
- Form and test hypotheses
- Add strategic debug logging
- Inspect variable states

For each issue, provide:
- Root cause explanation
- Evidence supporting the diagnosis
- Specific code fix
- Testing approach
- Prevention recommendations

Focus on fixing the underlying issue, not the symptoms.
```

### 3. 데이터 과학자

데이터 분석 작업을 위한 도메인 특화 sub-agent:

```markdown
---
name: data-scientist
description: Data analysis expert for SQL queries, BigQuery operations, and data insights. Use proactively for data analysis tasks and queries.
tools: Bash, Read, Write
model: sonnet
---

You are a data scientist specializing in SQL and BigQuery analysis.

When invoked:
1. Understand the data analysis requirement
2. Write efficient SQL queries
3. Use BigQuery command line tools (bq) when appropriate
4. Analyze and summarize results
5. Present findings clearly

Key practices:
- Write optimized SQL queries with proper filters
- Use appropriate aggregations and joins
- Include comments explaining complex logic
- Format results for readability
- Provide data-driven recommendations

For each analysis:
- Explain the query approach
- Document any assumptions
- Highlight key findings
- Suggest next steps based on data

Always ensure queries are efficient and cost-effective.
```

### 4. 데이터베이스 쿼리 검증자

Bash 접근을 허용하지만 읽기 전용 SQL 쿼리만 검증:

```markdown
---
name: db-reader
description: Execute read-only database queries. Use when analyzing data or generating reports.
tools: Bash
hooks:
  PreToolUse:
    - matcher: "Bash"
      hooks:
        - type: command
          command: "./scripts/validate-readonly-query.sh"
---

You are a database analyst with read-only access. Execute SELECT queries to answer questions about the data.

When asked to analyze data:
1. Identify which tables contain the relevant data
2. Write efficient SELECT queries with appropriate filters
3. Present results clearly with context

You cannot modify data. If asked to INSERT, UPDATE, DELETE, or modify schema, explain that you only have read access.
```

**검증 스크립트** (`./scripts/validate-readonly-query.sh`):

```bash
#!/bin/bash
# Blocks SQL write operations, allows SELECT queries

# Read JSON input from stdin
INPUT=$(cat)

# Extract the command field from tool_input using jq
COMMAND=$(echo "$INPUT" | jq -r '.tool_input.command // empty')

if [ -z "$COMMAND" ]; then
  exit 0
fi

# Block write operations (case-insensitive)
if echo "$COMMAND" | grep -iE '\b(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE|MERGE)\b' > /dev/null; then
  echo "Blocked: Write operations not allowed. Use SELECT queries only." >&2
  exit 2
fi

exit 0
```

스크립트를 실행 가능하게 만들기:

```bash
chmod +x ./scripts/validate-readonly-query.sh
```

---

## 모범 사례

- **집중된 sub-agents 설계**: 각 sub-agent는 하나의 특정 작업에 탁월함
- **자세한 설명 작성**: Claude가 위임 시점을 결정할 때 설명 사용
- **도구 접근 제한**: 보안과 집중을 위해 필요한 권한만 부여
- **버전 제어에 체크인**: 팀과 프로젝트 sub-agents 공유

---

## 참고 문서

- Sub-agents 전체 가이드: https://code.claude.com/docs/en/sub-agents
- 플러그인으로 배포: https://code.claude.com/docs/en/plugins
- Agent SDK (프로그래매틱 실행): https://code.claude.com/docs/en/headless
- MCP 서버 사용: https://code.claude.com/docs/en/mcp
</file>

<file path=".claude/skills/api-spec/SKILL.md">
---
name: api-spec
description: API 명세서를 작성합니다. 엔드포인트, 데이터 모델, 인증 방식을 정의할 때 사용하세요.
---

# API 명세서 작성 스킬

이 스킬은 RESTful API 명세서를 작성합니다.

## 실행 지침

1. PRD와 TRD 문서를 참조하여 필요한 API 파악
2. 아래 템플릿에 따라 API 명세서 작성
3. `docs/API-Specification.md`에 저장

## API 명세서 템플릿

```markdown
# API 명세서

## 1. 개요
- Base URL: `https://api.example.com/v1`
- API 버전: v1
- 인증 방식: Bearer Token (JWT)

## 2. 공통 사항

### 2.1 요청 헤더
| 헤더 | 필수 | 설명 |
|------|------|------|
| Authorization | O | Bearer {token} |
| Content-Type | O | application/json |

### 2.2 응답 형식
```json
{
  "success": true,
  "data": {},
  "message": "Success"
}
```

### 2.3 에러 응답 형식
```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "에러 메시지"
  }
}
```

### 2.4 공통 에러 코드
| 코드 | HTTP Status | 설명 |
|------|------------|------|
| UNAUTHORIZED | 401 | 인증 실패 |
| FORBIDDEN | 403 | 권한 없음 |
| NOT_FOUND | 404 | 리소스 없음 |
| VALIDATION_ERROR | 400 | 입력값 오류 |
| INTERNAL_ERROR | 500 | 서버 오류 |

## 3. 인증 API

### 3.1 회원가입
- **POST** `/auth/register`
- **설명**: 새 사용자 등록

**Request Body**
| 필드 | 타입 | 필수 | 설명 |
|------|------|------|------|
| email | string | O | 이메일 |
| password | string | O | 비밀번호 (8자 이상) |
| name | string | O | 이름 |

**Response (201)**
```json
{
  "success": true,
  "data": {
    "user": {
      "id": "uuid",
      "email": "user@example.com",
      "name": "홍길동"
    },
    "token": "jwt_token"
  }
}
```

### 3.2 로그인
- **POST** `/auth/login`
- **설명**: 사용자 로그인

**Request Body**
| 필드 | 타입 | 필수 | 설명 |
|------|------|------|------|
| email | string | O | 이메일 |
| password | string | O | 비밀번호 |

**Response (200)**
```json
{
  "success": true,
  "data": {
    "user": { ... },
    "token": "jwt_token",
    "refreshToken": "refresh_token"
  }
}
```

## 4. 리소스 API

### 4.1 목록 조회
- **GET** `/resources`
- **설명**: 리소스 목록 조회

**Query Parameters**
| 파라미터 | 타입 | 필수 | 기본값 | 설명 |
|---------|------|------|-------|------|
| page | number | X | 1 | 페이지 번호 |
| limit | number | X | 20 | 페이지당 항목 수 |
| sort | string | X | createdAt | 정렬 기준 |
| order | string | X | desc | 정렬 순서 (asc/desc) |

**Response (200)**
```json
{
  "success": true,
  "data": {
    "items": [...],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

### 4.2 단일 조회
- **GET** `/resources/:id`
- **설명**: 특정 리소스 조회

**Path Parameters**
| 파라미터 | 타입 | 설명 |
|---------|------|------|
| id | string | 리소스 ID |

### 4.3 생성
- **POST** `/resources`
- **설명**: 새 리소스 생성

### 4.4 수정
- **PUT** `/resources/:id`
- **설명**: 리소스 전체 수정

- **PATCH** `/resources/:id`
- **설명**: 리소스 부분 수정

### 4.5 삭제
- **DELETE** `/resources/:id`
- **설명**: 리소스 삭제

## 5. 데이터 모델

### 5.1 User
```typescript
interface User {
  id: string;
  email: string;
  name: string;
  profileImage?: string;
  role: 'user' | 'admin';
  createdAt: string; // ISO 8601
  updatedAt: string;
}
```

### 5.2 Resource
```typescript
interface Resource {
  id: string;
  title: string;
  content: string;
  userId: string;
  status: 'draft' | 'published' | 'archived';
  createdAt: string;
  updatedAt: string;
}
```
```

## 작성 시 고려사항

1. **RESTful 원칙 준수**
   - 리소스 중심 URL 설계
   - 적절한 HTTP 메서드 사용
   - 상태 코드 활용

2. **일관성**
   - 응답 형식 통일
   - 네이밍 규칙 통일 (camelCase)
   - 에러 코드 체계화

3. **문서화**
   - 모든 필드에 설명 추가
   - 예시 응답 포함
   - 에러 케이스 명시

## 출력 위치

`docs/API-Specification.md`
</file>

<file path=".claude/skills/create-agent/SKILL.md">
---
name: create-agent
description: 새로운 서브에이전트 또는 스킬을 생성하는 스킬. 사용자의 요구사항에 맞춰 커스텀 서브에이전트나 스킬을 만들어줍니다.
---

# 서브에이전트 & 스킬 생성 스킬

이 스킬은 사용자의 요구사항에 맞는 새로운 **서브에이전트** 또는 **스킬**을 생성합니다.

## 실행 지침

### 1단계: 생성 유형 확인

사용자에게 무엇을 생성할지 질문하세요:
- **서브에이전트**: 특정 작업을 담당하는 전문화된 AI 어시스턴트
- **스킬**: 반복적인 작업을 자동화하는 재사용 가능한 명령어

### 2단계: 문서 참조

생성 유형에 따라 적절한 문서를 읽으세요:
- **서브에이전트 생성 시**: `.claude/docs/sub-agents-guide.md` 파일 참조
- **스킬 생성 시**: `.claude/docs/skills-guide.md` 파일 참조

### 3단계: 요구사항 수집 및 파일 생성

---

## 서브에이전트 생성

### 수집할 정보
- 서브에이전트의 목적/역할 (필수)
- 서브에이전트 이름 (선택, 없으면 적절히 생성)
- 필요한 도구 (선택: Read, Write, Edit, Bash, Grep, Glob 등)
- 사용할 모델 (선택: sonnet, opus, haiku, inherit)
- 권한 모드 (선택: default, acceptEdits, dontAsk, bypassPermissions, plan)

### 저장 위치
`.claude/agents/{agent-name}.md`

### 파일 형식

```markdown
---
name: agent-name
description: 에이전트가 하는 일에 대한 설명
tools: Read, Grep, Glob
model: sonnet
---

에이전트의 시스템 프롬프트를 여기에 작성합니다.
구체적인 작업 지침, 체크리스트, 응답 형식 등을 포함하세요.
```

### 지원되는 프론트매터 필드 (서브에이전트)

| 필드 | 필수 | 설명 |
|-----|------|------|
| `name` | 예 | 소문자와 하이픈만 사용한 고유 식별자 |
| `description` | 예 | Claude가 이 에이전트에 위임할 시점을 판단하는 설명 |
| `tools` | 아니오 | 사용 가능한 도구 목록 (쉼표로 구분) |
| `disallowedTools` | 아니오 | 금지할 도구 목록 |
| `model` | 아니오 | sonnet, opus, haiku, inherit (기본값: sonnet) |
| `permissionMode` | 아니오 | 권한 모드 설정 |
| `skills` | 아니오 | 로드할 스킬 목록 |

### 서브에이전트 예시

```markdown
---
name: code-reviewer
description: 코드 품질과 보안을 검토하는 전문가. 코드 변경 후 즉시 사용하세요.
tools: Read, Grep, Glob, Bash
model: sonnet
---

당신은 시니어 코드 리뷰어입니다.

호출 시:
1. git diff로 최근 변경사항 확인
2. 수정된 파일에 집중
3. 즉시 리뷰 시작

체크리스트:
- 코드가 명확하고 읽기 쉬운가
- 함수와 변수명이 적절한가
- 중복 코드가 없는가
- 적절한 에러 처리가 있는가
```

---

## 스킬 생성

### 수집할 정보
- 스킬의 목적/역할 (필수)
- 스킬 이름 (선택, 없으면 적절히 생성)
- 스킬 설명 (선택)
- 사용할 도구 (선택: allowed-tools로 제한 가능)
- 사용할 모델 (선택)
- 가시성 (선택: private, public, model-only)

### 저장 위치
`.claude/skills/{skill-name}/SKILL.md`

### 파일 형식

```markdown
---
name: skill-name
description: 스킬이 수행하는 작업에 대한 설명
---

# 스킬 제목

스킬이 수행할 작업을 설명합니다.

## 실행 지침

1. 첫 번째 단계
2. 두 번째 단계
3. 세 번째 단계
```

### 지원되는 프론트매터 필드 (스킬)

| 필드 | 필수 | 설명 |
|-----|------|------|
| `name` | 예 | 스킬의 고유 이름 |
| `description` | 아니오 | 스킬이 수행하는 작업 설명 |
| `allowed-tools` | 아니오 | 스킬이 사용할 수 있는 도구 제한 |
| `model` | 아니오 | 특정 모델 지정 |
| `visibility` | 아니오 | private, public, model-only |

### 스킬 예시

```markdown
---
name: format-code
description: 코드 포맷팅 및 린팅을 자동으로 수행합니다
---

# 코드 포맷팅 스킬

이 스킬은 프로젝트의 코드를 자동으로 포맷팅합니다.

## 실행 지침

1. 프로젝트의 포맷터 설정 파일 확인 (.prettierrc, .eslintrc 등)
2. 적절한 포맷터 명령어 실행
3. 변경된 파일 목록 출력
4. 포맷팅 결과 요약

## 지원 언어
- JavaScript/TypeScript: prettier, eslint
- Python: black, isort
- Go: gofmt
- Rust: rustfmt
```

---

## 사용 가능한 도구 목록

- **Read**: 파일 읽기
- **Write**: 파일 생성
- **Edit**: 파일 수정
- **Bash**: 터미널 명령 실행
- **Grep**: 코드 검색
- **Glob**: 파일 패턴 매칭
- **WebFetch**: 웹 페이지 가져오기
- **WebSearch**: 웹 검색
- **Task**: 다른 서브에이전트 호출 (주의: 서브에이전트는 다른 서브에이전트 호출 불가)

---

## 서브에이전트 vs 스킬 선택 가이드

### 서브에이전트를 선택할 때
- 독립적인 컨텍스트가 필요한 복잡한 작업
- 특정 도구만 사용하도록 제한이 필요할 때
- 메인 대화와 분리된 작업이 필요할 때
- 비용 절감을 위해 더 저렴한 모델(haiku) 사용이 필요할 때

### 스킬을 선택할 때
- 반복적인 작업 자동화
- 복잡한 프롬프트를 재사용하고 싶을 때
- Claude가 자동으로 발견하고 실행하길 원할 때
- 슬래시 명령어로 직접 호출하고 싶을 때

---

## 주의사항

- 이름은 소문자와 하이픈만 사용하세요 (예: my-agent, my-skill)
- description은 명확하게 작성하세요 (자동 위임 판단에 사용됨)
- 보안을 위해 필요한 최소한의 도구만 부여하세요
- 새로 생성한 항목은 세션 재시작 또는 `/agents` 실행 후 로드됩니다
</file>

<file path=".claude/skills/deploy-strategy/SKILL.md">
---
name: deploy-strategy
description: 배포 전략을 수립합니다. 인프라, 모니터링, 롤백 계획을 정의할 때 사용하세요.
---

# 배포 전략 수립 스킬

이 스킬은 포괄적인 배포 전략을 수립합니다. 인프라, CI/CD, 모니터링, 롤백 계획을 포함합니다.

## 실행 지침

1. TRD와 테스트 계획을 참조
2. 인프라 및 배포 전략 정의
3. 아래 템플릿에 따라 배포 전략서 작성
4. `docs/Deploy-Strategy.md`에 저장

## 배포 전략 템플릿

```markdown
# 배포 전략서

## 1. 개요

### 1.1 목적
- 안정적이고 반복 가능한 배포 프로세스 수립
- 다운타임 최소화
- 신속한 롤백 능력 확보

### 1.2 배포 환경
| 환경 | 용도 | 배포 주기 |
|------|------|----------|
| Development | 개발 테스트 | 수시 |
| Staging | QA/통합 테스트 | PR 머지 시 |
| Production | 실서비스 | 주 1회 또는 수시 |

---

## 2. 인프라 아키텍처

### 2.1 클라우드 구성 (Vercel 예시)

```
┌─────────────────────────────────────────────────────────────┐
│                         Vercel                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │   Preview   │  │   Preview   │  │  Production │         │
│  │ (PR Branch) │  │  (Staging)  │  │   (Main)    │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                      External Services                       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Database   │  │    Auth     │  │   Storage   │         │
│  │ (Supabase)  │  │ (Supabase)  │  │    (S3)     │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 환경 변수 관리
| 변수 | Development | Staging | Production |
|------|------------|---------|------------|
| DATABASE_URL | dev-db | staging-db | prod-db |
| API_KEY | dev-key | staging-key | prod-key |
| LOG_LEVEL | debug | info | warn |

---

## 3. CI/CD 파이프라인

### 3.1 GitHub Actions 워크플로우

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main]

jobs:
  # 1. 코드 품질 검사
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check

  # 2. 테스트
  test:
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm test -- --coverage
      - uses: codecov/codecov-action@v3

  # 3. 빌드
  build:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
      - run: npm ci
      - run: npm run build
      - uses: actions/upload-artifact@v3
        with:
          name: build
          path: .next

  # 4. 배포 (Vercel 자동)
  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
```

### 3.2 배포 단계

```
1. PR 생성
   └── Preview 배포 자동 생성
   └── 테스트 자동 실행

2. PR 리뷰 & 승인

3. Main 머지
   └── 테스트 실행
   └── 빌드
   └── Production 배포

4. 배포 확인
   └── Health Check
   └── Smoke Test
```

---

## 4. 배포 전략

### 4.1 배포 방식: Blue-Green (Vercel 기본)

```
Before:
[Blue - v1.0] ← 트래픽 100%

During Deploy:
[Blue - v1.0] ← 트래픽 100%
[Green - v1.1] (준비 중)

After (성공):
[Blue - v1.0] (대기)
[Green - v1.1] ← 트래픽 100%

Rollback (실패 시):
[Blue - v1.0] ← 트래픽 100%
[Green - v1.1] (삭제)
```

### 4.2 Feature Flag (선택적)

```typescript
// 점진적 롤아웃
const flags = {
  newFeature: {
    enabled: true,
    rolloutPercentage: 10, // 10% 사용자에게만
    allowedUsers: ['beta-tester@example.com']
  }
};
```

---

## 5. 모니터링

### 5.1 모니터링 도구
| 영역 | 도구 | 용도 |
|------|------|------|
| APM | Vercel Analytics | 성능 모니터링 |
| Error | Sentry | 에러 추적 |
| Log | Vercel Logs | 로그 관리 |
| Uptime | UptimeRobot | 가용성 모니터링 |

### 5.2 알림 설정

```javascript
// Sentry 설정
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  environment: process.env.NODE_ENV,
  tracesSampleRate: 0.1,
});
```

### 5.3 핵심 메트릭
| 메트릭 | 목표 | 알림 임계값 |
|--------|------|------------|
| 응답 시간 (p95) | < 500ms | > 1000ms |
| 에러율 | < 0.1% | > 1% |
| 가용성 | 99.9% | < 99% |
| Core Web Vitals | 모두 Good | Poor 발생 시 |

---

## 6. 롤백 계획

### 6.1 자동 롤백 조건
- 배포 후 5분 내 에러율 5% 초과
- Health Check 3회 연속 실패
- Critical 에러 10건 이상 발생

### 6.2 수동 롤백 절차

```bash
# Vercel CLI 롤백
vercel rollback [deployment-url]

# 또는 대시보드에서
# 1. Vercel Dashboard 접속
# 2. Deployments 탭
# 3. 이전 배포 선택
# 4. "Promote to Production" 클릭
```

### 6.3 데이터베이스 롤백
```sql
-- 마이그레이션 롤백
-- 최근 마이그레이션 되돌리기 (예시)
-- 실제로는 마이그레이션 도구 사용

-- 데이터 백업 복원 (최후의 수단)
-- pg_restore -d database backup.dump
```

---

## 7. 배포 체크리스트

### 배포 전
- [ ] 모든 테스트 통과
- [ ] 코드 리뷰 완료
- [ ] 환경 변수 확인
- [ ] 데이터베이스 마이그레이션 준비
- [ ] 롤백 계획 확인

### 배포 중
- [ ] 배포 상태 모니터링
- [ ] 에러 로그 확인
- [ ] Health Check 확인

### 배포 후
- [ ] Smoke Test 수행
- [ ] 핵심 기능 확인
- [ ] 메트릭 정상 확인
- [ ] 팀 공지

---

## 8. 비상 연락망

| 역할 | 담당 | 연락처 |
|------|------|--------|
| 1차 대응 | 개발팀 | Slack #dev-alerts |
| 2차 대응 | DevOps | Slack #ops |
| 의사결정 | PM | 직접 연락 |
```

## 출력 위치

`docs/Deploy-Strategy.md`
</file>

<file path=".claude/skills/erd/SKILL.md">
---
name: erd
description: ERD(엔티티 관계 다이어그램)를 작성합니다. 데이터베이스 구조 설계 시 사용하세요.
---

# ERD 작성 스킬

이 스킬은 ERD(Entity Relationship Diagram)를 텍스트 기반으로 작성합니다.

## 실행 지침

1. PRD와 API 명세를 참조하여 필요한 엔티티 파악
2. 엔티티 간 관계 정의
3. 아래 템플릿에 따라 ERD 작성
4. `docs/ERD.md`에 저장

## ERD 템플릿

```markdown
# ERD (Entity Relationship Diagram)

## 1. 엔티티 목록

### 1.1 User (사용자)
| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | UUID | PK | 고유 식별자 |
| email | VARCHAR(255) | UNIQUE, NOT NULL | 이메일 |
| password_hash | VARCHAR(255) | NOT NULL | 암호화된 비밀번호 |
| name | VARCHAR(100) | NOT NULL | 이름 |
| profile_image | VARCHAR(500) | NULL | 프로필 이미지 URL |
| role | ENUM | NOT NULL, DEFAULT 'user' | 역할 (user, admin) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | 수정일시 |
| deleted_at | TIMESTAMP | NULL | 삭제일시 (소프트 삭제) |

**인덱스**
- PRIMARY KEY (id)
- UNIQUE INDEX (email)
- INDEX (role)
- INDEX (created_at)

### 1.2 Post (게시글)
| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | UUID | PK | 고유 식별자 |
| user_id | UUID | FK, NOT NULL | 작성자 ID |
| title | VARCHAR(200) | NOT NULL | 제목 |
| content | TEXT | NOT NULL | 내용 |
| status | ENUM | NOT NULL, DEFAULT 'draft' | 상태 |
| view_count | INT | NOT NULL, DEFAULT 0 | 조회수 |
| created_at | TIMESTAMP | NOT NULL | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | 수정일시 |

**인덱스**
- PRIMARY KEY (id)
- FOREIGN KEY (user_id) REFERENCES User(id)
- INDEX (status)
- INDEX (created_at)
- FULLTEXT INDEX (title, content)

### 1.3 Comment (댓글)
| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| id | UUID | PK | 고유 식별자 |
| post_id | UUID | FK, NOT NULL | 게시글 ID |
| user_id | UUID | FK, NOT NULL | 작성자 ID |
| parent_id | UUID | FK, NULL | 부모 댓글 ID (대댓글) |
| content | TEXT | NOT NULL | 내용 |
| created_at | TIMESTAMP | NOT NULL | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | 수정일시 |

## 2. 관계 다이어그램 (텍스트 기반)

```
┌─────────────┐       ┌─────────────┐       ┌─────────────┐
│    User     │       │    Post     │       │   Comment   │
├─────────────┤       ├─────────────┤       ├─────────────┤
│ id (PK)     │──┐    │ id (PK)     │──┐    │ id (PK)     │
│ email       │  │    │ user_id(FK) │  │    │ post_id(FK) │
│ password    │  └───<│ title       │  └───<│ user_id(FK) │
│ name        │       │ content     │       │ parent_id   │
│ role        │       │ status      │       │ content     │
│ created_at  │       │ created_at  │       │ created_at  │
└─────────────┘       └─────────────┘       └─────────────┘

관계:
- User (1) ──< Post (N): 한 사용자가 여러 게시글 작성
- User (1) ──< Comment (N): 한 사용자가 여러 댓글 작성
- Post (1) ──< Comment (N): 한 게시글에 여러 댓글
- Comment (1) ──< Comment (N): 대댓글 (자기 참조)
```

## 3. 관계 상세

| 관계 | 카디널리티 | 설명 |
|------|-----------|------|
| User - Post | 1:N | 사용자는 여러 게시글 작성 가능 |
| User - Comment | 1:N | 사용자는 여러 댓글 작성 가능 |
| Post - Comment | 1:N | 게시글에 여러 댓글 가능 |
| Comment - Comment | 1:N | 댓글에 대댓글 가능 (자기 참조) |

## 4. ENUM 정의

### 4.1 UserRole
- `user`: 일반 사용자
- `admin`: 관리자

### 4.2 PostStatus
- `draft`: 임시 저장
- `published`: 게시됨
- `archived`: 보관됨

## 5. 제약 조건 및 비즈니스 규칙

1. **사용자 삭제 시**: 소프트 삭제 (deleted_at 설정)
2. **게시글 삭제 시**: 연관 댓글도 함께 삭제 (CASCADE)
3. **이메일**: 고유해야 함
4. **비밀번호**: bcrypt로 해시 저장
```

## 카디널리티 표기법

```
1:1 관계: ──────
1:N 관계: ────<
N:M 관계: >───<
```

## 작성 시 고려사항

1. **정규화**: 최소 3NF까지 정규화
2. **인덱스**: 자주 조회되는 컬럼에 인덱스
3. **외래 키**: 참조 무결성 보장
4. **소프트 삭제**: deleted_at 컬럼 활용
5. **타임스탬프**: created_at, updated_at 필수

## 출력 위치

`docs/ERD.md`
</file>

<file path=".claude/skills/ia-db/SKILL.md">
---
name: ia-db
description: IA 점검 보고서 및 DB 스키마를 설계합니다. 정보 구조와 데이터베이스 설계 시 사용하세요.
---

# IA & DB 스키마 설계 스킬

이 스킬은 정보 구조(IA) 점검 보고서와 DB 테이블 플로우, 스키마를 설계합니다.

## 실행 지침

1. PRD, UX/UI, ERD 문서를 참조
2. 정보 구조(IA) 분석 및 점검
3. DB 스키마 설계
4. `docs/IA-DB-Design.md`에 저장

## IA & DB 설계 템플릿

```markdown
# IA & DB 설계 문서

## Part 1: 정보 구조(IA) 점검 보고서

### 1. 사이트맵

```
홈 (/)
├── 인증
│   ├── 로그인 (/login)
│   ├── 회원가입 (/register)
│   └── 비밀번호 찾기 (/forgot-password)
├── 대시보드 (/dashboard)
│   ├── 개요 (/dashboard)
│   ├── 분석 (/dashboard/analytics)
│   └── 설정 (/dashboard/settings)
├── 리소스 (/resources)
│   ├── 목록 (/resources)
│   ├── 상세 (/resources/:id)
│   ├── 생성 (/resources/new)
│   └── 수정 (/resources/:id/edit)
├── 프로필 (/profile)
│   ├── 내 정보 (/profile)
│   └── 설정 (/profile/settings)
└── 관리자 (/admin) [권한 필요]
    ├── 사용자 관리 (/admin/users)
    └── 시스템 설정 (/admin/settings)
```

### 2. 네비게이션 구조

#### 2.1 GNB (Global Navigation Bar)
| 메뉴 | 링크 | 권한 | 비고 |
|------|------|------|------|
| 홈 | / | 모두 | |
| 대시보드 | /dashboard | 로그인 | |
| 리소스 | /resources | 로그인 | |
| 관리자 | /admin | admin | 관리자만 표시 |

#### 2.2 사용자 메뉴 (로그인 시)
| 메뉴 | 링크 | 설명 |
|------|------|------|
| 프로필 | /profile | 내 정보 |
| 설정 | /profile/settings | 계정 설정 |
| 로그아웃 | - | 로그아웃 액션 |

### 3. 페이지 계층 분석

| Depth | 페이지 수 | 비고 |
|-------|----------|------|
| 1 (루트) | 3 | 홈, 로그인, 회원가입 |
| 2 | 8 | 주요 기능 페이지 |
| 3 | 5 | 상세/하위 페이지 |
| **총계** | **16** | |

### 4. IA 점검 체크리스트

| 항목 | 상태 | 비고 |
|------|------|------|
| 3클릭 규칙 준수 | ✅ | 최대 3depth |
| 일관된 네이밍 | ✅ | |
| 브레드크럼 제공 | ✅ | 2depth 이상 |
| 검색 기능 | ✅ | 헤더에 위치 |
| 404 페이지 | ✅ | 커스텀 404 |
| 접근성 고려 | ✅ | ARIA 적용 |

---

## Part 2: DB 테이블 플로우

### 1. 데이터 흐름도

```
[사용자 등록 플로우]
Client → POST /auth/register → Validate → Hash Password → INSERT users → Return JWT

[로그인 플로우]
Client → POST /auth/login → Find User → Verify Password → Generate JWT → Return Token

[리소스 CRUD 플로우]
Create: Client → POST /resources → Validate → INSERT resources → Return Resource
Read:   Client → GET /resources/:id → SELECT resources → Return Resource
Update: Client → PUT /resources/:id → Validate → UPDATE resources → Return Resource
Delete: Client → DELETE /resources/:id → UPDATE deleted_at → Return Success
```

### 2. 트랜잭션 흐름

```
[게시글 작성 + 알림]
BEGIN TRANSACTION
  1. INSERT INTO posts (...)
  2. INSERT INTO notifications (...)
  3. UPDATE users SET post_count = post_count + 1
COMMIT
```

---

## Part 3: DB 스키마 설계

### 1. 스키마 생성 SQL

```sql
-- 데이터베이스 생성
CREATE DATABASE app_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE app_db;

-- Users 테이블
CREATE TABLE users (
  id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(100) NOT NULL,
  profile_image VARCHAR(500),
  role ENUM('user', 'admin') NOT NULL DEFAULT 'user',
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL,

  INDEX idx_email (email),
  INDEX idx_role (role),
  INDEX idx_created_at (created_at)
);

-- Posts 테이블
CREATE TABLE posts (
  id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  user_id CHAR(36) NOT NULL,
  title VARCHAR(200) NOT NULL,
  content TEXT NOT NULL,
  status ENUM('draft', 'published', 'archived') NOT NULL DEFAULT 'draft',
  view_count INT NOT NULL DEFAULT 0,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_user_id (user_id),
  INDEX idx_status (status),
  INDEX idx_created_at (created_at),
  FULLTEXT INDEX ft_title_content (title, content)
);

-- Comments 테이블
CREATE TABLE comments (
  id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  post_id CHAR(36) NOT NULL,
  user_id CHAR(36) NOT NULL,
  parent_id CHAR(36) NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  FOREIGN KEY (post_id) REFERENCES posts(id) ON DELETE CASCADE,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (parent_id) REFERENCES comments(id) ON DELETE CASCADE,
  INDEX idx_post_id (post_id),
  INDEX idx_user_id (user_id)
);

-- Sessions 테이블 (토큰 관리)
CREATE TABLE sessions (
  id CHAR(36) PRIMARY KEY DEFAULT (UUID()),
  user_id CHAR(36) NOT NULL,
  refresh_token VARCHAR(500) NOT NULL,
  user_agent VARCHAR(500),
  ip_address VARCHAR(45),
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  INDEX idx_user_id (user_id),
  INDEX idx_refresh_token (refresh_token),
  INDEX idx_expires_at (expires_at)
);
```

### 2. 마이그레이션 전략

```
migrations/
├── 001_create_users_table.sql
├── 002_create_posts_table.sql
├── 003_create_comments_table.sql
├── 004_create_sessions_table.sql
└── 005_add_indexes.sql
```

### 3. 시드 데이터

```sql
-- 관리자 계정 시드
INSERT INTO users (id, email, password_hash, name, role)
VALUES (
  UUID(),
  'admin@example.com',
  '$2b$10$...', -- bcrypt hash of 'admin123'
  '관리자',
  'admin'
);
```

---

## Part 4: 점검 요약

### 체크리스트

| 항목 | 상태 | 비고 |
|------|------|------|
| IA 사이트맵 완성 | ✅ | |
| 네비게이션 구조 정의 | ✅ | |
| 테이블 정의 완료 | ✅ | |
| 관계 설정 완료 | ✅ | |
| 인덱스 설계 완료 | ✅ | |
| 마이그레이션 준비 | ✅ | |
```

## 출력 위치

`docs/IA-DB-Design.md`
</file>

<file path=".claude/skills/test-plan/SKILL.md">
---
name: test-plan
description: 테스트 계획서를 작성합니다. 유닛/통합/E2E 테스트 전략과 검증 시나리오를 정의할 때 사용하세요.
---

# 테스트 계획서 작성 스킬

이 스킬은 포괄적인 테스트 계획서를 작성합니다. AI/시스템이 자체적으로 테스트를 수행할 수 있도록 상세 계획을 수립합니다.

## 실행 지침

1. PRD, TRD, API 명세를 참조하여 테스트 범위 파악
2. 테스트 전략 및 시나리오 정의
3. 아래 템플릿에 따라 테스트 계획서 작성
4. `docs/Test-Plan.md`에 저장

## 테스트 계획서 템플릿

```markdown
# 테스트 계획서

## 1. 개요

### 1.1 목적
- 소프트웨어 품질 보증
- 요구사항 충족 검증
- 결함 조기 발견

### 1.2 범위
- 테스트 대상: [기능 목록]
- 제외 항목: [제외 사유와 함께]

### 1.3 테스트 환경
| 환경 | 용도 | URL |
|------|------|-----|
| Development | 개발 테스트 | localhost:3000 |
| Staging | 통합 테스트 | staging.example.com |
| Production | 최종 검증 | example.com |

---

## 2. 테스트 전략

### 2.1 테스트 피라미드

```
        /\
       /  \     E2E (10%)
      /----\
     /      \   Integration (20%)
    /--------\
   /          \ Unit (70%)
  --------------
```

### 2.2 테스트 유형별 전략

| 유형 | 도구 | 커버리지 목표 | 담당 |
|------|------|-------------|------|
| Unit Test | Jest | 80% | TDD Agent |
| Integration Test | Jest + Supertest | 60% | TDD Agent |
| Component Test | React Testing Library | 70% | TDD Agent |
| E2E Test | Playwright | 핵심 플로우 | TDD Agent |
| API Test | Jest + Supertest | 90% | TDD Agent |

---

## 3. 유닛 테스트 계획

### 3.1 대상
- 유틸리티 함수
- 커스텀 훅
- 서비스 레이어
- 상태 관리 로직

### 3.2 테스트 케이스 예시

#### formatDate 함수
| 케이스 | 입력 | 예상 출력 | 우선순위 |
|--------|------|----------|----------|
| 정상 케이스 | '2024-01-15' | '2024년 1월 15일' | High |
| null 입력 | null | '' | High |
| 잘못된 형식 | 'invalid' | '' | Medium |
| 타임존 처리 | ISO 문자열 | 로컬 시간 | Medium |

---

## 4. 통합 테스트 계획

### 4.1 API 엔드포인트 테스트

#### POST /auth/register
| 케이스 | 요청 | 예상 응답 | 상태 코드 |
|--------|------|----------|----------|
| 성공 | 유효한 데이터 | user + token | 201 |
| 이메일 중복 | 기존 이메일 | 에러 메시지 | 400 |
| 잘못된 이메일 형식 | invalid-email | 에러 메시지 | 400 |
| 비밀번호 짧음 | 7자 미만 | 에러 메시지 | 400 |
| 필수 필드 누락 | name 없음 | 에러 메시지 | 400 |

#### GET /resources
| 케이스 | 요청 | 예상 응답 | 상태 코드 |
|--------|------|----------|----------|
| 기본 조회 | 파라미터 없음 | 20개 항목 | 200 |
| 페이지네이션 | page=2 | 두 번째 페이지 | 200 |
| 정렬 | sort=title | 제목순 정렬 | 200 |
| 인증 없음 | 토큰 없음 | 에러 | 401 |

---

## 5. 컴포넌트 테스트 계획

### 5.1 Button 컴포넌트
| 케이스 | 검증 항목 | 우선순위 |
|--------|----------|----------|
| 렌더링 | 텍스트 표시 | High |
| 클릭 이벤트 | onClick 호출 | High |
| disabled 상태 | 클릭 불가 | High |
| 로딩 상태 | 스피너 표시 | Medium |
| 스타일 variant | primary/secondary | Low |

### 5.2 Form 컴포넌트
| 케이스 | 검증 항목 | 우선순위 |
|--------|----------|----------|
| 입력 | 값 변경 반영 | High |
| 유효성 검증 | 에러 메시지 표시 | High |
| 제출 | onSubmit 호출 | High |
| 초기화 | 폼 리셋 | Medium |

---

## 6. E2E 테스트 계획

### 6.1 핵심 사용자 플로우

#### 회원가입 → 로그인 플로우
```
1. /register 페이지 접속
2. 폼 입력 (이메일, 비밀번호, 이름)
3. 제출 버튼 클릭
4. /dashboard로 리다이렉트 확인
5. 로그아웃
6. /login 페이지 접속
7. 로그인 정보 입력
8. /dashboard 접속 확인
```

#### 리소스 CRUD 플로우
```
1. 로그인 상태로 /resources 접속
2. 새 리소스 생성
3. 목록에서 확인
4. 상세 페이지 접속
5. 수정
6. 삭제
7. 목록에서 사라짐 확인
```

---

## 7. 에러 케이스 & 엣지 케이스

### 7.1 에러 케이스
| 시나리오 | 예상 동작 | 테스트 방법 |
|---------|----------|------------|
| 네트워크 오류 | 재시도 또는 에러 표시 | MSW로 에러 응답 |
| 서버 500 에러 | 에러 페이지 표시 | Mock 서버 에러 |
| 세션 만료 | 로그인 페이지로 이동 | 만료된 토큰 사용 |
| 권한 없음 | 403 페이지 표시 | 다른 사용자 리소스 접근 |

### 7.2 엣지 케이스
| 시나리오 | 예상 동작 | 테스트 방법 |
|---------|----------|------------|
| 빈 목록 | Empty state 표시 | 데이터 없는 상태로 렌더링 |
| 매우 긴 텍스트 | 말줄임 처리 | 긴 문자열 입력 |
| 특수 문자 입력 | 이스케이프 처리 | XSS 페이로드 입력 |
| 동시 요청 | 중복 방지 | 빠른 연속 클릭 |
| 대용량 데이터 | 페이지네이션/가상화 | 1000개 항목 |

---

## 8. 테스트 실행 계획

### 8.1 자동화 실행
```bash
# 유닛 테스트
npm test

# 커버리지 리포트
npm test -- --coverage

# E2E 테스트
npm run test:e2e

# 전체 테스트
npm run test:all
```

### 8.2 CI/CD 연동
```yaml
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm ci
      - run: npm test -- --coverage
      - run: npm run test:e2e
```

---

## 9. 품질 기준

### 9.1 테스트 통과 기준
- [ ] 모든 유닛 테스트 통과
- [ ] 모든 통합 테스트 통과
- [ ] 핵심 E2E 시나리오 통과
- [ ] 커버리지 70% 이상

### 9.2 릴리스 기준
- [ ] 블로커/크리티컬 버그 0건
- [ ] 메이저 버그 해결률 100%
- [ ] 성능 기준 충족

---

## 10. 테스트 결과 보고서 템플릿

```markdown
## 테스트 결과 요약

- 실행일: YYYY-MM-DD
- 총 테스트: XXX개
- 성공: XXX개
- 실패: XXX개
- 스킵: XXX개
- 커버리지: XX%

### 실패 테스트 상세
| 테스트명 | 실패 사유 | 담당자 |
|---------|----------|-------|
| ... | ... | ... |
```
```

## 출력 위치

`docs/Test-Plan.md`
</file>

<file path=".gitignore">
# Dependencies
node_modules/
.pnp/
.pnp.js

# Expo
.expo/
dist/
web-build/
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Environment variables
.env
.env.local
.env.*.local

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Build outputs
*.tsbuildinfo
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Test coverage
coverage/

# Temporary files
*.tmp
*.temp
*.backup

# TypeScript
*.tsbuildinfo
</file>

<file path="app/.gitignore">
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/
expo-env.d.ts

# Native
.kotlin/
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

app-example

# generated native folders
/ios
/android
</file>

<file path="app/app.json">
{
  "expo": {
    "name": "myapp",
    "slug": "myapp",
    
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "myapp",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "backgroundColor": "#E6F4FE",
        "foregroundImage": "./assets/images/android-icon-foreground.png",
        "backgroundImage": "./assets/images/android-icon-background.png",
        "monochromeImage": "./assets/images/android-icon-monochrome.png"
      },
      "edgeToEdgeEnabled": true,
      "predictiveBackGestureEnabled": false
    },
    "web": {
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#ffffff",
          "dark": {
            "backgroundColor": "#000000"
          }
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true,
      "reactCompiler": true
    }
  }
}
</file>

<file path="app/App.tsx">
/**
 * 재고 할인 중개 플랫폼 - 메인 앱
 * Zustand를 사용한 상태 관리
 */
import React, { useEffect } from 'react';
import { ActivityIndicator, View } from 'react-native';
import { supabase } from './src/lib/supabase';

// Zustand 스토어
import {
  useAuthStore,
  useNavigationStore,
  useSelectionStore,
} from './src/stores';

// 로그인/회원가입 화면
import ConsumerSignupScreen from './src/screens/ConsumerSignupScreen';
import LoginScreen from './src/screens/LoginScreen';
import SignupTypeScreen from './src/screens/SignupTypeScreen';
import StoreSignupScreen from './src/screens/StoreSignupScreen';

// 소비자 화면
import MyPageScreen from './src/screens/MyPageScreen';
import MyReservations from './src/screens/MyReservations';
import ReservationScreen from './src/screens/ReservationScreen';
import ReviewScreen from './src/screens/ReviewScreen';
import StoreDetail from './src/screens/StoreDetail';
import StoreListHome from './src/screens/StoreListHome';

// 업주 화면
import StoreCashHistory from './src/screens/StoreCashHistory';
import StoreCashManagement from './src/screens/StoreCashManagement';
import StoreDashboard from './src/screens/StoreDashboard';
import StoreInfoManagement from './src/screens/StoreInfoManagement';
import StoreProductManagement from './src/screens/StoreProductManagement';
import StoreRegularCustomers from './src/screens/StoreRegularCustomers';
import StoreReservationManagement from './src/screens/StoreReservationManagement';
import StoreReviewManagement from './src/screens/StoreReviewManagement';

export default function App() {
  // 인증 스토어
  const {
    session,
    isStoreOwner,
    loading,
    checkSession,
    checkUserType,
    setSession,
    setIsStoreOwner,
    reset: resetAuth,
  } = useAuthStore();

  // 네비게이션 스토어
  const {
    authScreen,
    consumerScreen,
    storeScreen,
    showStoreMode,
    setAuthScreen,
    setConsumerScreen,
    setStoreScreen,
    setShowStoreMode,
    goToLogin,
    reset: resetNav,
  } = useNavigationStore();

  // 선택 스토어
  const {
    selectedStoreId,
    selectedProduct,
    selectedReservation,
    selectStore,
    selectProduct,
    selectReservation,
    clearReservation,
  } = useSelectionStore();

  // 앱 시작 시 세션 확인
  useEffect(() => {
    checkSession();

    // 인증 상태 변화 구독
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session);
      if (session) {
        checkUserType(session.user.id);
      } else {
        setIsStoreOwner(false);
        setShowStoreMode(false);
        goToLogin();
      }
    });

    return () => subscription.unsubscribe();
  }, [checkSession, checkUserType, setSession, setIsStoreOwner, setShowStoreMode, goToLogin]);

  // 로딩 화면
  if (loading) {
    return (
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  // ==================== 로그인하지 않은 경우 ====================
  if (!session) {
    return (
      <View style={{ flex: 1 }}>
        {authScreen === 'login' && (
          <LoginScreen onSignup={() => setAuthScreen('signupType')} />
        )}

        {authScreen === 'signupType' && (
          <SignupTypeScreen
            onSelectConsumer={() => setAuthScreen('consumerSignup')}
            onSelectStore={() => setAuthScreen('storeSignup')}
            onBack={() => setAuthScreen('login')}
          />
        )}

        {authScreen === 'consumerSignup' && (
          <ConsumerSignupScreen
            onBack={() => setAuthScreen('signupType')}
            onSuccess={() => setAuthScreen('login')}
          />
        )}

        {authScreen === 'storeSignup' && (
          <StoreSignupScreen
            onBack={() => setAuthScreen('signupType')}
            onSignupComplete={() => setAuthScreen('login')}
          />
        )}
      </View>
    );
  }

  // ==================== 업주 모드 ====================
  if (showStoreMode && isStoreOwner) {
    return (
      <View style={{ flex: 1 }}>
        {storeScreen === 'dashboard' && (
          <StoreDashboard
            onManageProducts={() => setStoreScreen('products')}
            onManageCash={() => setStoreScreen('cash')}
            onManageReservations={() => setStoreScreen('reservations')}
            onManageInfo={() => setStoreScreen('info')}
            onManageReviews={() => setStoreScreen('reviews')}
            onManageRegulars={() => setStoreScreen('regulars')}
            onLogout={() => {
              setShowStoreMode(false);
              setConsumerScreen('mypage');
            }}
          />
        )}

        {storeScreen === 'info' && (
          <StoreInfoManagement
            onBack={() => setStoreScreen('dashboard')}
            onManageProducts={() => setStoreScreen('products')}
          />
        )}

        {storeScreen === 'products' && (
          <StoreProductManagement onBack={() => setStoreScreen('dashboard')} />
        )}

        {storeScreen === 'cash' && (
          <StoreCashManagement
            onBack={() => setStoreScreen('dashboard')}
            onViewHistory={() => setStoreScreen('cashHistory')}
          />
        )}

        {storeScreen === 'cashHistory' && (
          <StoreCashHistory onBack={() => setStoreScreen('dashboard')} />
        )}

        {storeScreen === 'reservations' && (
          <StoreReservationManagement onBack={() => setStoreScreen('dashboard')} />
        )}

        {storeScreen === 'reviews' && (
          <StoreReviewManagement onBack={() => setStoreScreen('dashboard')} />
        )}

        {storeScreen === 'regulars' && (
          <StoreRegularCustomers onBack={() => setStoreScreen('dashboard')} />
        )}
      </View>
    );
  }

  // ==================== 소비자 모드 ====================
  return (
    <View style={{ flex: 1 }}>
      {consumerScreen === 'storelist' && (
        <StoreListHome
          onSelectStore={(id) => {
            selectStore(id);
            setConsumerScreen('detail');
          }}
          onViewReservations={() => setConsumerScreen('myreservations')}
          onViewMyPage={() => setConsumerScreen('mypage')}
        />
      )}

      {consumerScreen === 'detail' && (
        <StoreDetail
          storeId={selectedStoreId}
          onReserve={(product) => {
            selectProduct(product);
            setConsumerScreen('reserve');
          }}
          onBack={() => setConsumerScreen('storelist')}
        />
      )}

      {consumerScreen === 'reserve' && selectedProduct && (
        <ReservationScreen
          product={selectedProduct}
          onBack={() => setConsumerScreen('detail')}
          onComplete={() => setConsumerScreen('myreservations')}
        />
      )}

      {consumerScreen === 'myreservations' && (
        <MyReservations
          onBack={() => setConsumerScreen('storelist')}
          onWriteReview={(reservation) => {
            selectReservation(reservation);
            setConsumerScreen('review');
          }}
        />
      )}

      {consumerScreen === 'review' && selectedReservation && (
        <ReviewScreen
          reservation={selectedReservation}
          onBack={() => {
            clearReservation();
            setConsumerScreen('myreservations');
          }}
        />
      )}

      {consumerScreen === 'mypage' && (
        <MyPageScreen
          onViewReservations={() => setConsumerScreen('myreservations')}
          onViewStoreManagement={() => {
            if (isStoreOwner) {
              setShowStoreMode(true);
              setStoreScreen('dashboard');
            }
          }}
          onBack={() => setConsumerScreen('storelist')}
        />
      )}
    </View>
  );
}
</file>

<file path="app/components/external-link.tsx">
import { Href, Link } from 'expo-router';
import { openBrowserAsync, WebBrowserPresentationStyle } from 'expo-web-browser';
import { type ComponentProps } from 'react';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (process.env.EXPO_OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href, {
            presentationStyle: WebBrowserPresentationStyle.AUTOMATIC,
          });
        }
      }}
    />
  );
}
</file>

<file path="app/components/haptic-tab.tsx">
import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}
</file>

<file path="app/components/hello-wave.tsx">
import Animated from 'react-native-reanimated';

export function HelloWave() {
  return (
    <Animated.Text
      style={{
        fontSize: 28,
        lineHeight: 32,
        marginTop: -6,
        animationName: {
          '50%': { transform: [{ rotate: '25deg' }] },
        },
        animationIterationCount: 4,
        animationDuration: '300ms',
      }}>
      👋
    </Animated.Text>
  );
}
</file>

<file path="app/components/parallax-scroll-view.tsx">
import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/themed-view';
import { useColorScheme } from '@/hooks/use-color-scheme';
import { useThemeColor } from '@/hooks/use-theme-color';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const backgroundColor = useThemeColor({}, 'background');
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollOffset(scrollRef);
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <Animated.ScrollView
      ref={scrollRef}
      style={{ backgroundColor, flex: 1 }}
      scrollEventThrottle={16}>
      <Animated.View
        style={[
          styles.header,
          { backgroundColor: headerBackgroundColor[colorScheme] },
          headerAnimatedStyle,
        ]}>
        {headerImage}
      </Animated.View>
      <ThemedView style={styles.content}>{children}</ThemedView>
    </Animated.ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});
</file>

<file path="app/components/themed-text.tsx">
import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});
</file>

<file path="app/components/themed-view.tsx">
import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/use-theme-color';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}
</file>

<file path="app/components/ui/collapsible.tsx">
import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/themed-text';
import { ThemedView } from '@/components/themed-view';
import { IconSymbol } from '@/components/ui/icon-symbol';
import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});
</file>

<file path="app/components/ui/icon-symbol.ios.tsx">
import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}
</file>

<file path="app/components/ui/icon-symbol.tsx">
// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}
</file>

<file path="app/constants/theme.ts">
/**
 * Below are the colors that are used in the app. The colors are defined in the light and dark mode.
 * There are many other ways to style your app. For example, [Nativewind](https://www.nativewind.dev/), [Tamagui](https://tamagui.dev/), [unistyles](https://reactnativeunistyles.vercel.app), etc.
 */

import { Platform } from 'react-native';

const tintColorLight = '#0a7ea4';
const tintColorDark = '#fff';

export const Colors = {
  light: {
    text: '#11181C',
    background: '#fff',
    tint: tintColorLight,
    icon: '#687076',
    tabIconDefault: '#687076',
    tabIconSelected: tintColorLight,
  },
  dark: {
    text: '#ECEDEE',
    background: '#151718',
    tint: tintColorDark,
    icon: '#9BA1A6',
    tabIconDefault: '#9BA1A6',
    tabIconSelected: tintColorDark,
  },
};

export const Fonts = Platform.select({
  ios: {
    /** iOS `UIFontDescriptorSystemDesignDefault` */
    sans: 'system-ui',
    /** iOS `UIFontDescriptorSystemDesignSerif` */
    serif: 'ui-serif',
    /** iOS `UIFontDescriptorSystemDesignRounded` */
    rounded: 'ui-rounded',
    /** iOS `UIFontDescriptorSystemDesignMonospaced` */
    mono: 'ui-monospace',
  },
  default: {
    sans: 'normal',
    serif: 'serif',
    rounded: 'normal',
    mono: 'monospace',
  },
  web: {
    sans: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif",
    serif: "Georgia, 'Times New Roman', serif",
    rounded: "'SF Pro Rounded', 'Hiragino Maru Gothic ProN', Meiryo, 'MS PGothic', sans-serif",
    mono: "SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
  },
});
</file>

<file path="app/eslint.config.js">
// https://docs.expo.dev/guides/using-eslint/
const { defineConfig } = require('eslint/config');
const expoConfig = require('eslint-config-expo/flat');

module.exports = defineConfig([
  expoConfig,
  {
    ignores: ['dist/*'],
  },
]);
</file>

<file path="app/hooks/use-color-scheme.ts">
export { useColorScheme } from 'react-native';
</file>

<file path="app/hooks/use-color-scheme.web.ts">
import { useEffect, useState } from 'react';
import { useColorScheme as useRNColorScheme } from 'react-native';

/**
 * To support static rendering, this value needs to be re-calculated on the client side for web
 */
export function useColorScheme() {
  const [hasHydrated, setHasHydrated] = useState(false);

  useEffect(() => {
    setHasHydrated(true);
  }, []);

  const colorScheme = useRNColorScheme();

  if (hasHydrated) {
    return colorScheme;
  }

  return 'light';
}
</file>

<file path="app/hooks/use-theme-color.ts">
/**
 * Learn more about light and dark modes:
 * https://docs.expo.dev/guides/color-schemes/
 */

import { Colors } from '@/constants/theme';
import { useColorScheme } from '@/hooks/use-color-scheme';

export function useThemeColor(
  props: { light?: string; dark?: string },
  colorName: keyof typeof Colors.light & keyof typeof Colors.dark
) {
  const theme = useColorScheme() ?? 'light';
  const colorFromProps = props[theme];

  if (colorFromProps) {
    return colorFromProps;
  } else {
    return Colors[theme][colorName];
  }
}
</file>

<file path="app/index.js">
import { registerRootComponent } from 'expo';
import App from './App';

registerRootComponent(App);
</file>

<file path="app/package.json">
{
  "name": "myapp",
  "main": "index.js",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "lint": "expo lint"
  },
  "dependencies": {
    "@expo/vector-icons": "^15.0.3",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-navigation/bottom-tabs": "^7.4.0",
    "@react-navigation/elements": "^2.6.3",
    "@react-navigation/native": "^7.1.8",
    "@supabase/supabase-js": "^2.90.1",
    "base64-arraybuffer": "^1.0.2",
    "expo": "~54.0.31",
    "expo-constants": "~18.0.13",
    "expo-file-system": "^19.0.21",
    "expo-font": "~14.0.10",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-image-picker": "^17.0.10",
    "expo-linking": "~8.0.11",
    "expo-router": "~6.0.21",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-symbols": "~1.0.8",
    "expo-system-ui": "~6.0.9",
    "expo-web-browser": "~15.0.10",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-url-polyfill": "^3.0.0",
    "react-native-web": "~0.21.0",
    "react-native-worklets": "0.5.1",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@types/react": "~19.1.0",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "typescript": "~5.9.2"
  },
  "private": true
}
</file>

<file path="app/README.md">
# Welcome to your Expo app 👋

This is an [Expo](https://expo.dev) project created with [`create-expo-app`](https://www.npmjs.com/package/create-expo-app).

## Get started

1. Install dependencies

   ```bash
   npm install
   ```

2. Start the app

   ```bash
   npx expo start
   ```

In the output, you'll find options to open the app in a

- [development build](https://docs.expo.dev/develop/development-builds/introduction/)
- [Android emulator](https://docs.expo.dev/workflow/android-studio-emulator/)
- [iOS simulator](https://docs.expo.dev/workflow/ios-simulator/)
- [Expo Go](https://expo.dev/go), a limited sandbox for trying out app development with Expo

You can start developing by editing the files inside the **app** directory. This project uses [file-based routing](https://docs.expo.dev/router/introduction).

## Get a fresh project

When you're ready, run:

```bash
npm run reset-project
```

This command will move the starter code to the **app-example** directory and create a blank **app** directory where you can start developing.

## Learn more

To learn more about developing your project with Expo, look at the following resources:

- [Expo documentation](https://docs.expo.dev/): Learn fundamentals, or go into advanced topics with our [guides](https://docs.expo.dev/guides).
- [Learn Expo tutorial](https://docs.expo.dev/tutorial/introduction/): Follow a step-by-step tutorial where you'll create a project that runs on Android, iOS, and the web.

## Join the community

Join our community of developers creating universal apps.

- [Expo on GitHub](https://github.com/expo/expo): View our open source platform and contribute.
- [Discord community](https://chat.expo.dev): Chat with Expo users and ask questions.
</file>

<file path="app/scripts/reset-project.js">
#!/usr/bin/env node

/**
 * This script is used to reset the project to a blank state.
 * It deletes or moves the /app, /components, /hooks, /scripts, and /constants directories to /app-example based on user input and creates a new /app directory with an index.tsx and _layout.tsx file.
 * You can remove the `reset-project` script from package.json and safely delete this file after running it.
 */

const fs = require("fs");
const path = require("path");
const readline = require("readline");

const root = process.cwd();
const oldDirs = ["app", "components", "hooks", "constants", "scripts"];
const exampleDir = "app-example";
const newAppDir = "app";
const exampleDirPath = path.join(root, exampleDir);

const indexContent = `import { Text, View } from "react-native";

export default function Index() {
  return (
    <View
      style={{
        flex: 1,
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      <Text>Edit app/index.tsx to edit this screen.</Text>
    </View>
  );
}
`;

const layoutContent = `import { Stack } from "expo-router";

export default function RootLayout() {
  return <Stack />;
}
`;

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const moveDirectories = async (userInput) => {
  try {
    if (userInput === "y") {
      // Create the app-example directory
      await fs.promises.mkdir(exampleDirPath, { recursive: true });
      console.log(`📁 /${exampleDir} directory created.`);
    }

    // Move old directories to new app-example directory or delete them
    for (const dir of oldDirs) {
      const oldDirPath = path.join(root, dir);
      if (fs.existsSync(oldDirPath)) {
        if (userInput === "y") {
          const newDirPath = path.join(root, exampleDir, dir);
          await fs.promises.rename(oldDirPath, newDirPath);
          console.log(`➡️ /${dir} moved to /${exampleDir}/${dir}.`);
        } else {
          await fs.promises.rm(oldDirPath, { recursive: true, force: true });
          console.log(`❌ /${dir} deleted.`);
        }
      } else {
        console.log(`➡️ /${dir} does not exist, skipping.`);
      }
    }

    // Create new /app directory
    const newAppDirPath = path.join(root, newAppDir);
    await fs.promises.mkdir(newAppDirPath, { recursive: true });
    console.log("\n📁 New /app directory created.");

    // Create index.tsx
    const indexPath = path.join(newAppDirPath, "index.tsx");
    await fs.promises.writeFile(indexPath, indexContent);
    console.log("📄 app/index.tsx created.");

    // Create _layout.tsx
    const layoutPath = path.join(newAppDirPath, "_layout.tsx");
    await fs.promises.writeFile(layoutPath, layoutContent);
    console.log("📄 app/_layout.tsx created.");

    console.log("\n✅ Project reset complete. Next steps:");
    console.log(
      `1. Run \`npx expo start\` to start a development server.\n2. Edit app/index.tsx to edit the main screen.${
        userInput === "y"
          ? `\n3. Delete the /${exampleDir} directory when you're done referencing it.`
          : ""
      }`
    );
  } catch (error) {
    console.error(`❌ Error during script execution: ${error.message}`);
  }
};

rl.question(
  "Do you want to move existing files to /app-example instead of deleting them? (Y/n): ",
  (answer) => {
    const userInput = answer.trim().toLowerCase() || "y";
    if (userInput === "y" || userInput === "n") {
      moveDirectories(userInput).finally(() => rl.close());
    } else {
      console.log("❌ Invalid input. Please enter 'Y' or 'N'.");
      rl.close();
    }
  }
);
</file>

<file path="app/src/lib/supabase.ts">
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import 'react-native-url-polyfill/auto';

const supabaseUrl = process.env.EXPO_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY!;

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
</file>

<file path="app/src/screens/ConsumerSignupScreen.tsx">
import React, { useState } from 'react';
import { Alert, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface ConsumerSignupScreenProps {
  onBack: () => void;
  onSuccess: () => void;
}

export default function ConsumerSignupScreen({ onBack, onSuccess }: ConsumerSignupScreenProps) {
  const [nickname, setNickname] = useState('');
  const [phone, setPhone] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSignup = async () => {
    // 입력 검증
    if (!nickname || !phone || !email || !password || !confirmPassword) {
      Alert.alert('오류', '모든 항목을 입력해주세요.');
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert('오류', '비밀번호가 일치하지 않습니다.');
      return;
    }

    if (password.length < 6) {
      Alert.alert('오류', '비밀번호는 최소 6자 이상이어야 합니다.');
      return;
    }

    setLoading(true);

    try {
      // 1. Supabase Auth에 회원가입
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email: email.trim(),
        password: password,
      });

      if (authError) throw authError;

      if (!authData.user) {
        throw new Error('회원가입에 실패했습니다.');
      }

      // 2. consumers 테이블에 추가 정보 저장
      const { error: consumerError } = await supabase
        .from('consumers')
        .insert([
          {
            user_id: authData.user.id,
            nickname: nickname.trim(),
            phone: phone.trim(),
            total_savings: 0,
          },
        ]);

      if (consumerError) throw consumerError;

      Alert.alert(
        '회원가입 완료',
        '일반고객으로 가입되었습니다!\n로그인해주세요.',
        [{ text: '확인', onPress: onSuccess }]
      );
    } catch (error: any) {
      console.error('회원가입 오류:', error);
      Alert.alert('회원가입 실패', error.message || '회원가입 중 오류가 발생했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <ScrollView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>일반고객 회원가입</Text>
        <Text style={styles.subtitle}>할인 상품을 예약하고 절약하세요!</Text>

        <View style={styles.form}>
          <View style={styles.inputGroup}>
            <Text style={styles.label}>이름 (닉네임)</Text>
            <TextInput
              style={styles.input}
              placeholder="홍길동"
              value={nickname}
              onChangeText={setNickname}
              editable={!loading}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>전화번호</Text>
            <TextInput
              style={styles.input}
              placeholder="010-1234-5678"
              value={phone}
              onChangeText={setPhone}
              keyboardType="phone-pad"
              editable={!loading}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>이메일</Text>
            <TextInput
              style={styles.input}
              placeholder="example@email.com"
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              editable={!loading}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>비밀번호</Text>
            <TextInput
              style={styles.input}
              placeholder="최소 6자 이상"
              value={password}
              onChangeText={setPassword}
              secureTextEntry
              editable={!loading}
            />
          </View>

          <View style={styles.inputGroup}>
            <Text style={styles.label}>비밀번호 확인</Text>
            <TextInput
              style={styles.input}
              placeholder="비밀번호를 다시 입력하세요"
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              secureTextEntry
              editable={!loading}
            />
          </View>

          <TouchableOpacity
            style={[styles.signupButton, loading && styles.disabledButton]}
            onPress={handleSignup}
            disabled={loading}
          >
            <Text style={styles.signupButtonText}>
              {loading ? '가입 중...' : '회원가입'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.backButton} onPress={onBack} disabled={loading}>
            <Text style={styles.backButtonText}>뒤로 가기</Text>
          </TouchableOpacity>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  content: {
    padding: 20,
    paddingTop: 40,
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    marginBottom: 30,
  },
  form: {
    gap: 20,
  },
  inputGroup: {
    gap: 8,
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  input: {
    borderWidth: 1,
    borderColor: '#DDD',
    borderRadius: 8,
    padding: 15,
    fontSize: 16,
    backgroundColor: '#F9F9F9',
  },
  signupButton: {
    backgroundColor: '#007AFF',
    padding: 18,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 10,
  },
  disabledButton: {
    backgroundColor: '#CCC',
  },
  signupButtonText: {
    color: '#FFFFFF',
    fontSize: 18,
    fontWeight: 'bold',
  },
  backButton: {
    padding: 15,
    alignItems: 'center',
  },
  backButtonText: {
    fontSize: 16,
    color: '#007AFF',
  },
});
</file>

<file path="app/src/screens/HomeScreen.tsx">
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

interface HomeScreenProps {
  onViewStores: () => void;
  onViewReservations: () => void;
  onViewMyPage: () => void;
}

export default function HomeScreen({ onViewStores, onViewReservations, onViewMyPage }: HomeScreenProps) {
  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <Text style={styles.title}>투굿투고</Text>
        <TouchableOpacity style={styles.myPageButton} onPress={onViewMyPage}>
          <Text style={styles.myPageIcon}>👤</Text>
        </TouchableOpacity>
      </View>

      {/* 메인 컨텐츠 */}
      <View style={styles.content}>
        <View style={styles.hero}>
          <Text style={styles.heroTitle}>🌍</Text>
          <Text style={styles.heroSubtitle}>음식물 낭비를 줄이고</Text>
          <Text style={styles.heroSubtitle}>지구를 지키는 중</Text>
        </View>

        {/* 메인 버튼들 */}
        <View style={styles.buttonContainer}>
          <TouchableOpacity style={[styles.mainButton, styles.primaryButton]} onPress={onViewStores}>
            <Text style={styles.buttonIcon}>🏪</Text>
            <Text style={styles.buttonTitle}>업체 보기</Text>
            <Text style={styles.buttonSubtitle}>할인 상품 둘러보기</Text>
          </TouchableOpacity>

          <TouchableOpacity style={[styles.mainButton, styles.secondaryButton]} onPress={onViewReservations}>
            <Text style={styles.buttonIcon}>📋</Text>
            <Text style={styles.buttonTitle}>예약 내역</Text>
            <Text style={styles.buttonSubtitle}>나의 예약 확인하기</Text>
          </TouchableOpacity>
        </View>

        {/* 하단 메뉴 */}
        <View style={styles.bottomMenu}>
          <TouchableOpacity style={styles.bottomMenuItem} onPress={onViewMyPage}>
            <Text style={styles.bottomMenuIcon}>⚙️</Text>
            <Text style={styles.bottomMenuText}>내정보</Text>
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    paddingTop: 50,
    backgroundColor: '#007AFF',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#FFFFFF',
  },
  myPageButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  myPageIcon: {
    fontSize: 24,
  },
  content: {
    flex: 1,
    padding: 20,
  },
  hero: {
    alignItems: 'center',
    paddingVertical: 40,
  },
  heroTitle: {
    fontSize: 80,
    marginBottom: 20,
  },
  heroSubtitle: {
    fontSize: 18,
    color: '#666',
    marginBottom: 5,
  },
  buttonContainer: {
    gap: 15,
    marginBottom: 30,
  },
  mainButton: {
    padding: 25,
    borderRadius: 15,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  primaryButton: {
    backgroundColor: '#007AFF',
  },
  secondaryButton: {
    backgroundColor: '#34C759',
  },
  buttonIcon: {
    fontSize: 48,
    marginBottom: 10,
  },
  buttonTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FFFFFF',
    marginBottom: 5,
  },
  buttonSubtitle: {
    fontSize: 14,
    color: 'rgba(255, 255, 255, 0.9)',
  },
  bottomMenu: {
    flexDirection: 'row',
    justifyContent: 'center',
    paddingTop: 20,
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
  },
  bottomMenuItem: {
    alignItems: 'center',
    padding: 15,
  },
  bottomMenuIcon: {
    fontSize: 28,
    marginBottom: 5,
  },
  bottomMenuText: {
    fontSize: 14,
    color: '#666',
  },
});
</file>

<file path="app/src/screens/LoginScreen.tsx">
import React, { useState } from 'react';
import { Alert, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

export default function LoginScreen({ onSignup }: { onSignup: () => void }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = async () => {
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) Alert.alert('오류', error.message);
    else Alert.alert('성공', '로그인 완료!');
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>재고 할인 플랫폼</Text>
      <TextInput style={styles.input} placeholder="이메일" value={email} onChangeText={setEmail} autoCapitalize="none" />
      <TextInput style={styles.input} placeholder="비밀번호" value={password} onChangeText={setPassword} secureTextEntry />
      <TouchableOpacity style={styles.button} onPress={handleLogin}>
        <Text style={styles.buttonText}>로그인</Text>
      </TouchableOpacity>
      <TouchableOpacity onPress={onSignup}>
        <Text style={styles.link}>계정이 없으신가요? 회원가입</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, justifyContent: 'center', backgroundColor: '#fff' },
  title: { fontSize: 32, fontWeight: 'bold', marginBottom: 30, textAlign: 'center' },
  input: { backgroundColor: '#f5f5f5', padding: 15, borderRadius: 10, marginBottom: 15 },
  button: { backgroundColor: '#007AFF', padding: 18, borderRadius: 10, alignItems: 'center' },
  buttonText: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  link: { color: '#007AFF', textAlign: 'center', marginTop: 20 },
});
</file>

<file path="app/src/screens/MyPageScreen.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { ScrollView, Share, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface MyPageScreenProps {
  onViewReservations: () => void;
  onViewStoreManagement: () => void;
  onBack: () => void;
}

export default function MyPageScreen({ onViewReservations, onViewStoreManagement, onBack }: MyPageScreenProps) {
  const [userInfo, setUserInfo] = useState<any>(null);
  const [isStoreOwner, setIsStoreOwner] = useState(false);
  const [stats, setStats] = useState({ savings: 0, carbonReduced: 0, mealsRescued: 0 });
  const [recentOrders, setRecentOrders] = useState<any[]>([]);
  const [loading, setLoading] = useState(true);

  const loadUserData = useCallback(async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: consumer } = await supabase
        .from('consumers')
        .select('id, nickname, phone, total_savings')
        .eq('user_id', user.id)
        .single();

      const { data: store } = await supabase
        .from('stores')
        .select('name, owner_name')
        .eq('user_id', user.id)
        .single();

      if (consumer) {
        setUserInfo({
          nickname: consumer.nickname,
          email: user.email,
          total_savings: consumer.total_savings || 0,
        });

        // 통계 계산
        const { data: completedReservations } = await supabase
          .from('reservations')
          .select('total_amount')
          .eq('consumer_id', consumer.id)
          .eq('status', 'completed');

        const totalSavings = consumer.total_savings || 0;
        const mealsRescued = completedReservations?.length || 0;
        const carbonReduced = mealsRescued * 0.5; // 1건당 0.5kg 가정

        setStats({
          savings: totalSavings,
          carbonReduced: parseFloat(carbonReduced.toFixed(1)),
          mealsRescued,
        });

        // 최근 구매 내역 (최대 2건)
        const { data: recent } = await supabase
          .from('reservations')
          .select('*, stores(name), products(name)')
          .eq('consumer_id', consumer.id)
          .in('status', ['confirmed', 'completed'])
          .order('created_at', { ascending: false })
          .limit(2);

        setRecentOrders(recent || []);
      }

      if (store) {
        setIsStoreOwner(true);
      }
    } catch (error) {
      console.error('데이터 로드 오류:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    loadUserData();
  }, [loadUserData]);

  const handleShare = async () => {
    try {
      await Share.share({
        message: 'Save It 앱으로 음식물 낭비를 줄이고 할인 혜택을 받아보세요! 🌍',
      });
    } catch (error) {
      console.error('공유 오류:', error);
    }
  };

  const getTimeAgo = (dateString: string) => {
    const now = new Date();
    const created = new Date(dateString);
    const diffDays = Math.floor((now.getTime() - created.getTime()) / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return '오늘';
    if (diffDays === 1) return '1일전';
    return `${diffDays}일전`;
  };

  if (loading) {
    return (
      <View style={styles.container}>
        <View style={styles.header}>
          <Text style={styles.logo}>💚 Save It</Text>
        </View>
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <Text>로딩 중...</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <Text style={styles.logo}>💚 Save It</Text>
      </View>

      <ScrollView style={styles.scrollView}>
        {/* 프로필 섹션 */}
        <View style={styles.profileSection}>
          <View style={styles.profileIcon}>
            <Text style={styles.profileEmoji}>👤</Text>
          </View>
          <View style={{ flex: 1 }}>
            <View style={styles.profileHeader}>
              <Text style={styles.profileName}>{userInfo?.nickname || '사용자'}님 ✓</Text>
              {isStoreOwner && (
                <TouchableOpacity onPress={onViewStoreManagement} style={styles.storeLink}>
                  <Text style={styles.storeLinkText}>사장님 페이지 ›</Text>
                </TouchableOpacity>
              )}
            </View>
            <Text style={styles.profileSubtitle}>지구를 지키는 중</Text>
          </View>
        </View>

        {/* 통계 박스 */}
        <View style={styles.statsBox}>
          <Text style={styles.statsLabel}>지금까지 아낀금액</Text>
          <Text style={styles.statsAmount}>{stats.savings.toLocaleString()} 원</Text>
          <View style={styles.statsRow}>
            <View style={{ flex: 1 }}>
              <Text style={styles.statsSubLabel}>절감 탄소</Text>
              <Text style={styles.statsSubValue}>{stats.carbonReduced}kg</Text>
            </View>
            <View style={{ flex: 1 }}>
              <Text style={styles.statsSubLabel}>구조한 음식</Text>
              <Text style={styles.statsSubValue}>{stats.mealsRescued}건</Text>
            </View>
          </View>
        </View>

        {/* 최근 구매 내역 */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>최근 구매 내역</Text>
            <TouchableOpacity onPress={onViewReservations}>
              <Text style={styles.sectionLink}>전체보기</Text>
            </TouchableOpacity>
          </View>

          {recentOrders.length === 0 ? (
            <View style={styles.emptyOrders}>
              <Text style={styles.emptyText}>최근 구매 내역이 없습니다</Text>
            </View>
          ) : (
            recentOrders.map((order) => (
              <TouchableOpacity key={order.id} style={styles.orderItem}>
                <View style={styles.orderImage}>
                  <Text style={styles.orderImageText}>🏪</Text>
                </View>
                <View style={{ flex: 1 }}>
                  <View style={styles.orderHeader}>
                    {order.status === 'completed' && (
                      <Text style={styles.orderBadge}>수량 완료</Text>
                    )}
                    <Text style={styles.orderTime}>{getTimeAgo(order.created_at)}</Text>
                  </View>
                  <Text style={styles.orderStoreName}>{order.stores?.name}</Text>
                  <Text style={styles.orderProductName}>{order.products?.name}</Text>
                </View>
                <Text style={styles.orderArrow}>›</Text>
              </TouchableOpacity>
            ))
          )}
        </View>

        {/* 공유 박스 */}
        <TouchableOpacity style={styles.shareBox} onPress={handleShare}>
          <View style={styles.shareIcon}>
            <Text style={styles.shareIconText}>👥</Text>
          </View>
          <View style={{ flex: 1 }}>
            <Text style={styles.shareText}>친구에게 공유하고</Text>
            <Text style={styles.shareText}>함께 지구를 구해요!</Text>
          </View>
          <Text style={styles.shareArrow}>⤴</Text>
        </TouchableOpacity>

        {/* 메뉴 섹션 */}
        <View style={styles.menuSection}>
          <TouchableOpacity style={styles.menuItem}>
            <Text style={styles.menuIcon}>❤️</Text>
            <Text style={styles.menuText}>관심업체</Text>
            <Text style={styles.menuArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.menuItem}>
            <Text style={styles.menuIcon}>💬</Text>
            <Text style={styles.menuText}>작성한 리뷰</Text>
            <Text style={styles.menuArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.menuItem}>
            <Text style={styles.menuIcon}>🔔</Text>
            <Text style={styles.menuText}>알림 설정</Text>
            <Text style={styles.menuArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.menuItem}>
            <Text style={styles.menuIcon}>❓</Text>
            <Text style={styles.menuText}>자주 묻는 질문</Text>
            <Text style={styles.menuArrow}>›</Text>
          </TouchableOpacity>

          <TouchableOpacity style={styles.menuItem}>
            <Text style={styles.menuIcon}>❓</Text>
            <Text style={styles.menuText}>고객센터</Text>
            <Text style={styles.menuArrow}>›</Text>
          </TouchableOpacity>
        </View>

        <View style={{ height: 100 }} />
      </ScrollView>

      {/* 하단 네비게이션 */}
      <View style={styles.bottomNav}>
        <TouchableOpacity style={styles.navItem} onPress={onBack}>
          <Text style={styles.navIcon}>🏠</Text>
          <Text style={styles.navLabel}>홈</Text>
        </TouchableOpacity>
        <TouchableOpacity style={styles.navItem} onPress={onViewReservations}>
          <Text style={styles.navIcon}>📦</Text>
          <Text style={styles.navLabel}>주문/예약</Text>
        </TouchableOpacity>
        <TouchableOpacity style={[styles.navItem, styles.navItemActive]}>
          <Text style={styles.navIconActive}>👤</Text>
          <Text style={styles.navLabelActive}>내정보</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  header: { backgroundColor: '#FFF', paddingTop: 50, paddingBottom: 15, paddingHorizontal: 20, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  logo: { fontSize: 18, fontWeight: 'bold', textAlign: 'center' },
  scrollView: { flex: 1 },
  profileSection: { backgroundColor: '#FFF', padding: 20, flexDirection: 'row', alignItems: 'center', gap: 12 },
  profileIcon: { width: 70, height: 70, borderRadius: 35, backgroundColor: '#F0E5D8', justifyContent: 'center', alignItems: 'center' },
  profileEmoji: { fontSize: 36 },
  profileHeader: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 4 },
  profileName: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  storeLink: { paddingHorizontal: 8 },
  storeLinkText: { fontSize: 14, color: '#999' },
  profileSubtitle: { fontSize: 14, color: '#999' },
  statsBox: { backgroundColor: '#E8F5E9', margin: 20, padding: 20, borderRadius: 12 },
  statsLabel: { fontSize: 14, color: '#2E7D32', marginBottom: 8 },
  statsAmount: { fontSize: 32, fontWeight: 'bold', color: '#1B5E20', marginBottom: 16 },
  statsRow: { flexDirection: 'row', gap: 20 },
  statsSubLabel: { fontSize: 13, color: '#2E7D32', marginBottom: 4 },
  statsSubValue: { fontSize: 18, fontWeight: 'bold', color: '#1B5E20' },
  section: { backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 16, marginBottom: 12 },
  sectionHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  sectionLink: { fontSize: 14, color: '#999' },
  emptyOrders: { paddingVertical: 40, alignItems: 'center' },
  emptyText: { fontSize: 14, color: '#999' },
  orderItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: 12, borderBottomWidth: 1, borderBottomColor: '#F0F0F0' },
  orderImage: { width: 60, height: 60, borderRadius: 8, backgroundColor: '#F5F5F5', justifyContent: 'center', alignItems: 'center', marginRight: 12 },
  orderImageText: { fontSize: 24 },
  orderHeader: { flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 4 },
  orderBadge: { fontSize: 12, color: '#00D563', fontWeight: '600' },
  orderTime: { fontSize: 12, color: '#999' },
  orderStoreName: { fontSize: 16, fontWeight: 'bold', color: '#333', marginBottom: 2 },
  orderProductName: { fontSize: 14, color: '#666' },
  orderArrow: { fontSize: 20, color: '#CCC', marginLeft: 8 },
  shareBox: { backgroundColor: '#E8F5E9', marginHorizontal: 20, marginBottom: 20, padding: 16, borderRadius: 12, flexDirection: 'row', alignItems: 'center', gap: 12 },
  shareIcon: { width: 50, height: 50, borderRadius: 25, backgroundColor: '#FFF', justifyContent: 'center', alignItems: 'center' },
  shareIconText: { fontSize: 24 },
  shareText: { fontSize: 14, color: '#1B5E20', fontWeight: '600' },
  shareArrow: { fontSize: 24, color: '#00D563' },
  menuSection: { backgroundColor: '#FFF', marginBottom: 20 },
  menuItem: { flexDirection: 'row', alignItems: 'center', paddingVertical: 16, paddingHorizontal: 20, borderBottomWidth: 1, borderBottomColor: '#F0F0F0' },
  menuIcon: { fontSize: 20, width: 30, marginRight: 12 },
  menuText: { flex: 1, fontSize: 16, color: '#333' },
  menuArrow: { fontSize: 20, color: '#CCC' },
  bottomNav: { flexDirection: 'row', backgroundColor: '#FFF', borderTopWidth: 1, borderTopColor: '#E0E0E0', paddingBottom: 20, paddingTop: 10 },
  navItem: { flex: 1, alignItems: 'center', paddingVertical: 8 },
  navItemActive: {},
  navIcon: { fontSize: 24, marginBottom: 4, color: '#999' },
  navIconActive: { fontSize: 24, marginBottom: 4, color: '#00D563' },
  navLabel: { fontSize: 12, color: '#999' },
  navLabelActive: { fontSize: 12, color: '#00D563', fontWeight: '600' },
});
</file>

<file path="app/src/screens/MyReservations.tsx">
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, Alert, Clipboard, Modal, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface MyReservationsFullProps {
  onBack: () => void;
  onWriteReview: (reservation: any) => void;
}

export default function MyReservationsFull({ onBack, onWriteReview }: MyReservationsFullProps) {
  const [loading, setLoading] = useState(true);
  const [reservations, setReservations] = useState<any[]>([]);
  const [cancelModalVisible, setCancelModalVisible] = useState(false);
  const [selectedReservationId, setSelectedReservationId] = useState<string | null>(null);
  const [cancelReason, setCancelReason] = useState('');

  useEffect(() => {
    fetchReservations();
  }, []);

  const fetchReservations = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: consumer } = await supabase.from('consumers').select('id').eq('user_id', user.id).single();
      if (!consumer) return;

      const { data, error } = await supabase
        .from('reservations')
        .select('*, stores(name, address, phone, refund_policy, no_show_policy), products(name)')
        .eq('consumer_id', consumer.id)
        .eq('picked_up', false)
        .in('status', ['confirmed', 'pending'])
        .order('created_at', { ascending: false });

      if (error) throw error;
      setReservations(data || []);
    } catch (error) {
      console.error('예약 로딩 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const handlePickupComplete = async (reservationId: string) => {
    try {
      const { error } = await supabase
        .from('reservations')
        .update({ picked_up: true, picked_up_at: new Date().toISOString() })
        .eq('id', reservationId);

      if (error) throw error;

      const reservation = reservations.find(r => r.id === reservationId);
      onWriteReview(reservation);
    } catch (error) {
      console.error('픽업 완료 오류:', error);
      alert('픽업 완료 처리에 실패했습니다.');
    }
  };

  const copyAddress = (address: string) => {
    Clipboard.setString(address);
    alert('주소가 복사되었습니다.');
  };

  const openCancelModal = (reservationId: string) => {
    setSelectedReservationId(reservationId);
    setCancelModalVisible(true);
  };

  const handleCancelReservation = async () => {
    if (!selectedReservationId) return;
    if (!cancelReason.trim()) {
      Alert.alert('알림', '취소 사유를 입력해주세요.');
      return;
    }

    try {
      const { error } = await supabase
        .from('reservations')
        .update({
          status: 'cancelled_by_consumer',
          cancel_reason: cancelReason.trim()
        })
        .eq('id', selectedReservationId);

      if (error) throw error;

      Alert.alert('완료', '예약이 취소되었습니다.');
      setCancelModalVisible(false);
      setCancelReason('');
      setSelectedReservationId(null);
      fetchReservations(); // 목록 새로고침
    } catch (error) {
      console.error('예약 취소 오류:', error);
      Alert.alert('오류', '예약 취소에 실패했습니다.');
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>💚 Save It</Text>
        <Text style={styles.notificationIcon}>🔔</Text>
      </View>

      <View style={styles.topTab}>
        <TouchableOpacity style={styles.topTabButton}>
          <Text style={styles.topTabTextActive}>내 매장 예약</Text>
        </TouchableOpacity>
        <TouchableOpacity style={[styles.topTabButton, { backgroundColor: '#E8F5E9' }]}>
          <Text style={styles.topTabText}>나의 예약</Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView}>
        {reservations.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>예약 내역이 없습니다.</Text>
          </View>
        ) : (
          reservations.map((reservation) => (
            <View key={reservation.id} style={styles.reservationCard}>
              <View style={styles.reservationHeader}>
                <Text style={styles.reservationNumber}>예약번호 #{reservation.reservation_number}</Text>
                <Text style={[styles.reservationStatus, reservation.status === 'confirmed' ? styles.statusConfirmed : styles.statusPending]}>
                  {reservation.status === 'confirmed' ? '예약 확정' : '곧 방문'}
                </Text>
              </View>

              <Text style={styles.storeName}>{reservation.stores?.name}</Text>

              <View style={styles.productRow}>
                <Text style={styles.productIcon}>🛒</Text>
                <View style={{ flex: 1 }}>
                  <Text style={styles.productName}>{reservation.products?.name} x{reservation.quantity}</Text>
                  <Text style={styles.productPrice}>{reservation.total_amount?.toLocaleString()}원 <Text style={styles.priceLabel}>(현장 결제)</Text></Text>
                </View>
              </View>

              <View style={styles.timeRow}>
                <Text style={styles.timeIcon}>🕐</Text>
                <Text style={styles.timeText}>
                  픽업 예약 시간: {reservation.pickup_time ? new Date(reservation.pickup_time).toLocaleString('ko-KR', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : '-'}
                </Text>
              </View>

              <View style={styles.storeInfoBox}>
                <View style={styles.storeInfoRow}>
                  <Text style={styles.storeInfoIcon}>📍</Text>
                  <Text style={styles.storeInfoText}>{reservation.stores?.address}</Text>
                  <TouchableOpacity onPress={() => copyAddress(reservation.stores?.address)}>
                    <Text style={styles.copyButton}>복사</Text>
                  </TouchableOpacity>
                </View>
                <View style={styles.storeInfoRow}>
                  <Text style={styles.storeInfoIcon}>📞</Text>
                  <Text style={styles.storeInfoText}>{reservation.stores?.phone}</Text>
                  <TouchableOpacity>
                    <Text style={styles.callButton}>전화하기</Text>
                  </TouchableOpacity>
                </View>
              </View>

              <View style={styles.policyBox}>
                <Text style={styles.policyTitle}>환불 및 노쇼 정책</Text>
                <Text style={styles.policyText}>• {reservation.stores?.refund_policy}</Text>
                <Text style={styles.policyText}>• {reservation.stores?.no_show_policy}</Text>
              </View>

              <View style={styles.buttonRow}>
                <TouchableOpacity
                  style={styles.cancelButton}
                  onPress={() => openCancelModal(reservation.id)}
                >
                  <Text style={styles.cancelButtonText}>예약 취소</Text>
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.completeButton}
                  onPress={() => handlePickupComplete(reservation.id)}
                >
                  <Text style={styles.completeButtonText}>픽업 완료</Text>
                </TouchableOpacity>
              </View>
            </View>
          ))
        )}
        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 취소 모달 */}
      <Modal
        visible={cancelModalVisible}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setCancelModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            <Text style={styles.modalTitle}>예약 취소</Text>
            <Text style={styles.modalSubtitle}>취소 사유를 입력해주세요</Text>

            <TextInput
              style={styles.modalInput}
              placeholder="예: 일정이 변경되어서, 다른 곳 예약함 등"
              placeholderTextColor="#999"
              value={cancelReason}
              onChangeText={setCancelReason}
              multiline
              numberOfLines={3}
            />

            <View style={styles.modalButtonRow}>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonCancel]}
                onPress={() => {
                  setCancelModalVisible(false);
                  setCancelReason('');
                  setSelectedReservationId(null);
                }}
              >
                <Text style={styles.modalButtonTextCancel}>닫기</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonConfirm]}
                onPress={handleCancelReservation}
              >
                <Text style={styles.modalButtonTextConfirm}>취소하기</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  notificationIcon: { fontSize: 24 },
  topTab: { flexDirection: 'row', backgroundColor: '#FFF', padding: 15, gap: 10 },
  topTabButton: { flex: 1, paddingVertical: 12, borderRadius: 12, backgroundColor: '#1A1A2E', alignItems: 'center' },
  topTabText: { fontSize: 14, fontWeight: '600', color: '#00A84D' },
  topTabTextActive: { fontSize: 14, fontWeight: '600', color: '#FFF' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 15 },
  emptyContainer: { paddingVertical: 60, alignItems: 'center' },
  emptyText: { fontSize: 15, color: '#999' },
  reservationCard: { backgroundColor: '#FFF', padding: 18, borderRadius: 12, marginBottom: 12 },
  reservationHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 },
  reservationNumber: { fontSize: 13, color: '#999' },
  reservationStatus: { fontSize: 13, fontWeight: '600', paddingHorizontal: 12, paddingVertical: 4, borderRadius: 12 },
  statusConfirmed: { backgroundColor: '#E8F5E9', color: '#00A84D' },
  statusPending: { backgroundColor: '#FFE5E5', color: '#FF9800' },
  storeName: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 12 },
  productRow: { flexDirection: 'row', alignItems: 'center', gap: 12, marginBottom: 10, backgroundColor: '#E8F5E9', padding: 12, borderRadius: 8 },
  productIcon: { fontSize: 24 },
  productName: { fontSize: 15, fontWeight: '600', color: '#333', marginBottom: 4 },
  productPrice: { fontSize: 16, fontWeight: 'bold', color: '#00D563' },
  priceLabel: { fontSize: 13, color: '#666', fontWeight: 'normal' },
  timeRow: { flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 12 },
  timeIcon: { fontSize: 18 },
  timeText: { fontSize: 14, color: '#666' },
  storeInfoBox: { backgroundColor: '#F9F9F9', padding: 12, borderRadius: 8, marginBottom: 12 },
  storeInfoRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 8 },
  storeInfoIcon: { fontSize: 16, marginRight: 8 },
  storeInfoText: { flex: 1, fontSize: 13, color: '#333' },
  copyButton: { fontSize: 13, color: '#00D563', fontWeight: '600' },
  callButton: { fontSize: 13, color: '#007AFF', fontWeight: '600' },
  policyBox: { backgroundColor: '#FFF4E5', padding: 12, borderRadius: 8, marginBottom: 12 },
  policyTitle: { fontSize: 13, fontWeight: '600', color: '#333', marginBottom: 6 },
  policyText: { fontSize: 12, color: '#666', lineHeight: 18, marginBottom: 2 },
  buttonRow: { flexDirection: 'row', gap: 10 },
  cancelButton: { flex: 1, paddingVertical: 12, borderRadius: 8, borderWidth: 1, borderColor: '#E0E0E0', alignItems: 'center' },
  cancelButtonText: { fontSize: 14, fontWeight: '600', color: '#666' },
  completeButton: { flex: 1, paddingVertical: 12, borderRadius: 8, backgroundColor: '#00D563', alignItems: 'center' },
  completeButtonText: { fontSize: 14, fontWeight: '600', color: '#FFF' },
  // 모달 스타일
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0, 0, 0, 0.5)', justifyContent: 'center', alignItems: 'center', padding: 20 },
  modalContainer: { backgroundColor: '#FFF', borderRadius: 16, padding: 24, width: '100%', maxWidth: 400 },
  modalTitle: { fontSize: 20, fontWeight: 'bold', color: '#333', marginBottom: 8 },
  modalSubtitle: { fontSize: 14, color: '#666', marginBottom: 20 },
  modalInput: { borderWidth: 1, borderColor: '#E0E0E0', borderRadius: 8, padding: 12, fontSize: 14, color: '#333', minHeight: 80, textAlignVertical: 'top', marginBottom: 20 },
  modalButtonRow: { flexDirection: 'row', gap: 10 },
  modalButton: { flex: 1, paddingVertical: 14, borderRadius: 8, alignItems: 'center' },
  modalButtonCancel: { backgroundColor: '#F5F5F5', borderWidth: 1, borderColor: '#E0E0E0' },
  modalButtonConfirm: { backgroundColor: '#FF6B6B' },
  modalButtonTextCancel: { fontSize: 14, fontWeight: '600', color: '#666' },
  modalButtonTextConfirm: { fontSize: 14, fontWeight: '600', color: '#FFF' },
});
</file>

<file path="app/src/screens/ProfileEditScreen.tsx">
import React, { useEffect, useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface ProfileEditScreenProps {
  onBack: () => void;
}

export default function ProfileEditScreen({ onBack }: ProfileEditScreenProps) {
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);

  const [nickname, setNickname] = useState('');
  const [phone, setPhone] = useState('');
  const [address, setAddress] = useState('');
  const [email, setEmail] = useState('');
  const [consumerId, setConsumerId] = useState('');

  useEffect(() => {
    fetchProfile();
  }, []);

  const fetchProfile = async () => {
    try {
      setLoading(true);
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) return;

      setEmail(user.email || '');

      const { data: consumerData, error } = await supabase
        .from('consumers')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;

      if (consumerData) {
        setConsumerId(consumerData.id);
        setNickname(consumerData.nickname || '');
        setPhone(consumerData.phone || '');
        setAddress(consumerData.address || '');
      }
    } catch (error) {
      console.error('프로필 로딩 오류:', error);
      Alert.alert('오류', '프로필을 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    try {
      if (!nickname.trim()) {
        Alert.alert('알림', '닉네임을 입력해주세요.');
        return;
      }

      setSaving(true);

      const { error } = await supabase
        .from('consumers')
        .update({
          nickname: nickname.trim(),
          phone: phone.trim(),
          address: address.trim(),
        })
        .eq('id', consumerId);

      if (error) throw error;

      Alert.alert('완료', '프로필이 저장되었습니다.', [{ text: '확인', onPress: onBack }]);
    } catch (error) {
      console.error('프로필 저장 오류:', error);
      Alert.alert('오류', '프로필 저장에 실패했습니다.');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>프로필 편집</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* 이메일 (읽기 전용) */}
        <Text style={styles.label}>이메일</Text>
        <View style={[styles.input, styles.inputDisabled]}>
          <Text style={styles.inputTextDisabled}>{email}</Text>
        </View>

        {/* 닉네임 */}
        <Text style={styles.label}>닉네임 *</Text>
        <TextInput
          style={styles.input}
          value={nickname}
          onChangeText={setNickname}
          placeholder="닉네임을 입력하세요"
          placeholderTextColor="#999"
        />

        {/* 연락처 */}
        <Text style={styles.label}>연락처</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="010-1234-5678"
          placeholderTextColor="#999"
          keyboardType="phone-pad"
        />

        {/* 주소 */}
        <Text style={styles.label}>주소</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={address}
          onChangeText={setAddress}
          placeholder="서울시 강남구 테헤란로 123"
          placeholderTextColor="#999"
          multiline
          numberOfLines={2}
        />

        {/* 저장 버튼 */}
        <TouchableOpacity style={styles.saveButton} onPress={handleSave} disabled={saving}>
          {saving ? (
            <ActivityIndicator size="small" color="#FFF" />
          ) : (
            <Text style={styles.saveButtonText}>저장하기</Text>
          )}
        </TouchableOpacity>

        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 30,
  },

  // 라벨
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    marginTop: 15,
  },

  // 입력 필드
  input: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  inputDisabled: {
    backgroundColor: '#F5F5F5',
  },
  inputTextDisabled: {
    fontSize: 15,
    color: '#999',
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },

  // 저장 버튼
  saveButton: {
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 30,
  },
  saveButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/ReservationScreen.tsx">
import React, { useState } from 'react';
import { Alert, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

export default function ReservationScreen({ product, store, onBack }: any) {
  const [quantity, setQuantity] = useState('1');
  const [pickupTime, setPickupTime] = useState('18:00');

  const handleReserve = async () => {
    const qty = parseInt(quantity);
    if (!qty || qty < 1 || qty > product.stock) {
      Alert.alert('오류', '수량을 확인해주세요');
      return;
    }

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    const { data: consumer } = await supabase.from('consumers').select('id').eq('user_id', user.id).single();
    if (!consumer) {
      Alert.alert('오류', '소비자 정보가 없습니다');
      return;
    }

    const { data: resNumber } = await supabase.rpc('generate_reservation_number');
    
    const pickupDateTime = new Date();
    const [hours, minutes] = pickupTime.split(':');
    pickupDateTime.setHours(parseInt(hours), parseInt(minutes));

    const { error } = await supabase.from('reservations').insert({
      reservation_number: resNumber,
      consumer_id: consumer.id,
      store_id: store.id,
      product_id: product.id,
      quantity: qty,
      total_amount: product.discounted_price * qty,
      pickup_time: pickupDateTime.toISOString(),
      status: 'confirmed'
    });

    if (error) {
      Alert.alert('오류', error.message);
    } else {
      Alert.alert('예약 완료!', `예약번호: ${resNumber}\n픽업시간: ${pickupTime}`, [
        { text: '확인', onPress: onBack }
      ]);
    }
  };

  const totalAmount = product.discounted_price * parseInt(quantity || '1');

  return (
    <ScrollView style={styles.container}>
      <TouchableOpacity onPress={onBack} style={styles.backButton}>
        <Text style={styles.backText}>← 뒤로</Text>
      </TouchableOpacity>

      <Text style={styles.title}>예약하기</Text>
      
      <View style={styles.section}>
        <Text style={styles.label}>업체</Text>
        <Text style={styles.value}>{store.name}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>상품</Text>
        <Text style={styles.value}>{product.name}</Text>
        <Text style={styles.price}>{product.discounted_price.toLocaleString()}원</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>수량 (재고: {product.stock}개)</Text>
        <TextInput
          style={styles.input}
          value={quantity}
          onChangeText={setQuantity}
          keyboardType="number-pad"
          placeholder="1"
        />
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>픽업 시간</Text>
        <TextInput
          style={styles.input}
          value={pickupTime}
          onChangeText={setPickupTime}
          placeholder="18:00"
        />
      </View>

      <View style={styles.totalSection}>
        <Text style={styles.totalLabel}>총 결제 금액</Text>
        <Text style={styles.totalAmount}>{totalAmount.toLocaleString()}원</Text>
      </View>

      <TouchableOpacity style={styles.button} onPress={handleReserve}>
        <Text style={styles.buttonText}>예약하기</Text>
      </TouchableOpacity>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#fff', padding: 20 },
  backButton: { marginBottom: 15 },
  backText: { fontSize: 16, color: '#007AFF' },
  title: { fontSize: 28, fontWeight: 'bold', marginBottom: 20 },
  section: { marginBottom: 20 },
  label: { fontSize: 16, fontWeight: 'bold', marginBottom: 5 },
  value: { fontSize: 16, color: '#333' },
  price: { fontSize: 14, color: '#666', marginTop: 3 },
  input: { backgroundColor: '#f5f5f5', padding: 15, borderRadius: 10, fontSize: 16, marginTop: 5 },
  totalSection: { backgroundColor: '#f9f9f9', padding: 20, borderRadius: 10, marginVertical: 20 },
  totalLabel: { fontSize: 16, color: '#666', marginBottom: 5 },
  totalAmount: { fontSize: 32, fontWeight: 'bold', color: '#007AFF' },
  button: { backgroundColor: '#00C853', padding: 18, borderRadius: 10, alignItems: 'center', marginBottom: 30 },
  buttonText: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
});
</file>

<file path="app/src/screens/ReviewScreen.tsx">
import React, { useState } from 'react';
import { Alert, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

export default function ReviewScreen({ reservation, onBack }: any) {
  const [rating, setRating] = useState(5);
  const [content, setContent] = useState('');

  const handleSubmit = async () => {
    if (!content.trim()) {
      Alert.alert('오류', '리뷰 내용을 입력해주세요');
      return;
    }

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        Alert.alert('오류', '로그인이 필요합니다');
        return;
      }

      const { data: consumer } = await supabase
        .from('consumers')
        .select('id')
        .eq('user_id', user.id)
        .single();

      if (!consumer) {
        Alert.alert('오류', '소비자 정보를 찾을 수 없습니다');
        return;
      }

      // 리뷰 작성
      const { error } = await supabase.from('reviews').insert({
        reservation_id: reservation.id,
        consumer_id: consumer.id,
        store_id: reservation.store_id,
        rating,
        content: content.trim(),
      });

      if (error) {
        Alert.alert('오류', error.message);
        return;
      }

      // 업체 평점 업데이트
      const { data: reviews } = await supabase
        .from('reviews')
        .select('rating')
        .eq('store_id', reservation.store_id);

      if (reviews && reviews.length > 0) {
        const avgRating = reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length;
        await supabase
          .from('stores')
          .update({ average_rating: avgRating })
          .eq('id', reservation.store_id);
      }

      Alert.alert('완료', '리뷰가 작성되었습니다!', [
        { text: '확인', onPress: onBack }
      ]);
    } catch (err: any) {
      console.error('리뷰 작성 오류:', err);
      Alert.alert('오류', '리뷰 작성 중 문제가 발생했습니다');
    }
  };

  return (
    <ScrollView style={styles.container}>
      <TouchableOpacity onPress={onBack} style={styles.backButton}>
        <Text style={styles.backText}>← 뒤로</Text>
      </TouchableOpacity>

      <Text style={styles.title}>리뷰 작성</Text>

      <View style={styles.section}>
        <Text style={styles.label}>업체</Text>
        <Text style={styles.value}>{reservation.store?.name || '업체명 없음'}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>상품</Text>
        <Text style={styles.value}>{reservation.product?.name || '상품명 없음'}</Text>
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>별점</Text>
        <View style={styles.ratingContainer}>
          {[1, 2, 3, 4, 5].map((star) => (
            <TouchableOpacity key={star} onPress={() => setRating(star)}>
              <Text style={styles.star}>{star <= rating ? '⭐' : '☆'}</Text>
            </TouchableOpacity>
          ))}
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.label}>리뷰 내용</Text>
        <TextInput
          style={styles.textArea}
          value={content}
          onChangeText={setContent}
          placeholder="이용 경험을 공유해주세요"
          multiline
          numberOfLines={6}
          textAlignVertical="top"
        />
      </View>

      <TouchableOpacity style={styles.button} onPress={handleSubmit}>
        <Text style={styles.buttonText}>리뷰 등록</Text>
      </TouchableOpacity>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
    padding: 20
  },
  backButton: {
    marginBottom: 15
  },
  backText: {
    fontSize: 16,
    color: '#007AFF'
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    marginBottom: 20
  },
  section: {
    marginBottom: 20
  },
  label: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5
  },
  value: {
    fontSize: 16,
    color: '#333'
  },
  ratingContainer: {
    flexDirection: 'row',
    marginTop: 10
  },
  star: {
    fontSize: 40,
    marginRight: 5
  },
  textArea: {
    backgroundColor: '#f5f5f5',
    padding: 15,
    borderRadius: 10,
    fontSize: 16,
    marginTop: 5,
    minHeight: 150,
  },
  button: {
    backgroundColor: '#007AFF',
    padding: 18,
    borderRadius: 10,
    alignItems: 'center',
    marginVertical: 20
  },
  buttonText: {
    color: '#fff',
    fontSize: 18,
    fontWeight: 'bold'
  },
});
</file>

<file path="app/src/screens/ReviewWrite.tsx">
import React, { useState } from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface ReviewWriteProps {
  reservation: any;
  onBack: () => void;
  onComplete: () => void;
}

export default function ReviewWrite({ reservation, onBack, onComplete }: ReviewWriteProps) {
  const [loading, setLoading] = useState(false);
  const [rating, setRating] = useState(0);
  const [content, setContent] = useState('');

  const handleSubmit = async () => {
    if (rating === 0) {
      alert('별점을 선택해주세요.');
      return;
    }
    if (!content.trim()) {
      alert('리뷰 내용을 입력해주세요.');
      return;
    }
    if (content.length > 500) {
      alert('리뷰는 500자 이내로 작성해주세요.');
      return;
    }

    try {
      setLoading(true);

      const { error } = await supabase.from('reviews').insert({
        reservation_id: reservation.id,
        consumer_id: reservation.consumer_id,
        store_id: reservation.store_id,
        rating,
        content,
      });

      if (error) throw error;

      alert('리뷰가 등록되었습니다.');
      onComplete();
    } catch (error) {
      console.error('리뷰 등록 오류:', error);
      alert('리뷰 등록에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>💚 Save It</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.scrollContent}>
        {/* 픽업 완료 아이콘 */}
        <View style={styles.completeIconContainer}>
          <View style={styles.completeIcon}>
            <Text style={styles.completeIconText}>✓</Text>
          </View>
        </View>

        <Text style={styles.title}>픽업 완료!</Text>
        <Text style={styles.subtitle}>매장에서의 경험은 어떠셨나요?</Text>

        {/* 가게 정보 */}
        <View style={styles.storeCard}>
          <View style={styles.storeIcon}>
            <Text style={styles.storeIconText}>🏪</Text>
          </View>
          <View style={{ flex: 1 }}>
            <Text style={styles.storeName}>{reservation.stores?.name || 'Green Garden Bistro'}</Text>
            <Text style={styles.productName}>{reservation.products?.name} x{reservation.quantity}</Text>
            <Text style={styles.reservationNumber}>주문번호 #{reservation.reservation_number}</Text>
          </View>
        </View>

        {/* 별점 선택 */}
        <View style={styles.ratingContainer}>
          {[1, 2, 3, 4, 5].map((star) => (
            <TouchableOpacity key={star} onPress={() => setRating(star)}>
              <Text style={styles.star}>{star <= rating ? '★' : '☆'}</Text>
            </TouchableOpacity>
          ))}
        </View>
        <Text style={styles.ratingLabel}>
          {rating === 0
            ? '별점을 선택해주세요'
            : rating === 5
            ? '아주 좋아요'
            : rating === 4
            ? '좋아요'
            : rating === 3
            ? '보통이에요'
            : rating === 2
            ? '별로에요'
            : '아쉬워요'}
        </Text>

        {/* 리뷰 작성 */}
        <Text style={styles.label}>리뷰 작성하기</Text>
        <TextInput
          style={styles.textarea}
          value={content}
          onChangeText={setContent}
          placeholder="다른 분들께 도움이 되도록 상품이나 픽업 과정에 대한 후기를 남겨주세요."
          placeholderTextColor="#999"
          multiline
          numberOfLines={6}
          maxLength={500}
        />
        <Text style={styles.charCount}>{content.length} / 500</Text>

        {/* 안내 */}
        <View style={styles.infoBox}>
          <Text style={styles.infoIcon}>ℹ️</Text>
          <Text style={styles.infoText}>
            리뷰는 공성된 피드백을 위해 업체별 1회만 작성 가능하며, 작성 시 수정이 불가하니 신중하게 작성해 주세요.
          </Text>
        </View>

        {/* 버튼 */}
        <TouchableOpacity
          style={styles.submitButton}
          onPress={handleSubmit}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#FFF" />
          ) : (
            <Text style={styles.submitButtonText}>리뷰 등록하기 ➤</Text>
          )}
        </TouchableOpacity>

        <TouchableOpacity style={styles.skipButton} onPress={onBack}>
          <Text style={styles.skipButtonText}>나중에하기</Text>
        </TouchableOpacity>

        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  scrollView: { flex: 1 },
  scrollContent: { paddingHorizontal: 20, paddingTop: 30 },
  completeIconContainer: { alignItems: 'center', marginBottom: 20 },
  completeIcon: { width: 80, height: 80, borderRadius: 40, backgroundColor: '#E8F5E9', justifyContent: 'center', alignItems: 'center' },
  completeIconText: { fontSize: 40, color: '#00D563', fontWeight: 'bold' },
  title: { fontSize: 24, fontWeight: 'bold', color: '#333', textAlign: 'center', marginBottom: 8 },
  subtitle: { fontSize: 15, color: '#666', textAlign: 'center', marginBottom: 30 },
  storeCard: { backgroundColor: '#FFF', padding: 16, borderRadius: 12, marginBottom: 30, flexDirection: 'row', alignItems: 'center', gap: 12 },
  storeIcon: { width: 50, height: 50, borderRadius: 8, backgroundColor: '#F5F5F5', justifyContent: 'center', alignItems: 'center' },
  storeIconText: { fontSize: 24 },
  storeName: { fontSize: 16, fontWeight: 'bold', color: '#333', marginBottom: 4 },
  productName: { fontSize: 14, color: '#666', marginBottom: 2 },
  reservationNumber: { fontSize: 13, color: '#00D563', fontWeight: '600' },
  ratingContainer: { flexDirection: 'row', justifyContent: 'center', gap: 8, marginBottom: 12 },
  star: { fontSize: 48, color: '#FFB800' },
  ratingLabel: { fontSize: 16, color: '#FF9800', textAlign: 'center', marginBottom: 30, fontWeight: '600' },
  label: { fontSize: 16, fontWeight: '600', color: '#333', marginBottom: 12 },
  textarea: { backgroundColor: '#FFF', borderRadius: 12, padding: 16, fontSize: 15, color: '#333', height: 150, textAlignVertical: 'top', borderWidth: 1, borderColor: '#E0E0E0', marginBottom: 8 },
  charCount: { fontSize: 13, color: '#999', textAlign: 'right', marginBottom: 20 },
  infoBox: { backgroundColor: '#FFF4E5', padding: 16, borderRadius: 12, flexDirection: 'row', alignItems: 'flex-start', gap: 12, marginBottom: 20 },
  infoIcon: { fontSize: 18 },
  infoText: { flex: 1, fontSize: 13, color: '#666', lineHeight: 18 },
  submitButton: { backgroundColor: '#00D563', paddingVertical: 16, borderRadius: 12, alignItems: 'center', marginBottom: 12 },
  submitButtonText: { color: '#FFF', fontSize: 16, fontWeight: '600' },
  skipButton: { paddingVertical: 14, alignItems: 'center' },
  skipButtonText: { fontSize: 15, color: '#999' },
});
</file>

<file path="app/src/screens/SignupScreen.tsx">
import React, { useState } from 'react';
import { Alert, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

export default function SignupScreen({ onBack }: { onBack: () => void }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [nickname, setNickname] = useState('');

const handleSignup = async () => {
  if (!email || !password || !nickname) {
    Alert.alert('오류', '모든 항목을 입력해주세요');
    return;
  }
  
  const { data, error } = await supabase.auth.signUp({ email, password });
  if (error) {
    Alert.alert('오류', error.message);
    return;
  }

  // consumer 프로필 생성
  if (data.user) {
    await supabase.from('consumers').insert({
      user_id: data.user.id,
      nickname: nickname
    });
  }

  Alert.alert('성공', '이메일을 확인해주세요!');
  onBack();
};

  return (
    <View style={styles.container}>
      <Text style={styles.title}>회원가입</Text>
      <TextInput style={styles.input} placeholder="닉네임" value={nickname} onChangeText={setNickname} />
      <TextInput style={styles.input} placeholder="이메일" value={email} onChangeText={setEmail} autoCapitalize="none" />
      <TextInput style={styles.input} placeholder="비밀번호 (6자 이상)" value={password} onChangeText={setPassword} secureTextEntry />
      <TouchableOpacity style={styles.button} onPress={handleSignup}>
        <Text style={styles.buttonText}>가입하기</Text>
      </TouchableOpacity>
      <TouchableOpacity onPress={onBack}>
        <Text style={styles.link}>← 로그인으로 돌아가기</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 20, justifyContent: 'center', backgroundColor: '#fff' },
  title: { fontSize: 32, fontWeight: 'bold', marginBottom: 30, textAlign: 'center' },
  input: { backgroundColor: '#f5f5f5', padding: 15, borderRadius: 10, marginBottom: 15 },
  button: { backgroundColor: '#007AFF', padding: 18, borderRadius: 10, alignItems: 'center', marginTop: 10 },
  buttonText: { color: '#fff', fontSize: 18, fontWeight: 'bold' },
  link: { color: '#007AFF', textAlign: 'center', marginTop: 20 },
});
</file>

<file path="app/src/screens/SignupTypeScreen.tsx">
import React from 'react';
import { StyleSheet, Text, TouchableOpacity, View } from 'react-native';

interface SignupTypeScreenProps {
  onSelectConsumer: () => void;
  onSelectStore: () => void;
  onBack: () => void;
}

export default function SignupTypeScreen({ onSelectConsumer, onSelectStore, onBack }: SignupTypeScreenProps) {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>회원가입</Text>
      <Text style={styles.subtitle}>가입 유형을 선택해주세요</Text>

      <View style={styles.buttonContainer}>
        <TouchableOpacity
          style={[styles.typeButton, styles.consumerButton]}
          onPress={onSelectConsumer}
        >
          <Text style={styles.typeIcon}>👤</Text>
          <Text style={styles.typeTitle}>일반고객</Text>
          <Text style={styles.typeDescription}>할인 상품을 검색하고{'\n'}예약할 수 있어요</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.typeButton, styles.storeButton]}
          onPress={onSelectStore}
        >
          <Text style={styles.typeIcon}>🏪</Text>
          <Text style={styles.typeTitle}>사업자고객</Text>
          <Text style={styles.typeDescription}>상품을 등록하고{'\n'}예약을 관리할 수 있어요</Text>
        </TouchableOpacity>
      </View>

      <TouchableOpacity style={styles.backButton} onPress={onBack}>
        <Text style={styles.backButtonText}>뒤로 가기</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
    padding: 20,
    justifyContent: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#333',
    textAlign: 'center',
    marginBottom: 10,
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 40,
  },
  buttonContainer: {
    gap: 20,
    marginBottom: 30,
  },
  typeButton: {
    padding: 30,
    borderRadius: 15,
    alignItems: 'center',
    borderWidth: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  consumerButton: {
    backgroundColor: '#F0F8FF',
    borderColor: '#007AFF',
  },
  storeButton: {
    backgroundColor: '#FFF5F0',
    borderColor: '#FF9500',
  },
  typeIcon: {
    fontSize: 48,
    marginBottom: 15,
  },
  typeTitle: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 10,
  },
  typeDescription: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    lineHeight: 20,
  },
  backButton: {
    padding: 15,
    alignItems: 'center',
  },
  backButtonText: {
    fontSize: 16,
    color: '#007AFF',
  },
});
</file>

<file path="app/src/screens/StoreCashHistory.tsx">
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreCashHistoryProps {
  onBack: () => void;
}

type FilterType = '전체' | '충전' | '사용';

export default function StoreCashHistory({ onBack }: StoreCashHistoryProps) {
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<FilterType>('전체');
  const [transactions, setTransactions] = useState<any[]>([]);

  useEffect(() => {
    fetchTransactions();
  }, []);

  const fetchTransactions = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: store } = await supabase
        .from('stores')
        .select('id')
        .eq('user_id', user.id)
        .single();
      if (!store) return;

      const twoYearsAgo = new Date();
      twoYearsAgo.setFullYear(twoYearsAgo.getFullYear() - 2);

      const { data, error } = await supabase
        .from('cash_transactions')
        .select('*')
        .eq('store_id', store.id)
        .gte('created_at', twoYearsAgo.toISOString())
        .order('created_at', { ascending: false });

      if (error) throw error;
      setTransactions(data || []);
    } catch (error) {
      console.error('내역 로딩 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const filteredTransactions = transactions.filter((t) => {
    if (filter === '충전') return t.transaction_type === 'charge';
    if (filter === '사용') return t.transaction_type === 'fee';
    return true;
  });

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>캐시 내역</Text>
        <View style={{ width: 40 }} />
      </View>

      <View style={styles.filterRow}>
        {(['전체', '충전', '사용'] as FilterType[]).map((f) => (
          <TouchableOpacity
            key={f}
            style={[styles.filterButton, filter === f && styles.filterButtonActive]}
            onPress={() => setFilter(f)}
          >
            <Text style={[styles.filterText, filter === f && styles.filterTextActive]}>
              {f}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      <ScrollView style={styles.scrollView}>
        {filteredTransactions.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>내역이 없습니다.</Text>
          </View>
        ) : (
          filteredTransactions.map((transaction) => (
            <View key={transaction.id} style={styles.transactionCard}>
              <View>
                <Text style={styles.transactionType}>
                  {transaction.transaction_type === 'charge' ? '💵 충전' : '💸 사용'}
                </Text>
                <Text style={styles.transactionDesc}>{transaction.description}</Text>
                <Text style={styles.transactionDate}>
                  {new Date(transaction.created_at).toLocaleString('ko-KR')}
                </Text>
              </View>
              <View style={{ alignItems: 'flex-end' }}>
                <Text
                  style={[
                    styles.transactionAmount,
                    transaction.transaction_type === 'charge'
                      ? styles.transactionAmountCharge
                      : styles.transactionAmountFee,
                  ]}
                >
                  {transaction.transaction_type === 'charge' ? '+' : '-'}
                  {Math.abs(transaction.amount).toLocaleString()}원
                </Text>
                <Text style={styles.transactionBalance}>
                  잔액: {transaction.balance_after.toLocaleString()}원
                </Text>
              </View>
            </View>
          ))
        )}
        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  filterRow: { flexDirection: 'row', backgroundColor: '#FFF', padding: 15, gap: 10 },
  filterButton: { flex: 1, paddingVertical: 10, borderRadius: 20, backgroundColor: '#F5F5F5', alignItems: 'center' },
  filterButtonActive: { backgroundColor: '#00D563' },
  filterText: { fontSize: 14, fontWeight: '600', color: '#666' },
  filterTextActive: { color: '#FFF' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 15 },
  emptyContainer: { paddingVertical: 60, alignItems: 'center' },
  emptyText: { fontSize: 15, color: '#999' },
  transactionCard: { backgroundColor: '#FFF', padding: 18, borderRadius: 12, marginBottom: 12, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  transactionType: { fontSize: 15, fontWeight: '600', color: '#333', marginBottom: 4 },
  transactionDesc: { fontSize: 13, color: '#666', marginBottom: 4 },
  transactionDate: { fontSize: 12, color: '#999' },
  transactionAmount: { fontSize: 18, fontWeight: 'bold', marginBottom: 4 },
  transactionAmountCharge: { color: '#00D563' },
  transactionAmountFee: { color: '#FF6B6B' },
  transactionBalance: { fontSize: 13, color: '#999' },
});
</file>

<file path="app/src/screens/StoreCashManagement.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { ActivityIndicator, ScrollView, StyleSheet, Switch, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreCashManagementProps {
  onBack: () => void;
  onViewHistory: () => void;
}

const QUICK_AMOUNTS = [30000, 50000, 100000];

export default function StoreCashManagement({ onBack, onViewHistory }: StoreCashManagementProps) {
  const [loading, setLoading] = useState(true);
  const [storeId, setStoreId] = useState('');
  const [storeName, setStoreName] = useState('');
  const [cashBalance, setCashBalance] = useState(0);
  const [isActive, setIsActive] = useState(false);
  const [selectedAmount, setSelectedAmount] = useState<number | null>(50000);
  const [customAmount, setCustomAmount] = useState('');

  const fetchStoreInfo = useCallback(async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('사용자 정보 없음');

      const { data, error } = await supabase
        .from('stores')
        .select('id, name, cash_balance')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;
      setStoreId(data.id);
      setStoreName(data.name);
      setCashBalance(data.cash_balance);
      setIsActive(data.cash_balance >= 10000);
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      alert('업체 정보를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStoreInfo();
  }, [fetchStoreInfo]);

  const handleCharge = async () => {
    const amount = customAmount ? parseInt(customAmount) : selectedAmount;
    if (!amount || amount < 1000) {
      alert('1,000원 이상 충전해주세요.');
      return;
    }
    if (amount % 1000 !== 0) {
      alert('1,000원 단위로 입력해주세요.');
      return;
    }

    try {
      setLoading(true);
      const { error } = await supabase.rpc('charge_store_cash', {
        p_store_id: storeId,
        p_amount: amount,
        p_description: '캐시 충전',
      });

      if (error) throw error;
      alert('충전이 완료되었습니다.');
      fetchStoreInfo();
      setCustomAmount('');
    } catch (error) {
      console.error('충전 오류:', error);
      alert('충전에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>💚 Save It</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView}>
        {/* 활성화 상태 */}
        <View style={styles.statusCard}>
          <View style={styles.statusLeft}>
            <View style={styles.logoCircle}>
              <Text style={styles.logoText}>🏪</Text>
            </View>
            <View>
              <Text style={styles.storeName}>{storeName || '업체명 없음'}</Text>
              <Text style={styles.statusLabel}>영업 상태: {isActive ? '운영 중' : '준비중'}</Text>
            </View>
          </View>
          <Switch
            value={isActive}
            disabled={true}
            trackColor={{ false: '#D0D0D0', true: '#00D563' }}
            thumbColor="#FFF"
          />
          <Text style={styles.statusBadge}>{isActive ? '활성화' : '비활성'}</Text>
        </View>

        {/* 잔액 카드 */}
        <View style={styles.balanceCard}>
          <Text style={styles.balanceAmount}>{cashBalance.toLocaleString()}원</Text>
          <Text style={styles.balanceLabel}>현재 보유 캐시</Text>
        </View>

        {/* 경고 메시지 */}
        {cashBalance < 10000 && (
          <View style={styles.warningBox}>
            <Text style={styles.warningIcon}>⚠️</Text>
            <View style={{ flex: 1 }}>
              <Text style={styles.warningTitle}>캐시 잔액이 1만원 미만입니다.</Text>
              <Text style={styles.warningText}>
                충전하시면 가게 목록에서 비활성화 처리될 수 있습니다.
              </Text>
            </View>
          </View>
        )}

        {/* 캐시 충전 */}
        <Text style={styles.sectionTitle}>캐시 충전</Text>
        <View style={styles.quickAmountRow}>
          {QUICK_AMOUNTS.map((amt) => (
            <TouchableOpacity
              key={amt}
              style={[
                styles.quickAmountButton,
                selectedAmount === amt && styles.quickAmountButtonActive,
              ]}
              onPress={() => {
                setSelectedAmount(amt);
                setCustomAmount('');
              }}
            >
              <Text style={styles.quickAmountLabel}>{amt / 10000}만</Text>
              <Text
                style={[
                  styles.quickAmountValue,
                  selectedAmount === amt && styles.quickAmountValueActive,
                ]}
              >
                {amt.toLocaleString()}원
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* 직접 입력 */}
        <View style={styles.customInputContainer}>
          <TextInput
            style={styles.customInput}
            value={customAmount}
            onChangeText={(val) => {
              setCustomAmount(val);
              setSelectedAmount(null);
            }}
            placeholder="직접 입력"
            placeholderTextColor="#999"
            keyboardType="numeric"
          />
          <Text style={styles.customInputUnit}>원</Text>
        </View>

        {/* 충전하기 버튼 */}
        <TouchableOpacity style={styles.submitButton} onPress={handleCharge}>
          <Text style={styles.submitButtonText}>캐시 충전하기</Text>
        </TouchableOpacity>

        {/* 내역 버튼 */}
        <TouchableOpacity style={styles.historyButton} onPress={onViewHistory}>
          <Text style={styles.historyIcon}>🔄</Text>
          <Text style={styles.historyText}>캐시 사용 및 충전 내역</Text>
          <Text style={styles.arrow}>›</Text>
        </TouchableOpacity>

        {/* 안내 */}
        <View style={styles.infoBox}>
          <Text style={styles.infoIcon}>ℹ️</Text>
          <Text style={styles.infoText}>
            예약 완료 시 상품 금액의 15%가 캐시에서 수수료로 차감됩니다. 캐시 잔액이 부족할 경우 예약 접수가 중단되오니 충전 금액을 확인해 주세요.
          </Text>
        </View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 20 },
  statusCard: { backgroundColor: '#FFF', padding: 20, borderRadius: 16, marginBottom: 15, flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' },
  statusLeft: { flexDirection: 'row', alignItems: 'center', gap: 12, flex: 1 },
  logoCircle: { width: 50, height: 50, borderRadius: 25, backgroundColor: '#E8F5E9', justifyContent: 'center', alignItems: 'center' },
  logoText: { fontSize: 24 },
  storeName: { fontSize: 16, fontWeight: '600', color: '#333', marginBottom: 4 },
  statusLabel: { fontSize: 13, color: '#666' },
  statusBadge: { position: 'absolute', top: 10, right: 10, fontSize: 12, color: '#00D563', fontWeight: '600' },
  balanceCard: { backgroundColor: '#00D563', padding: 24, borderRadius: 16, marginBottom: 15 },
  balanceAmount: { fontSize: 36, fontWeight: 'bold', color: '#FFF', marginBottom: 8 },
  balanceLabel: { fontSize: 14, color: 'rgba(255,255,255,0.8)' },
  chargeButton: { position: 'absolute', bottom: 24, right: 24, backgroundColor: 'rgba(255,255,255,0.3)', paddingHorizontal: 16, paddingVertical: 8, borderRadius: 20 },
  chargeButtonText: { color: '#FFF', fontSize: 13, fontWeight: '600' },
  warningBox: { backgroundColor: '#FFF4E5', padding: 16, borderRadius: 12, marginBottom: 20, flexDirection: 'row', alignItems: 'flex-start', gap: 12 },
  warningIcon: { fontSize: 20 },
  warningTitle: { fontSize: 14, fontWeight: '600', color: '#FF6B00', marginBottom: 4 },
  warningText: { fontSize: 13, color: '#666', lineHeight: 18 },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 15 },
  quickAmountRow: { flexDirection: 'row', gap: 12, marginBottom: 15 },
  quickAmountButton: { flex: 1, backgroundColor: '#FFF', padding: 16, borderRadius: 12, borderWidth: 1, borderColor: '#E0E0E0', alignItems: 'center' },
  quickAmountButtonActive: { borderWidth: 2, borderColor: '#00D563', backgroundColor: '#E8F5E9' },
  quickAmountLabel: { fontSize: 13, color: '#666', marginBottom: 4 },
  quickAmountValue: { fontSize: 15, fontWeight: '600', color: '#333' },
  quickAmountValueActive: { color: '#00D563' },
  customInputContainer: { position: 'relative', marginBottom: 20 },
  customInput: { backgroundColor: '#FFF', borderRadius: 12, padding: 16, paddingRight: 50, fontSize: 15, color: '#333', borderWidth: 1, borderColor: '#E0E0E0' },
  customInputUnit: { position: 'absolute', right: 16, top: 16, fontSize: 15, color: '#999' },
  submitButton: { backgroundColor: '#00D563', paddingVertical: 16, borderRadius: 12, alignItems: 'center', marginBottom: 15 },
  submitButtonText: { color: '#FFF', fontSize: 16, fontWeight: '600' },
  historyButton: { backgroundColor: '#FFF', padding: 18, borderRadius: 12, flexDirection: 'row', alignItems: 'center', marginBottom: 20, borderWidth: 1, borderColor: '#E0E0E0' },
  historyIcon: { fontSize: 24, marginRight: 12 },
  historyText: { flex: 1, fontSize: 15, fontWeight: '600', color: '#333' },
  arrow: { fontSize: 24, color: '#999' },
  infoBox: { backgroundColor: '#F9F9F9', padding: 16, borderRadius: 12, flexDirection: 'row', alignItems: 'flex-start', gap: 12 },
  infoIcon: { fontSize: 18 },
  infoText: { flex: 1, fontSize: 13, color: '#666', lineHeight: 18 },
});
</file>

<file path="app/src/screens/StoreDashboard.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
    ActivityIndicator,
    ScrollView,
    StyleSheet,
    Switch,
    Text,
    TouchableOpacity,
    View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreDashboardProps {
  onManageProducts: () => void;
  onManageCash: () => void;
  onManageReservations: () => void;
  onManageInfo: () => void;
  onManageReviews: () => void;
  onManageRegulars: () => void;
  onLogout: () => void;
}

interface StoreInfo {
  id: string;
  name: string;
  cash_balance: number;
  is_open: boolean;
}

export default function StoreDashboard({
  onManageProducts,
  onManageCash,
  onManageReservations,
  onManageInfo,
  onManageReviews,
  onManageRegulars,
  onLogout,
}: StoreDashboardProps) {
  const [store, setStore] = useState<StoreInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [isOpen, setIsOpen] = useState(false);

  // 업체 정보 가져오기
  const fetchStoreInfo = useCallback(async () => {
    try {
      setLoading(true);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('사용자 정보를 찾을 수 없습니다');

      const { data: storeData, error } = await supabase
        .from('stores')
        .select('id, name, cash_balance, is_open')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;

      setStore(storeData);
      setIsOpen(storeData.is_open);
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      alert('업체 정보를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStoreInfo();
  }, [fetchStoreInfo]);

  // 매장 상태 토글
  const toggleStoreStatus = async (value: boolean) => {
    try {
      if (!store) return;

      const { error } = await supabase
        .from('stores')
        .update({ is_open: value })
        .eq('id', store.id);

      if (error) throw error;

      setIsOpen(value);
      alert(value ? '매장이 영업 중으로 변경되었습니다.' : '매장이 영업 종료 상태로 변경되었습니다.');
    } catch (error) {
      console.error('매장 상태 변경 오류:', error);
      alert('매장 상태 변경에 실패했습니다.');
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  if (!store) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>업체 정보를 찾을 수 없습니다.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onLogout}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>🏪 Save It</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* 가게 정보 관리 카드 */}
        <TouchableOpacity style={styles.infoCard} onPress={onManageInfo}>
          <View style={styles.infoCardLeft}>
            <Text style={styles.infoCardIcon}>🏪</Text>
            <View>
              <Text style={styles.infoCardTitle}>가게 정보 관리</Text>
              <Text style={styles.infoCardSubtitle}>가게 사진, 운영시간 설정</Text>
            </View>
          </View>
          <Text style={styles.arrow}>›</Text>
        </TouchableOpacity>

        {/* 매장 상태 카드 */}
        <View style={styles.statusCard}>
          <View style={styles.statusRow}>
            <View style={styles.statusLeft}>
              <Text style={styles.statusDot}>●</Text>
              <Text style={styles.statusText}>매장 상태: {isOpen ? '영업 중' : '영업 종료'}</Text>
            </View>
            <Switch
              value={isOpen}
              onValueChange={toggleStoreStatus}
              trackColor={{ false: '#D0D0D0', true: '#00D563' }}
              thumbColor="#FFFFFF"
              ios_backgroundColor="#D0D0D0"
            />
          </View>
        </View>

        {/* 보유 캐시 카드 */}
        <View style={styles.cashCard}>
          <Text style={styles.cashLabel}>나의 자산</Text>
          <Text style={styles.cashAmount}>보유 캐시: {store.cash_balance.toLocaleString()}원</Text>
          <TouchableOpacity style={styles.chargeButton} onPress={onManageCash}>
            <Text style={styles.chargeButtonText}>충전하기</Text>
          </TouchableOpacity>
          <View style={styles.cashIconContainer}>
            <Text style={styles.cashIcon}>💵</Text>
          </View>
        </View>

        {/* 빠른 관리 섹션 */}
        <Text style={styles.sectionTitle}>빠른 관리</Text>

        <View style={styles.quickActionsGrid}>
          {/* 판매상품 관리 */}
          <TouchableOpacity style={styles.quickActionCard} onPress={onManageProducts}>
            <View style={styles.quickActionIconContainer}>
              <Text style={styles.quickActionIcon}>🛒</Text>
            </View>
            <Text style={styles.quickActionText}>판매상품 관리</Text>
          </TouchableOpacity>

          {/* 예약 확인하기 */}
          <TouchableOpacity style={styles.quickActionCard} onPress={onManageReservations}>
            <View style={styles.quickActionIconContainer}>
              <Text style={styles.quickActionIcon}>📅</Text>
            </View>
            <Text style={styles.quickActionText}>예약 확인하기</Text>
          </TouchableOpacity>

          {/* 리뷰 관리 */}
          <TouchableOpacity style={styles.quickActionCard} onPress={onManageReviews}>
            <View style={styles.quickActionIconContainer}>
              <Text style={styles.quickActionIcon}>💬</Text>
            </View>
            <Text style={styles.quickActionText}>리뷰 관리</Text>
          </TouchableOpacity>

          {/* 단골 고객 현황 */}
          <TouchableOpacity style={styles.quickActionCard} onPress={onManageRegulars}>
            <View style={styles.quickActionIconContainer}>
              <Text style={styles.quickActionIcon}>👥</Text>
            </View>
            <Text style={styles.quickActionText}>단골 고객 현황</Text>
          </TouchableOpacity>
        </View>

        {/* 하단 여백 */}
        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  // 가게 정보 관리 카드
  infoCard: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#E8F5E9',
    padding: 20,
    borderRadius: 16,
    marginBottom: 15,
    borderWidth: 1,
    borderColor: '#00D563',
  },
  infoCardLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 15,
  },
  infoCardIcon: {
    fontSize: 32,
  },
  infoCardTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  infoCardSubtitle: {
    fontSize: 13,
    color: '#666',
  },
  arrow: {
    fontSize: 28,
    color: '#00D563',
    fontWeight: '300',
  },

  // 매장 상태 카드
  statusCard: {
    backgroundColor: '#FFF',
    padding: 20,
    borderRadius: 16,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 3,
  },
  statusRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  statusLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  statusDot: {
    fontSize: 12,
    color: '#00D563',
  },
  statusText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },

  // 보유 캐시 카드
  cashCard: {
    backgroundColor: '#E8F5E9',
    padding: 24,
    borderRadius: 16,
    marginBottom: 30,
    position: 'relative',
    overflow: 'hidden',
  },
  cashLabel: {
    fontSize: 14,
    color: '#666',
    marginBottom: 8,
  },
  cashAmount: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 16,
  },
  chargeButton: {
    backgroundColor: '#00D563',
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    alignSelf: 'flex-start',
  },
  chargeButtonText: {
    color: '#FFF',
    fontSize: 15,
    fontWeight: '600',
  },
  cashIconContainer: {
    position: 'absolute',
    right: 20,
    top: '50%',
    marginTop: -30,
  },
  cashIcon: {
    fontSize: 60,
    opacity: 0.3,
  },

  // 섹션 타이틀
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 15,
  },

  // 빠른 관리 그리드
  quickActionsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
  },
  quickActionCard: {
    width: '48%',
    backgroundColor: '#FFF',
    padding: 20,
    borderRadius: 16,
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 3,
  },
  quickActionIconContainer: {
    width: 60,
    height: 60,
    backgroundColor: '#F5F5F5',
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 12,
  },
  quickActionIcon: {
    fontSize: 28,
  },
  quickActionText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    textAlign: 'center',
  },
});
</file>

<file path="app/src/screens/StoreDetail.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
  ActivityIndicator,
  Image,
  Linking,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreDetailProps {
  storeId: string;
  onReserve: (product: any) => void;
  onBack: () => void;
}

interface Store {
  id: string;
  name: string;
  category: string;
  description: string;
  address: string;
  phone: string;
  cover_image_url: string;
  logo_url: string;
  average_rating: number;
  review_count: number;
  opening_hours_text: string;
  pickup_start_time: string;
  pickup_end_time: string;
  refund_policy: string;
  no_show_policy: string;
}

interface Product {
  id: string;
  name: string;
  original_price: number;
  discounted_price: number;
  stock_quantity: number;
  image_url: string;
  description: string;
}

export default function StoreDetail({ storeId, onReserve, onBack }: StoreDetailProps) {
  const [store, setStore] = useState<Store | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);

  const fetchStoreDetails = useCallback(async () => {
    try {
      setLoading(true);

      // 업체 정보 가져오기
      const { data: storeData, error: storeError } = await supabase
        .from('stores')
        .select('*')
        .eq('id', storeId)
        .single();

      if (storeError) throw storeError;
      setStore(storeData);

      // 활성화된 상품 가져오기
      const { data: productsData, error: productsError } = await supabase
        .from('products')
        .select('*')
        .eq('store_id', storeId)
        .eq('is_active', true)
        .gt('stock_quantity', 0)
        .order('created_at', { ascending: false });

      if (productsError) throw productsError;
      setProducts(productsData || []);
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      alert('업체 정보를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, [storeId]);

  useEffect(() => {
    fetchStoreDetails();
  }, [fetchStoreDetails]);

  const handleCallStore = () => {
    if (store?.phone) {
      Linking.openURL(`tel:${store.phone}`);
    }
  };

  const calculateDiscount = (original: number, discounted: number) => {
    const discount = Math.round(((original - discounted) / original) * 100);
    return discount;
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#FF6B6B" />
      </View>
    );
  }

  if (!store) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorText}>업체를 찾을 수 없습니다.</Text>
        <TouchableOpacity style={styles.backButton} onPress={onBack}>
          <Text style={styles.backButtonText}>돌아가기</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* 커버 이미지 */}
        <View style={styles.coverContainer}>
          {store.cover_image_url ? (
            <Image
              source={{ uri: store.cover_image_url }}
              style={styles.coverImage}
              resizeMode="cover"
            />
          ) : (
            <View style={styles.coverPlaceholder}>
              <Text style={styles.coverPlaceholderText}>🏪</Text>
            </View>
          )}

          {/* 뒤로가기 버튼 */}
          <TouchableOpacity style={styles.backIconButton} onPress={onBack}>
            <Text style={styles.backIconText}>←</Text>
          </TouchableOpacity>

          {/* 업체 로고 */}
          <View style={styles.logoContainer}>
            {store.logo_url ? (
              <Image
                source={{ uri: store.logo_url }}
                style={styles.logoImage}
                resizeMode="cover"
              />
            ) : (
              <View style={styles.logoPlaceholder}>
                <Text style={styles.logoPlaceholderText}>🏪</Text>
              </View>
            )}
          </View>
        </View>

        {/* 업체 기본 정보 */}
        <View style={styles.infoContainer}>
          <View style={styles.headerRow}>
            <Text style={styles.storeName}>{store.name}</Text>
            <Text style={styles.category}>{store.category}</Text>
          </View>

          {/* 평점 및 리뷰 */}
          <View style={styles.ratingRow}>
            <Text style={styles.rating}>
              ⭐ {store.average_rating?.toFixed(1) || '0.0'}
            </Text>
            <Text style={styles.reviewCount}>리뷰 {store.review_count || 0}개</Text>
          </View>

          {/* 영업시간 */}
          <View style={styles.detailRow}>
            <Text style={styles.detailIcon}>🕒</Text>
            <Text style={styles.detailText}>
              {store.opening_hours_text || '영업시간 정보 없음'}
            </Text>
          </View>

          {/* 픽업 시간 */}
          <View style={styles.detailRow}>
            <Text style={styles.detailIcon}>📦</Text>
            <Text style={styles.detailText}>
              픽업 가능 시간: {store.pickup_start_time?.slice(0, 5)} - {store.pickup_end_time?.slice(0, 5)}
            </Text>
          </View>

          {/* 주소 */}
          <View style={styles.detailRow}>
            <Text style={styles.detailIcon}>📍</Text>
            <Text style={styles.detailText}>{store.address}</Text>
          </View>

          {/* 전화번호 */}
          {store.phone && (
            <TouchableOpacity style={styles.detailRow} onPress={handleCallStore}>
              <Text style={styles.detailIcon}>📞</Text>
              <Text style={[styles.detailText, styles.phoneText]}>{store.phone}</Text>
            </TouchableOpacity>
          )}

          {/* 업체 설명 */}
          {store.description && (
            <View style={styles.descriptionContainer}>
              <Text style={styles.descriptionTitle}>업체 소개</Text>
              <Text style={styles.descriptionText}>{store.description}</Text>
            </View>
          )}

          {/* 환불/노쇼 정책 */}
          <View style={styles.policyContainer}>
            <View style={styles.policyItem}>
              <Text style={styles.policyTitle}>💰 환불 정책</Text>
              <Text style={styles.policyText}>
                {store.refund_policy || '픽업 1시간 전까지 취소 가능하며, 전액 환불됩니다.'}
              </Text>
            </View>
            <View style={styles.policyItem}>
              <Text style={styles.policyTitle}>⚠️ 노쇼 정책</Text>
              <Text style={styles.policyText}>
                {store.no_show_policy || '노쇼 시 다음 예약이 제한될 수 있습니다.'}
              </Text>
            </View>
          </View>
        </View>

        {/* 구분선 */}
        <View style={styles.divider} />

        {/* 상품 리스트 */}
        <View style={styles.productsContainer}>
          <Text style={styles.productsTitle}>할인 상품 ({products.length})</Text>

          {products.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>현재 판매 중인 상품이 없습니다.</Text>
            </View>
          ) : (
            products.map((product) => (
              <TouchableOpacity
                key={product.id}
                style={styles.productCard}
                onPress={() => onReserve(product)}
              >
                {/* 상품 이미지 */}
                <View style={styles.productImageContainer}>
                  {product.image_url ? (
                    <Image
                      source={{ uri: product.image_url }}
                      style={styles.productImage}
                      resizeMode="cover"
                    />
                  ) : (
                    <View style={styles.productImagePlaceholder}>
                      <Text style={styles.productImagePlaceholderText}>🍞</Text>
                    </View>
                  )}

                  {/* 할인율 뱃지 */}
                  <View style={styles.discountBadge}>
                    <Text style={styles.discountBadgeText}>
                      {calculateDiscount(product.original_price, product.discounted_price)}% ↓
                    </Text>
                  </View>
                </View>

                {/* 상품 정보 */}
                <View style={styles.productInfo}>
                  <Text style={styles.productName}>{product.name}</Text>
                  {product.description && (
                    <Text style={styles.productDescription} numberOfLines={2}>
                      {product.description}
                    </Text>
                  )}

                  <View style={styles.priceRow}>
                    <Text style={styles.originalPrice}>
                      {product.original_price.toLocaleString()}원
                    </Text>
                    <Text style={styles.discountedPrice}>
                      {product.discounted_price.toLocaleString()}원
                    </Text>
                  </View>

                  <View style={styles.stockRow}>
                    <Text style={styles.stockText}>재고: {product.stock_quantity}개</Text>
                    <View style={styles.reserveButton}>
                      <Text style={styles.reserveButtonText}>예약하기 →</Text>
                    </View>
                  </View>
                </View>
              </TouchableOpacity>
            ))
          )}
        </View>

        {/* 하단 여백 */}
        <View style={{ height: 30 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  scrollView: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    padding: 20,
  },
  errorText: {
    fontSize: 16,
    color: '#666',
    marginBottom: 20,
  },
  backButton: {
    backgroundColor: '#FF6B6B',
    paddingHorizontal: 30,
    paddingVertical: 12,
    borderRadius: 8,
  },
  backButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },

  // 커버 이미지 영역
  coverContainer: {
    position: 'relative',
    height: 200,
    backgroundColor: '#E0E0E0',
  },
  coverImage: {
    width: '100%',
    height: '100%',
  },
  coverPlaceholder: {
    width: '100%',
    height: '100%',
    backgroundColor: '#FFE5E5',
    justifyContent: 'center',
    alignItems: 'center',
  },
  coverPlaceholderText: {
    fontSize: 60,
  },
  backIconButton: {
    position: 'absolute',
    top: 40,
    left: 20,
    width: 40,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  backIconText: {
    fontSize: 24,
    color: '#333',
  },
  logoContainer: {
    position: 'absolute',
    bottom: -40,
    left: 20,
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#FFF',
    borderWidth: 3,
    borderColor: '#FFF',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  logoImage: {
    width: '100%',
    height: '100%',
    borderRadius: 40,
  },
  logoPlaceholder: {
    width: '100%',
    height: '100%',
    borderRadius: 40,
    backgroundColor: '#FFE5E5',
    justifyContent: 'center',
    alignItems: 'center',
  },
  logoPlaceholderText: {
    fontSize: 32,
  },

  // 업체 정보 영역
  infoContainer: {
    backgroundColor: '#FFF',
    paddingTop: 50,
    paddingHorizontal: 20,
    paddingBottom: 20,
  },
  headerRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 8,
  },
  storeName: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginRight: 10,
  },
  category: {
    fontSize: 14,
    color: '#FFF',
    backgroundColor: '#FF6B6B',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    overflow: 'hidden',
  },
  ratingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
  },
  rating: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginRight: 8,
  },
  reviewCount: {
    fontSize: 14,
    color: '#999',
  },
  detailRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  detailIcon: {
    fontSize: 18,
    marginRight: 10,
    width: 24,
  },
  detailText: {
    fontSize: 15,
    color: '#666',
    flex: 1,
  },
  phoneText: {
    color: '#007AFF',
    textDecorationLine: 'underline',
  },
  descriptionContainer: {
    marginTop: 15,
    paddingTop: 15,
    borderTopWidth: 1,
    borderTopColor: '#F0F0F0',
  },
  descriptionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  descriptionText: {
    fontSize: 14,
    color: '#666',
    lineHeight: 22,
  },
  policyContainer: {
    marginTop: 15,
    backgroundColor: '#F9F9F9',
    borderRadius: 12,
    padding: 15,
  },
  policyItem: {
    marginBottom: 12,
  },
  policyTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  policyText: {
    fontSize: 13,
    color: '#666',
    lineHeight: 18,
  },

  // 구분선
  divider: {
    height: 8,
    backgroundColor: '#F0F0F0',
  },

  // 상품 리스트 영역
  productsContainer: {
    backgroundColor: '#FFF',
    paddingTop: 20,
    paddingHorizontal: 20,
  },
  productsTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 15,
  },
  emptyContainer: {
    paddingVertical: 40,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 15,
    color: '#999',
  },
  productCard: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    marginBottom: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 8,
    elevation: 3,
    overflow: 'hidden',
  },
  productImageContainer: {
    position: 'relative',
    width: '100%',
    height: 200,
  },
  productImage: {
    width: '100%',
    height: '100%',
  },
  productImagePlaceholder: {
    width: '100%',
    height: '100%',
    backgroundColor: '#F5F5F5',
    justifyContent: 'center',
    alignItems: 'center',
  },
  productImagePlaceholderText: {
    fontSize: 60,
  },
  discountBadge: {
    position: 'absolute',
    top: 12,
    right: 12,
    backgroundColor: '#FF6B6B',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 3,
  },
  discountBadgeText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: 'bold',
  },
  productInfo: {
    padding: 16,
  },
  productName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 6,
  },
  productDescription: {
    fontSize: 14,
    color: '#999',
    marginBottom: 10,
    lineHeight: 20,
  },
  priceRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 10,
  },
  originalPrice: {
    fontSize: 15,
    color: '#999',
    textDecorationLine: 'line-through',
    marginRight: 10,
  },
  discountedPrice: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#FF6B6B',
  },
  stockRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  stockText: {
    fontSize: 14,
    color: '#666',
  },
  reserveButton: {
    backgroundColor: '#FF6B6B',
    paddingHorizontal: 20,
    paddingVertical: 8,
    borderRadius: 20,
  },
  reserveButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreInfoManagement.tsx">
import { decode } from 'base64-arraybuffer';
import * as FileSystem from 'expo-file-system/legacy';
import * as ImagePicker from 'expo-image-picker';
import React, { useCallback, useEffect, useState } from 'react';
import {
  ActivityIndicator,
  Image,
  Modal,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreInfoManagementProps {
  onBack: () => void;
  onManageProducts: () => void;
}

interface DaySchedule {
  day: string;
  dayShort: string;
  startTime: string;
  endTime: string;
  enabled: boolean;
}

const DAYS: { day: string; dayShort: string }[] = [
  { day: '월', dayShort: 'mon' },
  { day: '화', dayShort: 'tue' },
  { day: '수', dayShort: 'wed' },
  { day: '목', dayShort: 'thu' },
  { day: '금', dayShort: 'fri' },
  { day: '토', dayShort: 'sat' },
  { day: '일', dayShort: 'sun' },
];

const CATEGORIES = ['반찬', '제과', '식자재', '밀키트'];

export default function StoreInfoManagement({ onBack, onManageProducts }: StoreInfoManagementProps) {
  const [loading, setLoading] = useState(true);
  const [storeId, setStoreId] = useState('');

  const [coverImage, setCoverImage] = useState<any>(null);
  const [coverImageUrl, setCoverImageUrl] = useState('');
  const [storeName, setStoreName] = useState('');
  const [storeDescription, setStoreDescription] = useState('');
  const [category, setCategory] = useState('');
  const [showCategoryModal, setShowCategoryModal] = useState(false);
  const [refundPolicy, setRefundPolicy] = useState('');
  const [noShowPolicy, setNoShowPolicy] = useState('');

  const [schedule, setSchedule] = useState<DaySchedule[]>(
    DAYS.map(({ day, dayShort }) => ({
      day,
      dayShort,
      startTime: '09:00',
      endTime: '09:00',
      enabled: false,
    }))
  );

  const fetchStoreInfo = useCallback(async () => {
    try {
      setLoading(true);

      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('사용자 정보를 찾을 수 없습니다');

      const { data: storeData, error } = await supabase
        .from('stores')
        .select('*')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;

      setStoreId(storeData.id);
      setStoreName(storeData.name || '');
      setStoreDescription(storeData.description || '');
      setCategory(storeData.category || '');
      setCoverImageUrl(storeData.cover_image_url || '');
      setRefundPolicy(
        storeData.refund_policy || '픽업 1시간 전까지 취소 가능하며, 전액 환불됩니다.'
      );
      setNoShowPolicy(
        storeData.no_show_policy || '노쇼 시 다음 예약이 제한될 수 있습니다.'
      );

      if (storeData.opening_hours) {
        const loadedSchedule = DAYS.map(({ day, dayShort }) => {
          const dayData = storeData.opening_hours[dayShort];
          if (dayData) {
            return {
              day,
              dayShort,
              startTime: dayData.start || '09:00',
              endTime: dayData.end || '09:00',
              enabled: dayData.enabled || false,
            };
          }
          return {
            day,
            dayShort,
            startTime: '09:00',
            endTime: '09:00',
            enabled: false,
          };
        });
        setSchedule(loadedSchedule);
      }
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      alert('업체 정보를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStoreInfo();
  }, [fetchStoreInfo]);

  const pickCoverImage = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      alert('사진 접근 권한이 필요합니다.');
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [16, 9],
      quality: 0.8,
    });

    if (!result.canceled) {
      setCoverImage(result.assets[0]);
    }
  };

  const toggleDay = (index: number) => {
    const newSchedule = [...schedule];
    newSchedule[index].enabled = !newSchedule[index].enabled;
    setSchedule(newSchedule);
  };

  const updateTime = (index: number, type: 'start' | 'end', value: string) => {
    const newSchedule = [...schedule];
    if (type === 'start') {
      newSchedule[index].startTime = value;
    } else {
      newSchedule[index].endTime = value;
    }
    setSchedule(newSchedule);
  };

  const handleSave = async () => {
    try {
      if (!storeName.trim()) {
        alert('가게명을 입력해주세요.');
        return;
      }
      if (!category) {
        alert('카테고리를 선택해주세요.');
        return;
      }

      setLoading(true);

      let finalCoverUrl = coverImageUrl;
      if (coverImage) {
        const fileExt = coverImage.uri.split('.').pop();
        const fileName = `${storeId}-cover-${Date.now()}.${fileExt}`;
        const filePath = `covers/${fileName}`;

        const base64 = await FileSystem.readAsStringAsync(coverImage.uri, {
          encoding: 'base64',
        });

        const { error: uploadError } = await supabase.storage
          .from('store-documents')
          .upload(filePath, decode(base64), {
            contentType: `image/${fileExt}`,
            upsert: true,
          });

        if (uploadError) throw uploadError;

        const { data: urlData } = supabase.storage
          .from('store-documents')
          .getPublicUrl(filePath);

        finalCoverUrl = urlData.publicUrl;
      }

      const openingHours: any = {};
      schedule.forEach((item) => {
        openingHours[item.dayShort] = {
          start: item.startTime,
          end: item.endTime,
          enabled: item.enabled,
        };
      });

      const { error } = await supabase
        .from('stores')
        .update({
          name: storeName,
          description: storeDescription,
          category: category,
          cover_image_url: finalCoverUrl,
          opening_hours: openingHours,
          refund_policy: refundPolicy,
          no_show_policy: noShowPolicy,
        })
        .eq('id', storeId);

      if (error) throw error;

      alert('가게 정보가 저장되었습니다.');
      onBack();
    } catch (error) {
      console.error('저장 오류:', error);
      alert('저장에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>가게 정보 관리</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        <Text style={styles.sectionTitle}>대표 사진 추가</Text>
        <TouchableOpacity style={styles.imageUploadBox} onPress={pickCoverImage}>
          {coverImage || coverImageUrl ? (
            <Image
              source={{ uri: coverImage ? coverImage.uri : coverImageUrl }}
              style={styles.uploadedImage}
              resizeMode="cover"
            />
          ) : (
            <View style={styles.imageUploadPlaceholder}>
              <Text style={styles.imageUploadIcon}>📷+</Text>
              <Text style={styles.imageUploadText}>상품 사진 추가</Text>
            </View>
          )}
        </TouchableOpacity>

        <Text style={styles.sectionTitle}>가게 정보</Text>

        <Text style={styles.label}>가게명</Text>
        <TextInput
          style={styles.input}
          value={storeName}
          onChangeText={setStoreName}
          placeholder="예: 세이브잇 베이커리 성수점"
          placeholderTextColor="#999"
        />

        <Text style={styles.label}>카테고리</Text>
        <TouchableOpacity
          style={styles.categorySelector}
          onPress={() => setShowCategoryModal(true)}
        >
          <Text style={category ? styles.categorySelectorText : styles.categorySelectorPlaceholder}>
            {category || '카테고리 선택'}
          </Text>
          <Text style={styles.categorySelectorArrow}>▼</Text>
        </TouchableOpacity>

        <Text style={styles.label}>가게 소개글</Text>
        <TextInput
          style={[styles.input, styles.textarea]}
          value={storeDescription}
          onChangeText={setStoreDescription}
          placeholder="매일 아침 신선한 새로운 성수를 다룹 빵을 굽습니다. 남은 빵은 'Save It'을 통해 할인된 가격에 제공하고 있으니 맛은 관심부탁드립니다!"
          placeholderTextColor="#999"
          multiline
          numberOfLines={4}
        />

        <TouchableOpacity style={styles.productManageButton} onPress={onManageProducts}>
          <View style={styles.productManageLeft}>
            <Text style={styles.productManageIcon}>🛒</Text>
            <Text style={styles.productManageText}>판매상품 관리</Text>
          </View>
          <Text style={styles.arrow}>›</Text>
        </TouchableOpacity>

        <Text style={styles.sectionTitle}>운영 및 정책 관리</Text>

        <View style={styles.scheduleBox}>
          <View style={styles.scheduleHeader}>
            <Text style={styles.scheduleIcon}>🕐</Text>
            <Text style={styles.scheduleTitle}>오픈일 운영시간 설정</Text>
          </View>

          <View style={styles.scheduleTableHeader}>
            <Text style={[styles.scheduleTableCell, { flex: 1 }]}>요일</Text>
            <Text style={[styles.scheduleTableCell, { flex: 2 }]}>운영 시간 (시작 ~ 종료)</Text>
            <Text style={[styles.scheduleTableCell, { flex: 1 }]}>휴무</Text>
          </View>

          {schedule.map((item, index) => (
            <View key={item.dayShort} style={styles.scheduleRow}>
              <Text style={[styles.scheduleCell, { flex: 1 }]}>{item.day}</Text>
              <View style={[styles.scheduleCell, styles.scheduleTimeCell, { flex: 2 }]}>
                <TextInput
                  style={styles.timeInput}
                  value={item.startTime}
                  onChangeText={(value) => updateTime(index, 'start', value)}
                  placeholder="09:00"
                  placeholderTextColor="#999"
                />
                <Text style={styles.timeSeparator}>~</Text>
                <TextInput
                  style={styles.timeInput}
                  value={item.endTime}
                  onChangeText={(value) => updateTime(index, 'end', value)}
                  placeholder="09:00"
                  placeholderTextColor="#999"
                />
              </View>
              <TouchableOpacity
                style={[styles.scheduleCell, { flex: 1 }]}
                onPress={() => toggleDay(index)}
              >
                <View
                  style={[
                    styles.checkbox,
                    item.enabled && styles.checkboxChecked,
                  ]}
                >
                  {item.enabled && <Text style={styles.checkmark}>✓</Text>}
                </View>
              </TouchableOpacity>
            </View>
          ))}
        </View>

        <Text style={styles.sectionTitle}>환불/교환/노쇼 정책</Text>

        <Text style={styles.policyLabel}>환불 정책</Text>
        <TextInput
          style={[styles.input, styles.textarea]}
          value={refundPolicy}
          onChangeText={setRefundPolicy}
          multiline
          numberOfLines={3}
          placeholderTextColor="#999"
        />

        <Text style={styles.policyLabel}>노쇼 정책</Text>
        <TextInput
          style={[styles.input, styles.textarea]}
          value={noShowPolicy}
          onChangeText={setNoShowPolicy}
          multiline
          numberOfLines={3}
          placeholderTextColor="#999"
        />

        <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
          <Text style={styles.saveButtonText}>✓ 변경사항 저장하기</Text>
        </TouchableOpacity>

        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 카테고리 선택 모달 */}
      <Modal
        visible={showCategoryModal}
        transparent
        animationType="fade"
        onRequestClose={() => setShowCategoryModal(false)}
      >
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setShowCategoryModal(false)}
        >
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>카테고리 선택</Text>
            {CATEGORIES.map((cat) => (
              <TouchableOpacity
                key={cat}
                style={styles.modalItem}
                onPress={() => {
                  setCategory(cat);
                  setShowCategoryModal(false);
                }}
              >
                <Text style={styles.modalItemText}>{cat}</Text>
                {category === cat && <Text style={styles.modalItemCheck}>✓</Text>}
              </TouchableOpacity>
            ))}
          </View>
        </TouchableOpacity>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 15,
  },

  imageUploadBox: {
    width: '100%',
    height: 200,
    backgroundColor: '#E8F5E9',
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 20,
  },
  uploadedImage: {
    width: '100%',
    height: '100%',
  },
  imageUploadPlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  imageUploadIcon: {
    fontSize: 40,
    marginBottom: 8,
  },
  imageUploadText: {
    fontSize: 15,
    color: '#666',
  },

  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 15,
  },
  textarea: {
    height: 100,
    textAlignVertical: 'top',
  },

  categorySelector: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 15,
  },
  categorySelectorText: {
    fontSize: 15,
    color: '#333',
  },
  categorySelectorPlaceholder: {
    fontSize: 15,
    color: '#999',
  },
  categorySelectorArrow: {
    fontSize: 12,
    color: '#999',
  },

  productManageButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    padding: 18,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 20,
  },
  productManageLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  productManageIcon: {
    fontSize: 24,
  },
  productManageText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
  },
  arrow: {
    fontSize: 24,
    color: '#999',
  },

  scheduleBox: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    padding: 20,
    marginBottom: 20,
  },
  scheduleHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    marginBottom: 15,
  },
  scheduleIcon: {
    fontSize: 24,
  },
  scheduleTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
  },
  scheduleTableHeader: {
    flexDirection: 'row',
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  scheduleTableCell: {
    fontSize: 13,
    fontWeight: '600',
    color: '#666',
    textAlign: 'center',
  },
  scheduleRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  scheduleCell: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  scheduleTimeCell: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  timeInput: {
    backgroundColor: '#F5F5F5',
    borderRadius: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    fontSize: 13,
    color: '#333',
    textAlign: 'center',
    flex: 1,
  },
  timeSeparator: {
    fontSize: 14,
    color: '#999',
  },
  checkbox: {
    width: 24,
    height: 24,
    borderWidth: 2,
    borderColor: '#D0D0D0',
    borderRadius: 6,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkboxChecked: {
    backgroundColor: '#00D563',
    borderColor: '#00D563',
  },
  checkmark: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: 'bold',
  },

  policyLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
    marginTop: 10,
  },

  saveButton: {
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 20,
  },
  saveButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },

  // 모달
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  modalContent: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    padding: 20,
    width: '80%',
    maxWidth: 300,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 15,
    textAlign: 'center',
  },
  modalItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#F0F0F0',
  },
  modalItemText: {
    fontSize: 16,
    color: '#333',
  },
  modalItemCheck: {
    fontSize: 18,
    color: '#00D563',
    fontWeight: 'bold',
  },
});
</file>

<file path="app/src/screens/StoreList.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import { FlatList, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface Store {
  id: string;
  name: string;
  address: string;
  average_rating: number;
}

export default function StoreListScreen({ onSelectStore }: { onSelectStore: (id: string) => void }) {
  const [stores, setStores] = useState<Store[]>([]);
  const [filteredStores, setFilteredStores] = useState<Store[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(true);

  const filterStores = useCallback(async () => {
    if (!searchQuery.trim()) {
      setFilteredStores(stores);
      return;
    }

    const query = searchQuery.toLowerCase().trim();

    try {
      // 1. 가게명 또는 주소로 매칭되는 업체
      const storeMatches = stores.filter(
        (store) =>
          store.name.toLowerCase().includes(query) ||
          store.address.toLowerCase().includes(query)
      );

      // 2. 상품명으로 매칭되는 업체
      const { data: productsData, error } = await supabase
        .from('products')
        .select('store_id')
        .ilike('name', `%${query}%`)
        .eq('is_active', true);

      if (error) throw error;

      // 상품명으로 매칭된 store_id 목록
      const productStoreIds = new Set(
        productsData?.map((p: any) => p.store_id) || []
      );

      // 상품명으로 매칭된 업체 추가
      const productMatches = stores.filter((store) =>
        productStoreIds.has(store.id)
      );

      // 중복 제거하고 합치기
      const allMatches = [...storeMatches];
      productMatches.forEach((store) => {
        if (!allMatches.find((s) => s.id === store.id)) {
          allMatches.push(store);
        }
      });

      setFilteredStores(allMatches);
    } catch (error) {
      console.error('검색 오류:', error);
      // 오류 발생 시 기본 검색(가게명/주소만)
      const storeMatches = stores.filter(
        (store) =>
          store.name.toLowerCase().includes(query) ||
          store.address.toLowerCase().includes(query)
      );
      setFilteredStores(storeMatches);
    }
  }, [searchQuery, stores]);

  useEffect(() => {
    loadStores();
  }, []);

  useEffect(() => {
    filterStores();
  }, [filterStores]);

  const loadStores = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('stores')
        .select('id, name, address, average_rating')
        .eq('is_approved', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      if (data) {
        setStores(data);
        setFilteredStores(data);
      }
    } catch (error: any) {
      console.error('업체 목록 로드 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const clearSearch = () => {
    setSearchQuery('');
  };

  const renderStore = ({ item }: { item: Store }) => (
    <TouchableOpacity style={styles.storeCard} onPress={() => onSelectStore(item.id)}>
      <View style={styles.storeHeader}>
        <Text style={styles.storeName}>{item.name}</Text>
        <View style={styles.ratingContainer}>
          <Text style={styles.ratingStar}>⭐</Text>
          <Text style={styles.ratingText}>{item.average_rating.toFixed(1)}</Text>
        </View>
      </View>
      <Text style={styles.address}>{item.address}</Text>
    </TouchableOpacity>
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>업체 목록</Text>
      </View>

      {/* 검색창 */}
      <View style={styles.searchContainer}>
        <TextInput
          style={styles.searchInput}
          placeholder="가게명, 주소, 상품명으로 검색..."
          value={searchQuery}
          onChangeText={setSearchQuery}
          autoCapitalize="none"
          autoCorrect={false}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity style={styles.clearButton} onPress={clearSearch}>
            <Text style={styles.clearButtonText}>✕</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* 검색 결과 안내 */}
      {searchQuery.length > 0 && (
        <View style={styles.resultInfo}>
          <Text style={styles.resultText}>
            {filteredStores.length}개의 업체가 검색되었습니다
          </Text>
        </View>
      )}

      {loading ? (
        <View style={styles.centerContainer}>
          <Text>로딩 중...</Text>
        </View>
      ) : filteredStores.length === 0 ? (
        <View style={styles.centerContainer}>
          <Text style={styles.emptyText}>
            {searchQuery.length > 0 ? '검색 결과가 없습니다' : '등록된 업체가 없습니다'}
          </Text>
          {searchQuery.length > 0 && (
            <TouchableOpacity style={styles.resetButton} onPress={clearSearch}>
              <Text style={styles.resetButtonText}>검색 초기화</Text>
            </TouchableOpacity>
          )}
        </View>
      ) : (
        <FlatList
          data={filteredStores}
          renderItem={renderStore}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  header: {
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 15,
    backgroundColor: '#F5F5F5',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  searchInput: {
    flex: 1,
    backgroundColor: '#FFFFFF',
    borderRadius: 8,
    paddingHorizontal: 15,
    paddingVertical: 12,
    fontSize: 16,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  clearButton: {
    marginLeft: 10,
    padding: 10,
    backgroundColor: '#E0E0E0',
    borderRadius: 20,
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  clearButtonText: {
    fontSize: 18,
    color: '#666',
    fontWeight: 'bold',
  },
  resultInfo: {
    padding: 10,
    backgroundColor: '#E3F2FD',
    borderBottomWidth: 1,
    borderBottomColor: '#BBDEFB',
  },
  resultText: {
    fontSize: 14,
    color: '#1976D2',
    textAlign: 'center',
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
    textAlign: 'center',
    marginBottom: 15,
  },
  resetButton: {
    backgroundColor: '#007AFF',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 8,
  },
  resetButtonText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
  listContent: {
    padding: 15,
  },
  storeCard: {
    backgroundColor: '#f9f9f9',
    padding: 15,
    borderRadius: 10,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#eee',
  },
  storeHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 8,
  },
  storeName: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF3E0',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 5,
  },
  ratingStar: {
    fontSize: 14,
    marginRight: 4,
  },
  ratingText: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#F57C00',
  },
  address: {
    fontSize: 14,
    color: '#666',
  },
});
</file>

<file path="app/src/screens/StoreListHome.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
  ActivityIndicator,
  Image,
  ScrollView,
  StyleSheet,
  Text,
  TouchableOpacity,
  View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreListHomeProps {
  onSelectStore: (id: string) => void;
  onViewReservations: () => void;
  onViewMyPage: () => void;
}

interface Store {
  id: string;
  name: string;
  category: string;
  address: string;
  cover_image_url: string;
  average_rating: number;
  review_count: number;
  cash_balance: number;
  is_open: boolean;
}

type SortType = 'recommended' | 'distance' | 'map';
type CategoryType = '전체' | '반찬' | '제과' | '식자재' | '밀키트';

const CATEGORIES: CategoryType[] = ['전체', '반찬', '제과', '식자재', '밀키트'];
const RATING_OPTIONS = [4.5, 4.0, 3.5, 3.0];

export default function StoreListHome({
  onSelectStore,
  onViewReservations,
  onViewMyPage,
}: StoreListHomeProps) {
  const [stores, setStores] = useState<Store[]>([]);
  const [filteredStores, setFilteredStores] = useState<Store[]>([]);
  const [loading, setLoading] = useState(true);

  const [selectedCategory, setSelectedCategory] = useState<CategoryType>('전체');
  const [selectedRating, setSelectedRating] = useState<number | null>(null);
  const [sortType, setSortType] = useState<SortType>('recommended');

  const [showRatingDropdown, setShowRatingDropdown] = useState(false);
  const [showSortDropdown, setShowSortDropdown] = useState(false);

  const [currentTab, setCurrentTab] = useState<'home' | 'reservations' | 'mypage'>('home');

  const fetchStores = useCallback(async () => {
    try {
      setLoading(true);

      const { data, error } = await supabase
        .from('stores')
        .select('*')
        .eq('is_approved', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setStores(data || []);
    } catch (error) {
      console.error('업체 목록 로딩 오류:', error);
      alert('업체 목록을 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStores();
  }, [fetchStores]);

  useEffect(() => {
    let result = [...stores];

    if (selectedCategory !== '전체') {
      result = result.filter((store) => store.category === selectedCategory);
    }

    if (selectedRating !== null) {
      result = result.filter((store) => store.average_rating >= selectedRating);
    }

    if (sortType === 'recommended') {
      result.sort((a, b) => b.review_count - a.review_count);
    } else if (sortType === 'distance') {
      result.sort((a, b) => a.name.localeCompare(b.name));
    }

    setFilteredStores(result);
  }, [stores, selectedCategory, selectedRating, sortType]);

  const isStoreClosed = (store: Store) => {
    if (store.cash_balance <= 10000) return true;
    if (store.is_open === false) return true;
    return false;
  };

  const calculateDiscount = () => {
    return 50;
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <Text style={styles.logo}>💚 Save It</Text>
      </View>

      {/* 카테고리 + 필터 통합 컨테이너 */}
      <View style={styles.filterContainer}>
        {/* 카테고리 탭 */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.categoryScrollView}
          contentContainerStyle={styles.categoryContent}
        >
          {CATEGORIES.map((category) => (
            <TouchableOpacity
              key={category}
              style={[
                styles.categoryTab,
                selectedCategory === category && styles.categoryTabActive,
              ]}
              onPress={() => setSelectedCategory(category)}
            >
              <Text
                style={[
                  styles.categoryText,
                  selectedCategory === category && styles.categoryTextActive,
                ]}
              >
                {category}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>

        {/* 필터 버튼 */}
        <View style={styles.filterRow}>
        <TouchableOpacity
          style={styles.filterButton}
          onPress={() => setShowSortDropdown(!showSortDropdown)}
        >
          <Text style={styles.filterButtonText}>
            {sortType === 'recommended'
              ? '추천순'
              : sortType === 'distance'
              ? '거리순'
              : '지도보기'}
            {' ▼'}
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.filterButtonWhite}
          onPress={() => setShowRatingDropdown(!showRatingDropdown)}
        >
          <Text style={styles.filterButtonTextDark}>
            ⭐ {selectedRating ? `★ ${selectedRating}` : '전체'}
          </Text>
        </TouchableOpacity>
      </View>
      </View>

      {/* 정렬 드롭다운 */}
      {showSortDropdown && (
        <View style={styles.dropdown}>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSortType('recommended');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>추천순</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSortType('distance');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>거리순</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              alert('지도 기능은 추후 구현 예정입니다.');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>지도보기</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* 별점 드롭다운 */}
      {showRatingDropdown && (
        <View style={styles.dropdownRating}>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSelectedRating(null);
              setShowRatingDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>전체</Text>
          </TouchableOpacity>
          {RATING_OPTIONS.map((rating) => (
            <TouchableOpacity
              key={rating}
              style={styles.dropdownItem}
              onPress={() => {
                setSelectedRating(rating);
                setShowRatingDropdown(false);
              }}
            >
              <Text style={styles.dropdownText}>⭐ {rating} 이상</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}

      {/* 업체 리스트 */}
      <ScrollView style={styles.storeList} showsVerticalScrollIndicator={false}>
        {filteredStores.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>조건에 맞는 업체가 없습니다.</Text>
          </View>
        ) : (
          filteredStores.map((store) => {
            const closed = isStoreClosed(store);
            return (
              <TouchableOpacity
                key={store.id}
                style={styles.storeCard}
                onPress={() => !closed && onSelectStore(store.id)}
                disabled={closed}
              >
                {/* 이미지 */}
                <View style={styles.imageContainer}>
                  {store.cover_image_url ? (
                    <Image
                      source={{ uri: store.cover_image_url }}
                      style={[styles.storeImage, closed && styles.storeImageClosed]}
                      resizeMode="cover"
                    />
                  ) : (
                    <View
                      style={[
                        styles.imagePlaceholder,
                        closed && styles.storeImageClosed,
                      ]}
                    >
                      <Text style={styles.imagePlaceholderText}>🏪</Text>
                    </View>
                  )}

                  {closed && (
                    <View style={styles.closedOverlay}>
                      <View style={styles.closedBadge}>
                        <Text style={styles.closedText}>준비중</Text>
                      </View>
                    </View>
                  )}

                  {!closed && (
                    <View style={styles.discountBadge}>
                      <Text style={styles.discountText}>~{calculateDiscount()}% 할인</Text>
                    </View>
                  )}

                  <TouchableOpacity style={styles.heartButton}>
                    <Text style={styles.heartIcon}>🤍</Text>
                  </TouchableOpacity>
                </View>

                {/* 업체 정보 */}
                <View style={styles.storeInfo}>
                  <Text style={styles.storeName} numberOfLines={1}>
                    {store.name}
                  </Text>
                  <View style={styles.ratingRow}>
                    <Text style={styles.rating}>⭐ {store.average_rating.toFixed(1)}</Text>
                    <Text style={styles.reviewCount}>리뷰 {store.review_count}</Text>
                  </View>
                  <Text style={styles.storeAddress} numberOfLines={1}>
                    {store.address}
                  </Text>
                </View>
              </TouchableOpacity>
            );
          })
        )}

        <View style={{ height: 100 }} />
      </ScrollView>

      {/* 하단 네비게이션 */}
      <View style={styles.bottomNav}>
        <TouchableOpacity
          style={styles.navItem}
          onPress={() => setCurrentTab('home')}
        >
          <Text style={styles.navIcon}>🏠</Text>
          <Text style={[styles.navText, currentTab === 'home' && styles.navTextActive]}>
            홈
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.navItem}
          onPress={() => {
            setCurrentTab('reservations');
            onViewReservations();
          }}
        >
          <Text style={styles.navIcon}>📦</Text>
          <Text
            style={[styles.navText, currentTab === 'reservations' && styles.navTextActive]}
          >
            주문/예약
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.navItem}
          onPress={() => {
            setCurrentTab('mypage');
            onViewMyPage();
          }}
        >
          <Text style={styles.navIcon}>👤</Text>
          <Text style={[styles.navText, currentTab === 'mypage' && styles.navTextActive]}>
            내 정보
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFF',
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  logo: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },

  // 카테고리 + 필터 통합 컨테이너
  filterContainer: {
    backgroundColor: '#FFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },

  // 카테고리 탭
  categoryScrollView: {
    flexGrow: 0,
  },
  categoryContent: {
    paddingHorizontal: 20,
    paddingTop: 12,
    paddingBottom: 12,
    gap: 8,
  },
  categoryTab: {
    paddingHorizontal: 16,
    paddingVertical: 6,
    borderRadius: 20,
    backgroundColor: '#FFF',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  categoryTabActive: {
    backgroundColor: '#00D563',
    borderColor: '#00D563',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  categoryTextActive: {
    color: '#FFF',
    fontWeight: '600',
  },

  // 필터 버튼
  filterRow: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingTop: 0,
    paddingBottom: 12,
    gap: 10,
  },
  filterButton: {
    backgroundColor: '#E8F5E9',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#00D563',
  },
  filterButtonText: {
    fontSize: 14,
    color: '#00A84D',
    fontWeight: '600',
  },
  filterButtonWhite: {
    backgroundColor: '#FFF',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  filterButtonTextDark: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },

  // 드롭다운
  dropdown: {
    position: 'absolute',
    top: 157,
    left: 20,
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
    minWidth: 120,
  },
  dropdownRating: {
    position: 'absolute',
    top: 157,
    right: 20,
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
    minWidth: 120,
  },
  dropdownItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  dropdownText: {
    fontSize: 14,
    color: '#333',
  },

  // 업체 리스트
  storeList: {
    flex: 1,
    backgroundColor: '#F5F5F5',
    paddingHorizontal: 20,
    paddingTop: 10,
  },
  emptyContainer: {
    paddingVertical: 60,
    alignItems: 'center',
  },
  emptyText: {
    fontSize: 15,
    color: '#999',
  },

  // 업체 카드
  storeCard: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    marginBottom: 20,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 3,
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: 200,
  },
  storeImage: {
    width: '100%',
    height: '100%',
  },
  storeImageClosed: {
    opacity: 0.4,
  },
  imagePlaceholder: {
    width: '100%',
    height: '100%',
    backgroundColor: '#E0E0E0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  imagePlaceholderText: {
    fontSize: 60,
  },

  // 준비중 오버레이
  closedOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  closedBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    paddingHorizontal: 30,
    paddingVertical: 12,
    borderRadius: 8,
  },
  closedText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 할인율 뱃지
  discountBadge: {
    position: 'absolute',
    bottom: 12,
    right: 12,
    backgroundColor: '#00D563',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  discountText: {
    color: '#FFF',
    fontSize: 13,
    fontWeight: 'bold',
  },

  // 하트 버튼
  heartButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 40,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  heartIcon: {
    fontSize: 22,
  },

  // 업체 정보
  storeInfo: {
    padding: 16,
  },
  storeName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 6,
  },
  ratingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  rating: {
    fontSize: 14,
    color: '#333',
    marginRight: 8,
    fontWeight: '600',
  },
  reviewCount: {
    fontSize: 13,
    color: '#999',
  },
  storeAddress: {
    fontSize: 13,
    color: '#999',
  },

  // 하단 네비게이션
  bottomNav: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
    paddingBottom: 20,
    paddingTop: 10,
  },
  navItem: {
    flex: 1,
    alignItems: 'center',
    paddingVertical: 8,
  },
  navIcon: {
    fontSize: 24,
    marginBottom: 4,
  },
  navText: {
    fontSize: 12,
    color: '#999',
  },
  navTextActive: {
    color: '#00D563',
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreListHomeWithSearch.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
    ActivityIndicator,
    Image,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreListHomeProps {
  onSelectStore: (id: string) => void;
  onViewReservations: () => void;
  onViewMyPage: () => void;
}

interface Store {
  id: string;
  name: string;
  category: string;
  address: string;
  cover_image_url: string;
  average_rating: number;
  review_count: number;
  cash_balance: number;
  is_open: boolean;
}

type SortType = 'recommended' | 'distance' | 'map';
type CategoryType = '전체' | '반찬' | '제과' | '식자재' | '밀키트';

const CATEGORIES: CategoryType[] = ['전체', '반찬', '제과', '식자재', '밀키트'];
const RATING_OPTIONS = [4.5, 4.0, 3.5, 3.0];

export default function StoreListHomeWithSearch({
  onSelectStore,
  onViewReservations,
  onViewMyPage,
}: StoreListHomeProps) {
  const [stores, setStores] = useState<Store[]>([]);
  const [filteredStores, setFilteredStores] = useState<Store[]>([]);
  const [loading, setLoading] = useState(true);

  // 검색어
  const [searchQuery, setSearchQuery] = useState('');

  const [selectedCategory, setSelectedCategory] = useState<CategoryType>('전체');
  const [selectedRating, setSelectedRating] = useState<number | null>(null);
  const [sortType, setSortType] = useState<SortType>('recommended');

  const [showRatingDropdown, setShowRatingDropdown] = useState(false);
  const [showSortDropdown, setShowSortDropdown] = useState(false);

  const [currentTab, setCurrentTab] = useState<'home' | 'reservations' | 'mypage'>('home');

  // 즐겨찾기 ID 목록
  const [favoriteIds, setFavoriteIds] = useState<string[]>([]);
  const [consumerId, setConsumerId] = useState<string>('');

  // 소비자 ID 가져오기
  useEffect(() => {
    const fetchConsumerId = async () => {
      try {
        const {
          data: { user },
        } = await supabase.auth.getUser();
        if (!user) return;

        const { data: consumerData } = await supabase
          .from('consumers')
          .select('id')
          .eq('user_id', user.id)
          .single();

        if (consumerData) {
          setConsumerId(consumerData.id);
        }
      } catch (error) {
        console.error('소비자 ID 가져오기 오류:', error);
      }
    };

    fetchConsumerId();
  }, []);

  // 즐겨찾기 목록 가져오기
  const fetchFavorites = useCallback(async () => {
    if (!consumerId) return;

    try {
      const { data, error } = await supabase
        .from('favorites')
        .select('store_id')
        .eq('consumer_id', consumerId);

      if (error) throw error;

      const ids = data?.map((fav) => fav.store_id) || [];
      setFavoriteIds(ids);
    } catch (error) {
      console.error('즐겨찾기 로딩 오류:', error);
    }
  }, [consumerId]);

  useEffect(() => {
    if (consumerId) {
      fetchFavorites();
    }
  }, [consumerId, fetchFavorites]);

  const fetchStores = useCallback(async () => {
    try {
      setLoading(true);

      const { data, error } = await supabase
        .from('stores')
        .select('*')
        .eq('is_approved', true)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setStores(data || []);
    } catch (error) {
      console.error('업체 목록 로딩 오류:', error);
      alert('업체 목록을 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchStores();
  }, [fetchStores]);

  // 필터링 및 검색
  useEffect(() => {
    let result = [...stores];

    // 검색어 필터링
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase().trim();
      result = result.filter(
        (store) =>
          store.name.toLowerCase().includes(query) ||
          store.address.toLowerCase().includes(query) ||
          store.category.toLowerCase().includes(query)
      );
    }

    // 카테고리 필터링
    if (selectedCategory !== '전체') {
      result = result.filter((store) => store.category === selectedCategory);
    }

    // 별점 필터링
    if (selectedRating !== null) {
      result = result.filter((store) => store.average_rating >= selectedRating);
    }

    // 정렬
    if (sortType === 'recommended') {
      result.sort((a, b) => b.review_count - a.review_count);
    } else if (sortType === 'distance') {
      result.sort((a, b) => a.name.localeCompare(b.name));
    }

    setFilteredStores(result);
  }, [stores, selectedCategory, selectedRating, sortType, searchQuery]);

  const isStoreClosed = (store: Store) => {
    if (store.cash_balance <= 10000) return true;
    if (store.is_open === false) return true;
    return false;
  };

  const calculateDiscount = () => {
    return 50;
  };

  // 즐겨찾기 토글
  const toggleFavorite = async (storeId: string, e: any) => {
    e.stopPropagation(); // 카드 클릭 이벤트 방지

    if (!consumerId) {
      alert('로그인이 필요합니다.');
      return;
    }

    try {
      const isFavorite = favoriteIds.includes(storeId);

      if (isFavorite) {
        // 즐겨찾기 제거
        const { error } = await supabase
          .from('favorites')
          .delete()
          .eq('consumer_id', consumerId)
          .eq('store_id', storeId);

        if (error) throw error;

        setFavoriteIds(favoriteIds.filter((id) => id !== storeId));
      } else {
        // 즐겨찾기 추가
        const { error } = await supabase.from('favorites').insert({
          consumer_id: consumerId,
          store_id: storeId,
        });

        if (error) throw error;

        setFavoriteIds([...favoriteIds, storeId]);
      }
    } catch (error) {
      console.error('즐겨찾기 오류:', error);
      alert('즐겨찾기 처리 중 오류가 발생했습니다.');
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <Text style={styles.logo}>💚 Save It</Text>
      </View>

      {/* 검색 바 */}
      <View style={styles.searchContainer}>
        <Text style={styles.searchIcon}>🔍</Text>
        <TextInput
          style={styles.searchInput}
          placeholder="업체명, 주소로 검색"
          placeholderTextColor="#999"
          value={searchQuery}
          onChangeText={setSearchQuery}
        />
        {searchQuery.length > 0 && (
          <TouchableOpacity onPress={() => setSearchQuery('')}>
            <Text style={styles.clearIcon}>✕</Text>
          </TouchableOpacity>
        )}
      </View>

      {/* 카테고리 + 필터 통합 컨테이너 */}
      <View style={styles.filterContainer}>
        {/* 카테고리 탭 */}
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.categoryScrollView}
          contentContainerStyle={styles.categoryContent}
        >
          {CATEGORIES.map((category) => (
            <TouchableOpacity
              key={category}
              style={[
                styles.categoryTab,
                selectedCategory === category && styles.categoryTabActive,
              ]}
              onPress={() => setSelectedCategory(category)}
            >
              <Text
                style={[
                  styles.categoryText,
                  selectedCategory === category && styles.categoryTextActive,
                ]}
              >
                {category}
              </Text>
            </TouchableOpacity>
          ))}
        </ScrollView>

        {/* 필터 버튼 */}
        <View style={styles.filterRow}>
          <TouchableOpacity
            style={styles.filterButton}
            onPress={() => setShowSortDropdown(!showSortDropdown)}
          >
            <Text style={styles.filterButtonText}>
              {sortType === 'recommended'
                ? '추천순'
                : sortType === 'distance'
                ? '거리순'
                : '지도보기'}
              {' ▼'}
            </Text>
          </TouchableOpacity>

          <TouchableOpacity
            style={styles.filterButtonWhite}
            onPress={() => setShowRatingDropdown(!showRatingDropdown)}
          >
            <Text style={styles.filterButtonTextDark}>
              ⭐ {selectedRating ? `★ ${selectedRating}` : '전체'}
            </Text>
          </TouchableOpacity>
        </View>
      </View>

      {/* 정렬 드롭다운 */}
      {showSortDropdown && (
        <View style={styles.dropdown}>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSortType('recommended');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>추천순</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSortType('distance');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>거리순</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              alert('지도 기능은 추후 구현 예정입니다.');
              setShowSortDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>지도보기</Text>
          </TouchableOpacity>
        </View>
      )}

      {/* 별점 드롭다운 */}
      {showRatingDropdown && (
        <View style={styles.dropdownRating}>
          <TouchableOpacity
            style={styles.dropdownItem}
            onPress={() => {
              setSelectedRating(null);
              setShowRatingDropdown(false);
            }}
          >
            <Text style={styles.dropdownText}>전체</Text>
          </TouchableOpacity>
          {RATING_OPTIONS.map((rating) => (
            <TouchableOpacity
              key={rating}
              style={styles.dropdownItem}
              onPress={() => {
                setSelectedRating(rating);
                setShowRatingDropdown(false);
              }}
            >
              <Text style={styles.dropdownText}>⭐ {rating} 이상</Text>
            </TouchableOpacity>
          ))}
        </View>
      )}

      {/* 검색 결과 개수 */}
      {searchQuery.trim().length > 0 && (
        <View style={styles.searchResultInfo}>
          <Text style={styles.searchResultText}>
            &apos;{searchQuery}&apos; 검색 결과: {filteredStores.length}개
          </Text>
        </View>
      )}

      {/* 업체 리스트 */}
      <ScrollView style={styles.storeList} showsVerticalScrollIndicator={false}>
        {filteredStores.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyIcon}>🔍</Text>
            <Text style={styles.emptyText}>
              {searchQuery.trim()
                ? '검색 결과가 없습니다.'
                : '조건에 맞는 업체가 없습니다.'}
            </Text>
          </View>
        ) : (
          filteredStores.map((store) => {
            const closed = isStoreClosed(store);
            const isFavorite = favoriteIds.includes(store.id);
            return (
              <TouchableOpacity
                key={store.id}
                style={styles.storeCard}
                onPress={() => !closed && onSelectStore(store.id)}
                disabled={closed}
              >
                {/* 이미지 */}
                <View style={styles.imageContainer}>
                  {store.cover_image_url ? (
                    <Image
                      source={{ uri: store.cover_image_url }}
                      style={[styles.storeImage, closed && styles.storeImageClosed]}
                      resizeMode="cover"
                    />
                  ) : (
                    <View
                      style={[
                        styles.imagePlaceholder,
                        closed && styles.storeImageClosed,
                      ]}
                    >
                      <Text style={styles.imagePlaceholderText}>🏪</Text>
                    </View>
                  )}

                  {closed && (
                    <View style={styles.closedOverlay}>
                      <View style={styles.closedBadge}>
                        <Text style={styles.closedText}>준비중</Text>
                      </View>
                    </View>
                  )}

                  {!closed && (
                    <View style={styles.discountBadge}>
                      <Text style={styles.discountText}>
                        ~{calculateDiscount()}% 할인
                      </Text>
                    </View>
                  )}

                  <TouchableOpacity
                    style={styles.heartButton}
                    onPress={(e) => toggleFavorite(store.id, e)}
                  >
                    <Text style={styles.heartIcon}>
                      {isFavorite ? '❤️' : '🤍'}
                    </Text>
                  </TouchableOpacity>
                </View>

                {/* 업체 정보 */}
                <View style={styles.storeInfo}>
                  <Text style={styles.storeName} numberOfLines={1}>
                    {store.name}
                  </Text>
                  <View style={styles.ratingRow}>
                    <Text style={styles.rating}>⭐ {store.average_rating.toFixed(1)}</Text>
                    <Text style={styles.reviewCount}>리뷰 {store.review_count}</Text>
                  </View>
                  <Text style={styles.storeAddress} numberOfLines={1}>
                    {store.address}
                  </Text>
                </View>
              </TouchableOpacity>
            );
          })
        )}

        <View style={{ height: 100 }} />
      </ScrollView>

      {/* 하단 네비게이션 */}
      <View style={styles.bottomNav}>
        <TouchableOpacity style={styles.navItem} onPress={() => setCurrentTab('home')}>
          <Text style={styles.navIcon}>🏠</Text>
          <Text style={[styles.navText, currentTab === 'home' && styles.navTextActive]}>
            홈
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.navItem}
          onPress={() => {
            setCurrentTab('reservations');
            onViewReservations();
          }}
        >
          <Text style={styles.navIcon}>📦</Text>
          <Text
            style={[styles.navText, currentTab === 'reservations' && styles.navTextActive]}
          >
            주문/예약
          </Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.navItem}
          onPress={() => {
            setCurrentTab('mypage');
            onViewMyPage();
          }}
        >
          <Text style={styles.navIcon}>👤</Text>
          <Text style={[styles.navText, currentTab === 'mypage' && styles.navTextActive]}>
            내 정보
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFF',
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  logo: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#333',
  },

  // 검색 바
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    marginHorizontal: 20,
    marginTop: 15,
    marginBottom: 10,
    paddingHorizontal: 15,
    paddingVertical: 12,
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  searchIcon: {
    fontSize: 18,
    marginRight: 10,
  },
  searchInput: {
    flex: 1,
    fontSize: 15,
    color: '#333',
  },
  clearIcon: {
    fontSize: 18,
    color: '#999',
    marginLeft: 10,
  },

  // 검색 결과 정보
  searchResultInfo: {
    paddingHorizontal: 20,
    paddingVertical: 8,
    backgroundColor: '#FFF',
  },
  searchResultText: {
    fontSize: 14,
    color: '#666',
  },

  // 카테고리 + 필터 통합 컨테이너
  filterContainer: {
    backgroundColor: '#FFF',
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },

  // 카테고리 탭
  categoryScrollView: {
    flexGrow: 0,
  },
  categoryContent: {
    paddingHorizontal: 20,
    paddingTop: 12,
    paddingBottom: 12,
    gap: 8,
  },
  categoryTab: {
    paddingHorizontal: 16,
    paddingVertical: 6,
    borderRadius: 20,
    backgroundColor: '#FFF',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  categoryTabActive: {
    backgroundColor: '#00D563',
    borderColor: '#00D563',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  categoryTextActive: {
    color: '#FFF',
    fontWeight: '600',
  },

  // 필터 버튼
  filterRow: {
    flexDirection: 'row',
    paddingHorizontal: 20,
    paddingTop: 0,
    paddingBottom: 12,
    gap: 10,
  },
  filterButton: {
    backgroundColor: '#E8F5E9',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#00D563',
  },
  filterButtonText: {
    fontSize: 14,
    color: '#00A84D',
    fontWeight: '600',
  },
  filterButtonWhite: {
    backgroundColor: '#FFF',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#DDD',
  },
  filterButtonTextDark: {
    fontSize: 14,
    color: '#333',
    fontWeight: '500',
  },

  // 드롭다운
  dropdown: {
    position: 'absolute',
    top: 220,
    left: 20,
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
    minWidth: 120,
  },
  dropdownRating: {
    position: 'absolute',
    top: 220,
    right: 20,
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 5,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 5,
    zIndex: 1000,
    minWidth: 120,
  },
  dropdownItem: {
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  dropdownText: {
    fontSize: 14,
    color: '#333',
  },

  // 업체 리스트
  storeList: {
    flex: 1,
    backgroundColor: '#F5F5F5',
    paddingHorizontal: 20,
    paddingTop: 10,
  },
  emptyContainer: {
    paddingVertical: 60,
    alignItems: 'center',
  },
  emptyIcon: {
    fontSize: 48,
    marginBottom: 12,
  },
  emptyText: {
    fontSize: 15,
    color: '#999',
  },

  // 업체 카드
  storeCard: {
    backgroundColor: '#FFF',
    borderRadius: 16,
    marginBottom: 20,
    overflow: 'hidden',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.08,
    shadowRadius: 8,
    elevation: 3,
  },
  imageContainer: {
    position: 'relative',
    width: '100%',
    height: 200,
  },
  storeImage: {
    width: '100%',
    height: '100%',
  },
  storeImageClosed: {
    opacity: 0.4,
  },
  imagePlaceholder: {
    width: '100%',
    height: '100%',
    backgroundColor: '#E0E0E0',
    justifyContent: 'center',
    alignItems: 'center',
  },
  imagePlaceholderText: {
    fontSize: 60,
  },

  // 준비중 오버레이
  closedOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  closedBadge: {
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    paddingHorizontal: 30,
    paddingVertical: 12,
    borderRadius: 8,
  },
  closedText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 할인율 뱃지
  discountBadge: {
    position: 'absolute',
    bottom: 12,
    right: 12,
    backgroundColor: '#00D563',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  discountText: {
    color: '#FFF',
    fontSize: 13,
    fontWeight: 'bold',
  },

  // 하트 버튼
  heartButton: {
    position: 'absolute',
    top: 12,
    right: 12,
    width: 40,
    height: 40,
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  heartIcon: {
    fontSize: 22,
  },

  // 업체 정보
  storeInfo: {
    padding: 16,
  },
  storeName: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginBottom: 6,
  },
  ratingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 6,
  },
  rating: {
    fontSize: 14,
    color: '#333',
    marginRight: 8,
    fontWeight: '600',
  },
  reviewCount: {
    fontSize: 13,
    color: '#999',
  },
  storeAddress: {
    fontSize: 13,
    color: '#999',
  },

  // 하단 네비게이션
  bottomNav: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    borderTopWidth: 1,
    borderTopColor: '#E0E0E0',
    paddingBottom: 20,
    paddingTop: 10,
  },
  navItem: {
    flex: 1,
    alignItems: 'center',
    paddingVertical: 8,
  },
  navIcon: {
    fontSize: 24,
    marginBottom: 4,
  },
  navText: {
    fontSize: 12,
    color: '#999',
  },
  navTextActive: {
    color: '#00D563',
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreOperatingHoursScreen.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    ScrollView,
    StyleSheet,
    Switch,
    Text,
    TouchableOpacity,
    View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreOperatingHoursScreenProps {
  onBack: () => void;
}

interface OperatingHour {
  id?: string;
  day_of_week: number;
  open_time: string;
  close_time: string;
  is_closed: boolean;
}

const DAYS = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];

export default function StoreOperatingHoursScreen({ onBack }: StoreOperatingHoursScreenProps) {
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [storeId, setStoreId] = useState('');
  const [operatingHours, setOperatingHours] = useState<OperatingHour[]>([]);

  const fetchStoreId = useCallback(async () => {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error('사용자 정보를 찾을 수 없습니다');

      const { data: storeData, error } = await supabase
        .from('stores')
        .select('id')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;
      return storeData.id;
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      throw error;
    }
  }, []);

  const fetchOperatingHours = useCallback(async (storeIdParam: string) => {
    try {
      const { data, error } = await supabase
        .from('store_operating_hours')
        .select('*')
        .eq('store_id', storeIdParam)
        .order('day_of_week', { ascending: true });

      if (error) throw error;

      // 기본값 설정 (데이터가 없으면)
      const defaultHours: OperatingHour[] = [];
      for (let i = 0; i < 7; i++) {
        const existing = data?.find((h: any) => h.day_of_week === i);
        if (existing) {
          defaultHours.push(existing);
        } else {
          defaultHours.push({
            day_of_week: i,
            open_time: '09:00',
            close_time: '18:00',
            is_closed: false,
          });
        }
      }

      setOperatingHours(defaultHours);
    } catch (error) {
      console.error('영업시간 로딩 오류:', error);
      throw error;
    }
  }, []);

  useEffect(() => {
    const init = async () => {
      try {
        setLoading(true);
        const id = await fetchStoreId();
        setStoreId(id);
        await fetchOperatingHours(id);
      } catch {
        Alert.alert('오류', '영업시간을 불러오는데 실패했습니다.');
      } finally {
        setLoading(false);
      }
    };

    init();
  }, [fetchStoreId, fetchOperatingHours]);

  const updateHour = (dayIndex: number, field: string, value: any) => {
    const newHours = [...operatingHours];
    newHours[dayIndex] = { ...newHours[dayIndex], [field]: value };
    setOperatingHours(newHours);
  };

  const handleSave = async () => {
    try {
      setSaving(true);

      // 기존 데이터 삭제
      await supabase.from('store_operating_hours').delete().eq('store_id', storeId);

      // 새 데이터 삽입
      const insertData = operatingHours.map((hour) => ({
        store_id: storeId,
        day_of_week: hour.day_of_week,
        open_time: hour.open_time,
        close_time: hour.close_time,
        is_closed: hour.is_closed,
      }));

      const { error } = await supabase.from('store_operating_hours').insert(insertData);

      if (error) throw error;

      Alert.alert('완료', '영업시간이 저장되었습니다.', [{ text: '확인', onPress: onBack }]);
    } catch (error) {
      console.error('영업시간 저장 오류:', error);
      Alert.alert('오류', '영업시간 저장에 실패했습니다.');
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>영업시간 관리</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {operatingHours.map((hour, index) => (
          <View key={index} style={styles.dayCard}>
            <View style={styles.dayHeader}>
              <Text style={styles.dayName}>{DAYS[hour.day_of_week]}</Text>
              <View style={styles.closedSwitch}>
                <Text style={styles.closedLabel}>휴무</Text>
                <Switch
                  value={hour.is_closed}
                  onValueChange={(value) => updateHour(index, 'is_closed', value)}
                  trackColor={{ false: '#D0D0D0', true: '#FF6B6B' }}
                  thumbColor="#FFFFFF"
                  ios_backgroundColor="#D0D0D0"
                />
              </View>
            </View>

            {!hour.is_closed && (
              <View style={styles.timeRow}>
                <View style={styles.timeColumn}>
                  <Text style={styles.timeLabel}>오픈</Text>
                  <View style={styles.timePicker}>
                    <Text style={styles.timeText}>{hour.open_time}</Text>
                  </View>
                </View>

                <Text style={styles.timeSeparator}>~</Text>

                <View style={styles.timeColumn}>
                  <Text style={styles.timeLabel}>마감</Text>
                  <View style={styles.timePicker}>
                    <Text style={styles.timeText}>{hour.close_time}</Text>
                  </View>
                </View>
              </View>
            )}
          </View>
        ))}

        {/* 안내 메시지 */}
        <View style={styles.infoBox}>
          <Text style={styles.infoIcon}>💡</Text>
          <Text style={styles.infoText}>
            영업시간은 예약 가능 시간에 반영됩니다.{'\n'}휴무일로 설정하면 해당 요일에는 예약이
            불가합니다.
          </Text>
        </View>

        {/* 저장 버튼 */}
        <TouchableOpacity style={styles.saveButton} onPress={handleSave} disabled={saving}>
          {saving ? (
            <ActivityIndicator size="small" color="#FFF" />
          ) : (
            <Text style={styles.saveButtonText}>저장하기</Text>
          )}
        </TouchableOpacity>

        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  // 요일 카드
  dayCard: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  dayHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  dayName: {
    fontSize: 16,
    fontWeight: 'bold',
    color: '#333',
  },
  closedSwitch: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  closedLabel: {
    fontSize: 14,
    color: '#666',
  },

  // 시간 행
  timeRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    gap: 12,
  },
  timeColumn: {
    flex: 1,
  },
  timeLabel: {
    fontSize: 13,
    color: '#666',
    marginBottom: 6,
  },
  timePicker: {
    backgroundColor: '#F5F5F5',
    borderRadius: 8,
    padding: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  timeText: {
    fontSize: 15,
    color: '#333',
    textAlign: 'center',
    fontWeight: '500',
  },
  timeSeparator: {
    fontSize: 18,
    color: '#999',
    marginTop: 20,
  },

  // 안내 박스
  infoBox: {
    backgroundColor: '#FFF4E5',
    padding: 16,
    borderRadius: 12,
    flexDirection: 'row',
    alignItems: 'flex-start',
    marginTop: 10,
    marginBottom: 20,
    gap: 12,
  },
  infoIcon: {
    fontSize: 20,
  },
  infoText: {
    flex: 1,
    fontSize: 13,
    color: '#666',
    lineHeight: 20,
  },

  // 저장 버튼
  saveButton: {
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  saveButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreProductManagement.tsx">
import { decode } from 'base64-arraybuffer';
import * as FileSystem from 'expo-file-system/legacy';
import * as ImagePicker from 'expo-image-picker';
import React, { useCallback, useEffect, useState } from 'react';
import {
  ActivityIndicator,
  FlatList,
  Image,
  Modal,
  ScrollView,
  StyleSheet,
  Switch,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreProductManagementProps {
  onBack: () => void;
}

interface PastProduct {
  id: string;
  name: string;
  original_price: number;
  discounted_price: number;
  image_url: string | null;
  manufactured_date: string | null;
  expiry_date: string | null;
}

export default function StoreProductManagement({ onBack }: StoreProductManagementProps) {
  const [loading, setLoading] = useState(false);
  const [storeId, setStoreId] = useState('');

  // 상품 정보
  const [productImage, setProductImage] = useState<any>(null);
  const [productImageUrl, setProductImageUrl] = useState<string | null>(null);
  const [productName, setProductName] = useState('');
  const [productCategory, setProductCategory] = useState('빵');
  const [originalPrice, setOriginalPrice] = useState('');
  const [discountedPrice, setDiscountedPrice] = useState('');
  const [stockQuantity, setStockQuantity] = useState(5);
  const [manufacturedDate, setManufacturedDate] = useState('');
  const [expiryDate, setExpiryDate] = useState('');
  const [sendNotification, setSendNotification] = useState(true);

  // 과거 상품 관련
  const [showPastProducts, setShowPastProducts] = useState(false);
  const [pastProducts, setPastProducts] = useState<PastProduct[]>([]);
  const [loadingPastProducts, setLoadingPastProducts] = useState(false);

  // 할인율 계산
  const discountRate = useCallback(() => {
    const original = parseFloat(originalPrice);
    const discounted = parseFloat(discountedPrice);
    if (original > 0 && discounted > 0 && discounted < original) {
      return Math.round(((original - discounted) / original) * 100);
    }
    return 0;
  }, [originalPrice, discountedPrice]);

  // 업체 ID 가져오기
  useEffect(() => {
    const fetchStoreId = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) throw new Error('사용자 정보를 찾을 수 없습니다');

        const { data: storeData, error } = await supabase
          .from('stores')
          .select('id')
          .eq('user_id', user.id)
          .single();

        if (error) throw error;
        setStoreId(storeData.id);
      } catch (error) {
        console.error('업체 정보 로딩 오류:', error);
        alert('업체 정보를 불러오는데 실패했습니다.');
      }
    };

    fetchStoreId();
  }, []);

  // 상품 사진 선택
  const pickProductImage = async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    if (status !== 'granted') {
      alert('사진 접근 권한이 필요합니다.');
      return;
    }

    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
    });

    if (!result.canceled) {
      setProductImage(result.assets[0]);
      setProductImageUrl(null); // 새 이미지 선택 시 URL 초기화
    }
  };

  // 재고 증감
  const increaseStock = () => setStockQuantity(stockQuantity + 1);
  const decreaseStock = () => {
    if (stockQuantity > 0) setStockQuantity(stockQuantity - 1);
  };

  // 상품 등록
  const handleSubmit = async () => {
    try {
      // 유효성 검사
      if (!productName.trim()) {
        alert('상품명을 입력해주세요.');
        return;
      }
      if (!originalPrice || parseFloat(originalPrice) <= 0) {
        alert('정가를 입력해주세요.');
        return;
      }
      if (!discountedPrice || parseFloat(discountedPrice) <= 0) {
        alert('할인가를 입력해주세요.');
        return;
      }
      if (parseFloat(discountedPrice) >= parseFloat(originalPrice)) {
        alert('할인가는 정가보다 낮아야 합니다.');
        return;
      }
      if (stockQuantity <= 0) {
        alert('재고 수량을 1개 이상 입력해주세요.');
        return;
      }

      setLoading(true);

      // 1. 상품 이미지 업로드 (선택 사항)
      let imageUrl = productImageUrl; // 과거 상품에서 가져온 URL 유지
      if (productImage) {
        const fileExt = productImage.uri.split('.').pop();
        const fileName = `${storeId}-product-${Date.now()}.${fileExt}`;
        const filePath = `products/${fileName}`;

        const base64 = await FileSystem.readAsStringAsync(productImage.uri, {
          encoding: 'base64',
        });

        const { error: uploadError } = await supabase.storage
          .from('store-documents')
          .upload(filePath, decode(base64), {
            contentType: `image/${fileExt}`,
            upsert: true,
          });

        if (uploadError) throw uploadError;

        const { data: urlData } = supabase.storage
          .from('store-documents')
          .getPublicUrl(filePath);

        imageUrl = urlData.publicUrl;
      }

      // 2. 상품 등록
      const { error } = await supabase.from('products').insert({
        store_id: storeId,
        name: productName,
        category: productCategory,
        original_price: parseFloat(originalPrice),
        discounted_price: parseFloat(discountedPrice),
        stock_quantity: stockQuantity,
        image_url: imageUrl,
        manufactured_date: manufacturedDate || null,
        expiry_date: expiryDate || null,
        send_notification: sendNotification,
        is_active: true,
      });

      if (error) throw error;

      alert('상품이 등록되었습니다.');

      // 폼 초기화
      setProductImage(null);
      setProductImageUrl(null);
      setProductName('');
      setProductCategory('빵');
      setOriginalPrice('');
      setDiscountedPrice('');
      setStockQuantity(5);
      setManufacturedDate('');
      setExpiryDate('');
      setSendNotification(true);

      onBack();
    } catch (error) {
      console.error('상품 등록 오류:', error);
      alert('상품 등록에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  // 과거 상품 불러오기
  const loadPastProducts = async () => {
    try {
      setLoadingPastProducts(true);
      setShowPastProducts(true);

      const { data, error } = await supabase
        .from('products')
        .select('id, name, original_price, discounted_price, image_url, manufactured_date, expiry_date')
        .eq('store_id', storeId)
        .eq('is_active', false)
        .order('created_at', { ascending: false })
        .limit(20);

      if (error) throw error;

      setPastProducts(data || []);
    } catch (error) {
      console.error('과거 상품 로딩 오류:', error);
      alert('과거 상품을 불러오는데 실패했습니다.');
      setShowPastProducts(false);
    } finally {
      setLoadingPastProducts(false);
    }
  };

  // 과거 상품 선택
  const selectPastProduct = (product: PastProduct) => {
    setProductName(product.name);
    setOriginalPrice(product.original_price.toString());
    setDiscountedPrice(product.discounted_price.toString());
    setProductImageUrl(product.image_url);
    setProductImage(null); // 로컬 이미지 초기화
    setManufacturedDate(product.manufactured_date || '');
    setExpiryDate(product.expiry_date || '');

    setShowPastProducts(false);
    alert('상품 정보를 불러왔습니다. 재고만 입력하고 등록해주세요!');
  };

  // 과거 상품 아이템 렌더링
  const renderPastProductItem = ({ item }: { item: PastProduct }) => {
    return (
      <View style={styles.pastProductItem}>
        <Image
          source={{ uri: item.image_url || 'https://via.placeholder.com/80' }}
          style={styles.pastProductImage}
          resizeMode="cover"
        />
        <View style={styles.pastProductInfo}>
          <Text style={styles.pastProductName}>{item.name}</Text>
          <View style={styles.pastProductPriceRow}>
            <Text style={styles.pastProductOriginalPrice}>
              정가: {item.original_price.toLocaleString()}원
            </Text>
            <Text style={styles.pastProductDiscountedPrice}>
              할인가: {item.discounted_price.toLocaleString()}원
            </Text>
          </View>
        </View>
        <TouchableOpacity
          style={styles.selectButton}
          onPress={() => selectPastProduct(item)}
        >
          <Text style={styles.selectButtonText}>선택</Text>
        </TouchableOpacity>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>상품 등록</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* 과거 등록 상품 불러오기 */}
        <TouchableOpacity style={styles.loadPastButton} onPress={loadPastProducts}>
          <Text style={styles.loadPastIcon}>🔄</Text>
          <Text style={styles.loadPastText}>과거 등록 상품 불러오기</Text>
        </TouchableOpacity>

        {/* 기본 정보 */}
        <Text style={styles.sectionTitle}>기본 정보</Text>

        {/* 상품 사진 추가 */}
        <Text style={styles.label}>상품 사진</Text>
        <TouchableOpacity style={styles.imageUploadBox} onPress={pickProductImage}>
          {productImage ? (
            <Image
              source={{ uri: productImage.uri }}
              style={styles.uploadedImage}
              resizeMode="cover"
            />
          ) : productImageUrl ? (
            <Image
              source={{ uri: productImageUrl }}
              style={styles.uploadedImage}
              resizeMode="cover"
            />
          ) : (
            <View style={styles.imageUploadPlaceholder}>
              <Text style={styles.imageUploadIcon}>📷+</Text>
              <Text style={styles.imageUploadText}>상품 사진 추가</Text>
            </View>
          )}
        </TouchableOpacity>

        <Text style={styles.label}>상품명 *</Text>
        <TextInput
          style={styles.input}
          value={productName}
          onChangeText={setProductName}
          placeholder="예: 유기농 딸기"
          placeholderTextColor="#999"
        />

        <Text style={styles.label}>카테고리 *</Text>
        <View style={styles.categoryContainer}>
          {['빵', '도시락', '음료', '반찬', '과일', '기타'].map((cat) => (
            <TouchableOpacity
              key={cat}
              style={[
                styles.categoryButton,
                productCategory === cat && styles.categoryButtonActive,
              ]}
              onPress={() => setProductCategory(cat)}
            >
              <Text
                style={[
                  styles.categoryText,
                  productCategory === cat && styles.categoryTextActive,
                ]}
              >
                {cat}
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        {/* 가격 및 재고 */}
        <Text style={styles.sectionTitle}>가격 및 재고</Text>

        <View style={styles.priceRow}>
          <View style={styles.priceColumn}>
            <Text style={styles.label}>정가</Text>
            <TextInput
              style={styles.priceInput}
              value={originalPrice}
              onChangeText={setOriginalPrice}
              placeholder="10000"
              placeholderTextColor="#999"
              keyboardType="numeric"
            />
            <Text style={styles.priceUnit}>원</Text>
          </View>

          <View style={styles.priceColumn}>
            <Text style={styles.label}>할인가</Text>
            <TextInput
              style={[styles.priceInput, styles.discountInput]}
              value={discountedPrice}
              onChangeText={setDiscountedPrice}
              placeholder="7000"
              placeholderTextColor="#999"
              keyboardType="numeric"
            />
            <Text style={styles.priceUnit}>원</Text>
          </View>
        </View>

        {/* 현재 할인율 */}
        {discountRate() > 0 && (
          <View style={styles.discountRateBox}>
            <Text style={styles.discountRateLabel}>현재 할인율</Text>
            <Text style={styles.discountRateValue}>{discountRate()}% 할인</Text>
          </View>
        )}

        {/* 재고 수량 */}
        <Text style={styles.label}>재고 수량</Text>
        <View style={styles.stockRow}>
          <TouchableOpacity style={styles.stockButton} onPress={decreaseStock}>
            <Text style={styles.stockButtonText}>−</Text>
          </TouchableOpacity>
          <Text style={styles.stockValue}>{stockQuantity}</Text>
          <TouchableOpacity style={styles.stockButton} onPress={increaseStock}>
            <Text style={styles.stockButtonText}>+</Text>
          </TouchableOpacity>
        </View>

        {/* 제조날짜 & 소비기한 */}
        <View style={styles.dateRow}>
          <View style={styles.dateColumn}>
            <Text style={styles.label}>제조날짜</Text>
            <TextInput
              style={styles.dateInput}
              value={manufacturedDate}
              onChangeText={setManufacturedDate}
              placeholder="24/05/20"
              placeholderTextColor="#999"
            />
          </View>

          <View style={styles.dateColumn}>
            <Text style={styles.label}>소비기한</Text>
            <TextInput
              style={styles.dateInput}
              value={expiryDate}
              onChangeText={setExpiryDate}
              placeholder="24/05/23"
              placeholderTextColor="#999"
            />
          </View>
        </View>

        {/* 단골 알람 전송 */}
        <View style={styles.notificationBox}>
          <View>
            <Text style={styles.notificationTitle}>단골 알람 전송</Text>
            <Text style={styles.notificationSubtitle}>
              가게 단골분들에게 상품 등록 알림을 보냅니다.
            </Text>
          </View>
          <Switch
            value={sendNotification}
            onValueChange={setSendNotification}
            trackColor={{ false: '#D0D0D0', true: '#00D563' }}
            thumbColor="#FFFFFF"
            ios_backgroundColor="#D0D0D0"
          />
        </View>

        {/* 상품 등록 완료 버튼 */}
        <TouchableOpacity
          style={styles.submitButton}
          onPress={handleSubmit}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#FFF" />
          ) : (
            <Text style={styles.submitButtonText}>🛒 상품 등록 완료</Text>
          )}
        </TouchableOpacity>

        {/* 하단 여백 */}
        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 과거 상품 목록 Modal */}
      <Modal
        visible={showPastProducts}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setShowPastProducts(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            {/* Modal 헤더 */}
            <View style={styles.modalHeader}>
              <TouchableOpacity onPress={() => setShowPastProducts(false)}>
                <Text style={styles.modalBackButton}>←</Text>
              </TouchableOpacity>
              <Text style={styles.modalTitle}>과거 등록 상품</Text>
              <View style={{ width: 40 }} />
            </View>

            {/* 검색 바 */}
            <View style={styles.searchContainer}>
              <Text style={styles.searchIcon}>🔍</Text>
              <TextInput
                style={styles.searchInput}
                placeholder="상품 이름으로 검색"
                placeholderTextColor="#999"
              />
            </View>

            {/* 과거 상품 목록 */}
            {loadingPastProducts ? (
              <View style={styles.loadingContainer}>
                <ActivityIndicator size="large" color="#00D563" />
                <Text style={styles.loadingText}>상품을 불러오는 중...</Text>
              </View>
            ) : pastProducts.length === 0 ? (
              <View style={styles.emptyContainer}>
                <Text style={styles.emptyIcon}>📦</Text>
                <Text style={styles.emptyText}>과거 등록 상품이 없습니다</Text>
              </View>
            ) : (
              <FlatList
                data={pastProducts}
                renderItem={renderPastProductItem}
                keyExtractor={(item) => item.id}
                style={styles.pastProductList}
                showsVerticalScrollIndicator={false}
              />
            )}
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  // 과거 상품 불러오기
  loadPastButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#E8F5E9',
    paddingVertical: 14,
    borderRadius: 12,
    marginBottom: 20,
    gap: 8,
    borderWidth: 1,
    borderColor: '#00D563',
  },
  loadPastIcon: {
    fontSize: 18,
  },
  loadPastText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#00A84D',
  },

  // 섹션 타이틀
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 15,
  },

  // 라벨
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },

  // 이미지 업로드
  imageUploadBox: {
    width: '100%',
    height: 200,
    backgroundColor: '#E8F5E9',
    borderRadius: 16,
    overflow: 'hidden',
    marginBottom: 15,
  },
  uploadedImage: {
    width: '100%',
    height: '100%',
  },
  imageUploadPlaceholder: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  imageUploadIcon: {
    fontSize: 40,
    marginBottom: 8,
  },
  imageUploadText: {
    fontSize: 15,
    color: '#666',
  },

  // 입력 필드
  input: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 15,
  },

  // 가격 행
  priceRow: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 15,
  },
  priceColumn: {
    flex: 1,
    position: 'relative',
  },
  priceInput: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    paddingRight: 45,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  discountInput: {
    borderColor: '#00D563',
    borderWidth: 2,
  },
  priceUnit: {
    position: 'absolute',
    right: 16,
    bottom: 16,
    fontSize: 15,
    color: '#999',
  },

  // 할인율 표시
  discountRateBox: {
    backgroundColor: '#FFF4E5',
    paddingVertical: 16,
    paddingHorizontal: 20,
    borderRadius: 12,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 20,
  },
  discountRateLabel: {
    fontSize: 15,
    color: '#666',
  },
  discountRateValue: {
    fontSize: 20,
    fontWeight: 'bold',
    color: '#FF6B00',
  },

  // 재고 수량
  stockRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  stockButton: {
    width: 44,
    height: 44,
    backgroundColor: '#F5F5F5',
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
  stockButtonText: {
    fontSize: 24,
    color: '#333',
    fontWeight: '300',
  },
  stockValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
    marginHorizontal: 40,
  },

  // 날짜 행
  dateRow: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 20,
  },
  dateColumn: {
    flex: 1,
  },
  dateInput: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },

  // 단골 알람
  notificationBox: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    padding: 20,
    borderRadius: 12,
    marginBottom: 20,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  notificationTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  notificationSubtitle: {
    fontSize: 13,
    color: '#999',
  },

  // 제출 버튼
  submitButton: {
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },

  // Modal 스타일
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContainer: {
    backgroundColor: '#FFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    height: '80%',
    paddingBottom: 20,
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingTop: 20,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  modalBackButton: {
    fontSize: 28,
    color: '#333',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 검색 바
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
    margin: 20,
    paddingHorizontal: 15,
    paddingVertical: 12,
    borderRadius: 12,
    gap: 10,
  },
  searchIcon: {
    fontSize: 18,
  },
  searchInput: {
    flex: 1,
    fontSize: 15,
    color: '#333',
  },

  // 과거 상품 목록
  pastProductList: {
    flex: 1,
    paddingHorizontal: 20,
  },
  pastProductItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#FFF',
    padding: 15,
    borderRadius: 12,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
    gap: 12,
  },
  pastProductImage: {
    width: 80,
    height: 80,
    borderRadius: 12,
    backgroundColor: '#F5F5F5',
  },
  pastProductInfo: {
    flex: 1,
  },
  pastProductName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },
  pastProductPriceRow: {
    gap: 4,
  },
  pastProductOriginalPrice: {
    fontSize: 13,
    color: '#999',
    textDecorationLine: 'line-through',
  },
  pastProductDiscountedPrice: {
    fontSize: 15,
    fontWeight: '600',
    color: '#00D563',
  },
  selectButton: {
    backgroundColor: '#00D563',
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
  },
  selectButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
  },

  // 로딩 & 빈 화면
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    gap: 12,
  },
  loadingText: {
    fontSize: 15,
    color: '#999',
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    gap: 12,
  },
  emptyIcon: {
    fontSize: 48,
  },
  emptyText: {
    fontSize: 16,
    color: '#999',
  },

  // 카테고리 선택
  categoryContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
    marginBottom: 15,
  },
  categoryButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#FFF',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  categoryButtonActive: {
    backgroundColor: '#00D563',
    borderColor: '#00D563',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  categoryTextActive: {
    color: '#FFF',
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreRegularCustomers.tsx">
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, Modal, ScrollView, StyleSheet, Text, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreRegularCustomersProps {
  onBack: () => void;
}

export default function StoreRegularCustomers({ onBack }: StoreRegularCustomersProps) {
  const [loading, setLoading] = useState(true);
  const [favorites, setFavorites] = useState<any[]>([]);
  const [totalCount, setTotalCount] = useState(0);
  const [filterModal, setFilterModal] = useState(false);
  const [selectedFilter, setSelectedFilter] = useState<string>('전체');
  const [productFilters, setProductFilters] = useState<string[]>([]);

  useEffect(() => {
    fetchFavorites();
  }, []);

  const fetchFavorites = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: store } = await supabase.from('stores').select('id').eq('user_id', user.id).single();
      if (!store) return;

      const { data, error } = await supabase
        .from('favorites')
        .select('*, consumers(nickname)')
        .eq('store_id', store.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setFavorites(data || []);
      setTotalCount(data?.length || 0);

      // 제품 필터 목록 생성
      const products = new Set<string>();
      data?.forEach((f: any) => {
        if (f.product_names && f.product_names.length > 0) {
          f.product_names.forEach((p: string) => products.add(p));
        }
      });
      setProductFilters(['전체', '알림 전체', ...Array.from(products)]);
    } catch (error) {
      console.error('단골 고객 로딩 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const filteredFavorites = favorites.filter((f) => {
    if (selectedFilter === '전체') return true;
    if (selectedFilter === '알림 전체') return f.notification_type === 'all';
    return f.product_names && f.product_names.includes(selectedFilter);
  });

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>단골 고객 관리</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView}>
        {/* 전체 단골 수 */}
        <View style={styles.totalCard}>
          <Text style={styles.totalLabel}>우리 가게 팬</Text>
          <View style={styles.totalRow}>
            <Text style={styles.totalCount}>전체 단골 {totalCount.toLocaleString()}명</Text>
            <Text style={styles.heartIcon}>💚</Text>
          </View>
        </View>

        {/* 알림 설정 고객 목록 */}
        <View style={styles.sectionHeader}>
          <Text style={styles.sectionTitle}>알림 설정 고객 목록</Text>
          <TouchableOpacity style={styles.filterButton} onPress={() => setFilterModal(true)}>
            <Text style={styles.filterButtonText}>🔽 {selectedFilter}</Text>
          </TouchableOpacity>
        </View>

        {filteredFavorites.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>단골 고객이 없습니다.</Text>
          </View>
        ) : (
          filteredFavorites.map((favorite) => (
            <View key={favorite.id} style={styles.customerCard}>
              <View style={styles.customerAvatar}>
                <Text style={styles.customerAvatarText}>👤</Text>
              </View>
              <View style={{ flex: 1 }}>
                <View style={styles.customerHeader}>
                  <Text style={styles.customerName}>{favorite.consumers?.nickname || '익명'}</Text>
                  <Text
                    style={[
                      styles.notificationBadge,
                      favorite.notification_type === 'all' ? styles.badgeAll : styles.badgeSpecific,
                    ]}
                  >
                    {favorite.notification_type === 'all' ? '전체 알림' : '특정 상품 알림'}
                  </Text>
                </View>
                {favorite.notification_type === 'specific' && favorite.product_names && (
                  <Text style={styles.productNames}>
                    • {favorite.product_names.join(', ')}
                  </Text>
                )}
              </View>
            </View>
          ))
        )}

        {/* 단골 알림 안내 */}
        <View style={styles.infoBox}>
          <Text style={styles.infoIcon}>🔔</Text>
          <Text style={styles.infoText}>
            단골 알림 안내{'\n'}
            새로운 마감 할인 상품이 등록되면 단골 고객에게 푸시 알림이 발송되어 빠른 판매를 도와줍니다.
          </Text>
        </View>

        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 필터 모달 */}
      <Modal visible={filterModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>필터 선택</Text>
            <ScrollView style={{ maxHeight: 300 }}>
              {productFilters.map((filter) => (
                <TouchableOpacity
                  key={filter}
                  style={styles.filterOption}
                  onPress={() => {
                    setSelectedFilter(filter);
                    setFilterModal(false);
                  }}
                >
                  <Text
                    style={[
                      styles.filterOptionText,
                      selectedFilter === filter && styles.filterOptionTextActive,
                    ]}
                  >
                    {filter}
                  </Text>
                  {selectedFilter === filter && <Text style={styles.checkmark}>✓</Text>}
                </TouchableOpacity>
              ))}
            </ScrollView>
            <TouchableOpacity
              style={styles.modalCloseButton}
              onPress={() => setFilterModal(false)}
            >
              <Text style={styles.modalCloseButtonText}>닫기</Text>
            </TouchableOpacity>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 20 },
  totalCard: { backgroundColor: '#FFF', padding: 20, borderRadius: 16, marginBottom: 20, borderWidth: 2, borderColor: '#E8F5E9' },
  totalLabel: { fontSize: 14, color: '#666', marginBottom: 8 },
  totalRow: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between' },
  totalCount: { fontSize: 24, fontWeight: 'bold', color: '#00D563' },
  heartIcon: { fontSize: 40 },
  sectionHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 15 },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  filterButton: { backgroundColor: '#E8F5E9', paddingHorizontal: 12, paddingVertical: 6, borderRadius: 16, borderWidth: 1, borderColor: '#00D563' },
  filterButtonText: { fontSize: 13, fontWeight: '600', color: '#00A84D' },
  emptyContainer: { paddingVertical: 60, alignItems: 'center' },
  emptyText: { fontSize: 15, color: '#999' },
  customerCard: { backgroundColor: '#FFF', padding: 16, borderRadius: 12, marginBottom: 12, flexDirection: 'row', alignItems: 'center', gap: 12 },
  customerAvatar: { width: 50, height: 50, borderRadius: 25, backgroundColor: '#E8F5E9', justifyContent: 'center', alignItems: 'center' },
  customerAvatarText: { fontSize: 24 },
  customerHeader: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 6 },
  customerName: { fontSize: 16, fontWeight: '600', color: '#333' },
  notificationBadge: { fontSize: 12, fontWeight: '600', paddingHorizontal: 10, paddingVertical: 4, borderRadius: 12 },
  badgeAll: { backgroundColor: '#E8F5E9', color: '#00A84D' },
  badgeSpecific: { backgroundColor: '#FFF4E5', color: '#FF9800' },
  productNames: { fontSize: 13, color: '#666', lineHeight: 18 },
  infoBox: { backgroundColor: '#F9F9F9', padding: 16, borderRadius: 12, flexDirection: 'row', alignItems: 'flex-start', gap: 12, marginTop: 20 },
  infoIcon: { fontSize: 24 },
  infoText: { flex: 1, fontSize: 13, color: '#666', lineHeight: 18 },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end' },
  modalContent: { backgroundColor: '#FFF', borderTopLeftRadius: 20, borderTopRightRadius: 20, padding: 24 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 15 },
  filterOption: { paddingVertical: 14, borderBottomWidth: 1, borderBottomColor: '#F0F0F0', flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  filterOptionText: { fontSize: 15, color: '#333' },
  filterOptionTextActive: { fontWeight: '600', color: '#00D563' },
  checkmark: { fontSize: 18, color: '#00D563', fontWeight: 'bold' },
  modalCloseButton: { backgroundColor: '#F5F5F5', paddingVertical: 14, borderRadius: 10, alignItems: 'center', marginTop: 15 },
  modalCloseButtonText: { fontSize: 15, fontWeight: '600', color: '#666' },
});
</file>

<file path="app/src/screens/StoreReservationManagement.tsx">
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, Alert, Modal, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreReservationManagementNewProps {
  onBack: () => void;
}

export default function StoreReservationManagementNew({ onBack }: StoreReservationManagementNewProps) {
  const [loading, setLoading] = useState(true);
  const [tab, setTab] = useState<'pickup' | 'completed'>('pickup');
  const [reservations, setReservations] = useState<any[]>([]);
  const [cancelModal, setCancelModal] = useState(false);
  const [selectedReservation, setSelectedReservation] = useState<any>(null);
  const [cancelReason, setCancelReason] = useState('');

  useEffect(() => {
    fetchReservations();
  }, []);

  const fetchReservations = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: store } = await supabase.from('stores').select('id').eq('user_id', user.id).single();
      if (!store) return;

      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      const { data, error } = await supabase
        .from('reservations')
        .select('*, consumers(nickname), products(name, image_url)')
        .eq('store_id', store.id)
        .gte('created_at', oneWeekAgo.toISOString())
        .order('created_at', { ascending: false });

      if (error) throw error;
      setReservations(data || []);
    } catch (error) {
      console.error('예약 로딩 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const handlePickupComplete = (reservationId: string) => {
    Alert.alert(
      '픽업 완료 확인',
      '고객이 상품을 픽업했습니까?\n픽업 완료 처리 후에는 되돌릴 수 없습니다.',
      [
        {
          text: '취소',
          style: 'cancel'
        },
        {
          text: '픽업 완료',
          onPress: async () => {
            try {
              const { error } = await supabase
                .from('reservations')
                .update({ status: 'completed', picked_up: true, picked_up_at: new Date().toISOString() })
                .eq('id', reservationId);

              if (error) throw error;
              Alert.alert('완료', '픽업이 완료되었습니다.');
              fetchReservations();
            } catch (error) {
              console.error('픽업 완료 오류:', error);
              Alert.alert('오류', '픽업 완료 처리에 실패했습니다.');
            }
          }
        }
      ]
    );
  };

  const handleCancel = async () => {
    if (!cancelReason.trim()) {
      alert('취소 사유를 입력해주세요.');
      return;
    }
    try {
      const { error } = await supabase
        .from('reservations')
        .update({ status: 'cancelled_by_store', cancel_reason: cancelReason })
        .eq('id', selectedReservation.id);

      if (error) throw error;
      alert('예약이 취소되었습니다.');
      setCancelModal(false);
      setSelectedReservation(null);
      setCancelReason('');
      fetchReservations();
    } catch (error) {
      console.error('예약 취소 오류:', error);
      alert('예약 취소에 실패했습니다.');
    }
  };

  const pickupReservations = reservations.filter((r) => r.status === 'confirmed' && !r.picked_up);
  const completedReservations = reservations.filter((r) => r.status === 'completed' || r.picked_up);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>💚 Save It</Text>
        <View style={{ width: 40 }} />
      </View>

      <View style={styles.topTab}>
        <TouchableOpacity style={styles.topTabButton}>
          <Text style={styles.topTabTextActive}>내 매장 예약</Text>
        </TouchableOpacity>
        <TouchableOpacity style={[styles.topTabButton, { backgroundColor: '#E8F5E9' }]}>
          <Text style={styles.topTabText}>나의 예약</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.subTab}>
        <TouchableOpacity
          style={[styles.subTabButton, tab === 'pickup' && styles.subTabButtonActive]}
          onPress={() => setTab('pickup')}
        >
          <Text style={[styles.subTabText, tab === 'pickup' && styles.subTabTextActive]}>픽업 대기</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.subTabButton, tab === 'completed' && styles.subTabButtonActive]}
          onPress={() => setTab('completed')}
        >
          <Text style={[styles.subTabText, tab === 'completed' && styles.subTabTextActive]}>완료됨</Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView}>
        {(tab === 'pickup' ? pickupReservations : completedReservations).length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>예약이 없습니다.</Text>
          </View>
        ) : (
          (tab === 'pickup' ? pickupReservations : completedReservations).map((reservation) => (
            <View key={reservation.id} style={styles.reservationCard}>
              <View style={styles.reservationHeader}>
                <Text style={styles.reservationNumber}>예약번호 #{reservation.reservation_number}</Text>
                <Text style={[styles.reservationStatus, reservation.status === 'completed' ? styles.statusCompleted : styles.statusConfirmed]}>
                  {reservation.status === 'completed' ? '픽업 완료' : '예약 확정'}
                </Text>
              </View>
              <Text style={styles.storeName}>{reservation.consumers?.nickname || '고객'}</Text>

              <View style={styles.productRow}>
                <Text style={styles.productIcon}>🛒</Text>
                <View style={{ flex: 1 }}>
                  <Text style={styles.productName}>{reservation.products?.name} x{reservation.quantity}</Text>
                  <Text style={styles.productPrice}>{reservation.total_amount?.toLocaleString()}원 <Text style={styles.priceLabel}>(현장 결제)</Text></Text>
                </View>
              </View>

              <View style={styles.timeRow}>
                <Text style={styles.timeIcon}>🕐</Text>
                <Text style={styles.timeText}>
                  픽업 예약 시간: {new Date(reservation.pickup_time).toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })}
                </Text>
              </View>

              {tab === 'pickup' ? (
                <View style={styles.buttonRow}>
                  <TouchableOpacity
                    style={styles.cancelButton}
                    onPress={() => {
                      setSelectedReservation(reservation);
                      setCancelModal(true);
                    }}
                  >
                    <Text style={styles.cancelButtonText}>예약 취소</Text>
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={styles.completeButton}
                    onPress={() => handlePickupComplete(reservation.id)}
                  >
                    <Text style={styles.completeButtonText}>픽업 완료</Text>
                  </TouchableOpacity>
                </View>
              ) : null}
            </View>
          ))
        )}
        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 취소 모달 */}
      <Modal visible={cancelModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>예약 취소</Text>
            <Text style={styles.modalLabel}>취소 사유를 입력해주세요</Text>
            <TextInput
              style={styles.modalInput}
              value={cancelReason}
              onChangeText={setCancelReason}
              placeholder="예: 재고 소진, 영업 종료 등"
              placeholderTextColor="#999"
              multiline
            />
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonCancel]}
                onPress={() => {
                  setCancelModal(false);
                  setSelectedReservation(null);
                  setCancelReason('');
                }}
              >
                <Text style={styles.modalButtonTextCancel}>닫기</Text>
              </TouchableOpacity>
              <TouchableOpacity style={[styles.modalButton, styles.modalButtonConfirm]} onPress={handleCancel}>
                <Text style={styles.modalButtonTextConfirm}>취소하기</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  topTab: { flexDirection: 'row', backgroundColor: '#FFF', padding: 15, gap: 10 },
  topTabButton: { flex: 1, paddingVertical: 12, borderRadius: 12, backgroundColor: '#1A1A2E', alignItems: 'center' },
  topTabText: { fontSize: 14, fontWeight: '600', color: '#00A84D' },
  topTabTextActive: { fontSize: 14, fontWeight: '600', color: '#FFF' },
  subTab: { flexDirection: 'row', backgroundColor: '#FFF', paddingHorizontal: 15, paddingBottom: 10, gap: 10 },
  subTabButton: { flex: 1, paddingVertical: 10, borderRadius: 20, backgroundColor: '#F5F5F5', alignItems: 'center' },
  subTabButtonActive: { backgroundColor: '#00D563' },
  subTabText: { fontSize: 14, fontWeight: '600', color: '#666' },
  subTabTextActive: { color: '#FFF' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 15 },
  emptyContainer: { paddingVertical: 60, alignItems: 'center' },
  emptyText: { fontSize: 15, color: '#999' },
  reservationCard: { backgroundColor: '#FFF', padding: 18, borderRadius: 12, marginBottom: 12 },
  reservationHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 },
  reservationNumber: { fontSize: 13, color: '#999' },
  reservationStatus: { fontSize: 13, fontWeight: '600', paddingHorizontal: 12, paddingVertical: 4, borderRadius: 12 },
  statusConfirmed: { backgroundColor: '#E8F5E9', color: '#00A84D' },
  statusCompleted: { backgroundColor: '#FFE5E5', color: '#FF6B6B' },
  storeName: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 12 },
  productRow: { flexDirection: 'row', alignItems: 'center', gap: 12, marginBottom: 10, backgroundColor: '#E8F5E9', padding: 12, borderRadius: 8 },
  productIcon: { fontSize: 24 },
  productName: { fontSize: 15, fontWeight: '600', color: '#333', marginBottom: 4 },
  productPrice: { fontSize: 16, fontWeight: 'bold', color: '#00D563' },
  priceLabel: { fontSize: 13, color: '#666', fontWeight: 'normal' },
  timeRow: { flexDirection: 'row', alignItems: 'center', gap: 8, marginBottom: 12 },
  timeIcon: { fontSize: 18 },
  timeText: { fontSize: 14, color: '#666' },
  buttonRow: { flexDirection: 'row', gap: 10, marginTop: 12 },
  cancelButton: { flex: 1, paddingVertical: 12, borderRadius: 8, borderWidth: 1, borderColor: '#E0E0E0', alignItems: 'center' },
  cancelButtonText: { fontSize: 14, fontWeight: '600', color: '#666' },
  completeButton: { flex: 1, paddingVertical: 12, borderRadius: 8, backgroundColor: '#00D563', alignItems: 'center' },
  completeButtonText: { fontSize: 14, fontWeight: '600', color: '#FFF' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end' },
  modalContent: { backgroundColor: '#FFF', borderTopLeftRadius: 20, borderTopRightRadius: 20, padding: 24 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 8 },
  modalLabel: { fontSize: 14, color: '#666', marginBottom: 12 },
  modalInput: { backgroundColor: '#F5F5F5', borderRadius: 12, padding: 16, fontSize: 15, color: '#333', height: 100, textAlignVertical: 'top', marginBottom: 20 },
  modalButtons: { flexDirection: 'row', gap: 12 },
  modalButton: { flex: 1, paddingVertical: 14, borderRadius: 10, alignItems: 'center' },
  modalButtonCancel: { backgroundColor: '#F5F5F5' },
  modalButtonConfirm: { backgroundColor: '#FF6B6B' },
  modalButtonTextCancel: { fontSize: 15, fontWeight: '600', color: '#666' },
  modalButtonTextConfirm: { fontSize: 15, fontWeight: '600', color: '#FFF' },
});
</file>

<file path="app/src/screens/StoreReviewManagement.tsx">
import React, { useEffect, useState } from 'react';
import { ActivityIndicator, Image, Modal, ScrollView, StyleSheet, Text, TextInput, TouchableOpacity, View } from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreReviewManagementProps {
  onBack: () => void;
}

export default function StoreReviewManagement({ onBack }: StoreReviewManagementProps) {
  const [loading, setLoading] = useState(true);
  const [tab, setTab] = useState<'pending' | 'replied'>('pending');
  const [reviews, setReviews] = useState<any[]>([]);
  const [stats, setStats] = useState({ avgRating: 0, totalCount: 0, ratingDist: [0, 0, 0, 0, 0] });
  const [replyModal, setReplyModal] = useState(false);
  const [selectedReview, setSelectedReview] = useState<any>(null);
  const [replyText, setReplyText] = useState('');

  useEffect(() => {
    fetchReviews();
  }, []);

  const fetchReviews = async () => {
    try {
      setLoading(true);
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data: store } = await supabase.from('stores').select('id, average_rating, review_count').eq('user_id', user.id).single();
      if (!store) return;

      const { data: reviewsData } = await supabase
        .from('reviews')
        .select('*, consumers(nickname)')
        .eq('store_id', store.id)
        .order('created_at', { ascending: false });

      setReviews(reviewsData || []);

      // 별점 분포 계산
      const dist = [0, 0, 0, 0, 0];
      reviewsData?.forEach((r) => {
        dist[r.rating - 1]++;
      });
      setStats({ avgRating: store.average_rating || 0, totalCount: store.review_count || 0, ratingDist: dist });
    } catch (error) {
      console.error('리뷰 로딩 오류:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleReply = async () => {
    if (!replyText.trim()) {
      alert('답글을 입력해주세요.');
      return;
    }
    try {
      const { error } = await supabase
        .from('reviews')
        .update({ reply: replyText, replied_at: new Date().toISOString() })
        .eq('id', selectedReview.id);

      if (error) throw error;
      alert('답글이 등록되었습니다.');
      setReplyModal(false);
      setSelectedReview(null);
      setReplyText('');
      fetchReviews();
    } catch (error) {
      console.error('답글 등록 오류:', error);
      alert('답글 등록에 실패했습니다.');
    }
  };

  const pendingReviews = reviews.filter((r) => !r.reply);
  const repliedReviews = reviews.filter((r) => r.reply);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>리뷰 관리</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView}>
        {/* 가게 평점 */}
        <View style={styles.statsCard}>
          <View style={styles.statsLeft}>
            <Text style={styles.ratingBig}>{stats.avgRating.toFixed(1)}</Text>
            <View style={styles.starsRow}>
              {[1, 2, 3, 4, 5].map((s) => (
                <Text key={s} style={styles.star}>
                  {s <= Math.round(stats.avgRating) ? '★' : '☆'}
                </Text>
              ))}
            </View>
            <Text style={styles.statsTotal}>전체 리뷰 {stats.totalCount}개</Text>
          </View>
          <View style={styles.statsRight}>
            {[5, 4, 3, 2, 1].map((rating, idx) => {
              const count = stats.ratingDist[rating - 1];
              const percent = stats.totalCount > 0 ? Math.round((count / stats.totalCount) * 100) : 0;
              return (
                <View key={rating} style={styles.barRow}>
                  <Text style={styles.barLabel}>{rating}</Text>
                  <View style={styles.barBg}>
                    <View style={[styles.barFill, { width: `${percent}%` }]} />
                  </View>
                  <Text style={styles.barPercent}>{percent}%</Text>
                </View>
              );
            })}
          </View>
        </View>

        {/* 탭 */}
        <View style={styles.tabRow}>
          <TouchableOpacity
            style={[styles.tab, tab === 'pending' && styles.tabActive]}
            onPress={() => setTab('pending')}
          >
            <Text style={[styles.tabText, tab === 'pending' && styles.tabTextActive]}>답변 대기</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.tab, tab === 'replied' && styles.tabActive]}
            onPress={() => setTab('replied')}
          >
            <Text style={[styles.tabText, tab === 'replied' && styles.tabTextActive]}>답변 완료</Text>
          </TouchableOpacity>
        </View>

        {/* 리뷰 목록 */}
        <Text style={styles.sectionTitle}>고객 리뷰 목록</Text>
        {(tab === 'pending' ? pendingReviews : repliedReviews).length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyText}>리뷰가 없습니다.</Text>
          </View>
        ) : (
          (tab === 'pending' ? pendingReviews : repliedReviews).map((review) => (
            <View key={review.id} style={styles.reviewCard}>
              <View style={styles.reviewHeader}>
                <View style={styles.reviewLeft}>
                  <Text style={styles.reviewUser}>{review.consumers?.nickname || '익명'}</Text>
                  <View style={styles.reviewStarsRow}>
                    {[1, 2, 3, 4, 5].map((s) => (
                      <Text key={s} style={styles.reviewStar}>
                        {s <= review.rating ? '★' : '☆'}
                      </Text>
                    ))}
                    <Text style={styles.reviewRating}>{review.rating.toFixed(1)}</Text>
                  </View>
                  <Text style={styles.reviewDate}>
                    {new Date(review.created_at).toLocaleDateString('ko-KR')}
                  </Text>
                </View>
                <Image source={{ uri: 'https://via.placeholder.com/60' }} style={styles.reviewImage} />
              </View>
              <Text style={styles.reviewContent}>{review.content}</Text>
              {review.reply ? (
                <View style={styles.replyBox}>
                  <Text style={styles.replyLabel}>💬 업주 답글</Text>
                  <Text style={styles.replyText}>{review.reply}</Text>
                  <TouchableOpacity
                    onPress={() => {
                      setSelectedReview(review);
                      setReplyText(review.reply);
                      setReplyModal(true);
                    }}
                  >
                    <Text style={styles.replyEdit}>수정</Text>
                  </TouchableOpacity>
                </View>
              ) : (
                <TouchableOpacity
                  style={styles.replyButton}
                  onPress={() => {
                    setSelectedReview(review);
                    setReplyText('');
                    setReplyModal(true);
                  }}
                >
                  <Text style={styles.replyButtonText}>💬 답글 달기</Text>
                </TouchableOpacity>
              )}
            </View>
          ))
        )}
        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 답글 작성 모달 */}
      <Modal visible={replyModal} transparent animationType="slide">
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>답글 작성</Text>
            <TextInput
              style={styles.modalInput}
              value={replyText}
              onChangeText={setReplyText}
              placeholder="고객에게 답글을 남겨주세요."
              placeholderTextColor="#999"
              multiline
              numberOfLines={4}
            />
            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={[styles.modalButton, styles.modalButtonCancel]}
                onPress={() => {
                  setReplyModal(false);
                  setSelectedReview(null);
                  setReplyText('');
                }}
              >
                <Text style={styles.modalButtonTextCancel}>취소</Text>
              </TouchableOpacity>
              <TouchableOpacity style={[styles.modalButton, styles.modalButtonConfirm]} onPress={handleReply}>
                <Text style={styles.modalButtonTextConfirm}>등록</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F5F5' },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5F5F5' },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', backgroundColor: '#FFF', paddingHorizontal: 20, paddingTop: 50, paddingBottom: 15, borderBottomWidth: 1, borderBottomColor: '#E0E0E0' },
  backButton: { fontSize: 28, color: '#333' },
  headerTitle: { fontSize: 18, fontWeight: 'bold', color: '#333' },
  scrollView: { flex: 1, paddingHorizontal: 20, paddingTop: 20 },
  statsCard: { backgroundColor: '#FFF', padding: 20, borderRadius: 16, marginBottom: 15, flexDirection: 'row', gap: 20 },
  statsLeft: { alignItems: 'center' },
  ratingBig: { fontSize: 48, fontWeight: 'bold', color: '#333' },
  starsRow: { flexDirection: 'row', marginVertical: 8 },
  star: { fontSize: 20, color: '#00D563' },
  statsTotal: { fontSize: 13, color: '#00D563', fontWeight: '600' },
  statsRight: { flex: 1, justifyContent: 'center', gap: 8 },
  barRow: { flexDirection: 'row', alignItems: 'center', gap: 8 },
  barLabel: { fontSize: 13, color: '#333', width: 10 },
  barBg: { flex: 1, height: 8, backgroundColor: '#E0E0E0', borderRadius: 4, overflow: 'hidden' },
  barFill: { height: '100%', backgroundColor: '#00D563', borderRadius: 4 },
  barPercent: { fontSize: 12, color: '#00D563', fontWeight: '600', width: 40, textAlign: 'right' },
  tabRow: { flexDirection: 'row', backgroundColor: '#FFF', borderRadius: 12, padding: 4, marginBottom: 20 },
  tab: { flex: 1, paddingVertical: 10, alignItems: 'center', borderRadius: 8 },
  tabActive: { backgroundColor: '#00D563' },
  tabText: { fontSize: 14, fontWeight: '600', color: '#666' },
  tabTextActive: { color: '#FFF' },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 15 },
  emptyContainer: { paddingVertical: 60, alignItems: 'center' },
  emptyText: { fontSize: 15, color: '#999' },
  reviewCard: { backgroundColor: '#FFF', padding: 18, borderRadius: 12, marginBottom: 12 },
  reviewHeader: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 12 },
  reviewLeft: { flex: 1 },
  reviewUser: { fontSize: 15, fontWeight: '600', color: '#333', marginBottom: 4 },
  reviewStarsRow: { flexDirection: 'row', alignItems: 'center', marginBottom: 4 },
  reviewStar: { fontSize: 14, color: '#FFB800' },
  reviewRating: { fontSize: 13, fontWeight: '600', color: '#333', marginLeft: 4 },
  reviewDate: { fontSize: 12, color: '#999' },
  reviewImage: { width: 60, height: 60, borderRadius: 8, backgroundColor: '#E0E0E0' },
  reviewContent: { fontSize: 14, color: '#333', lineHeight: 20, marginBottom: 12 },
  replyBox: { backgroundColor: '#F9F9F9', padding: 12, borderRadius: 8 },
  replyLabel: { fontSize: 13, fontWeight: '600', color: '#666', marginBottom: 6 },
  replyText: { fontSize: 13, color: '#333', lineHeight: 18, marginBottom: 8 },
  replyEdit: { fontSize: 13, color: '#00D563', fontWeight: '600' },
  replyButton: { backgroundColor: '#00D563', paddingVertical: 10, borderRadius: 8, alignItems: 'center' },
  replyButtonText: { color: '#FFF', fontSize: 14, fontWeight: '600' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.5)', justifyContent: 'flex-end' },
  modalContent: { backgroundColor: '#FFF', borderTopLeftRadius: 20, borderTopRightRadius: 20, padding: 24 },
  modalTitle: { fontSize: 18, fontWeight: 'bold', color: '#333', marginBottom: 15 },
  modalInput: { backgroundColor: '#F5F5F5', borderRadius: 12, padding: 16, fontSize: 15, color: '#333', height: 120, textAlignVertical: 'top', marginBottom: 20 },
  modalButtons: { flexDirection: 'row', gap: 12 },
  modalButton: { flex: 1, paddingVertical: 14, borderRadius: 10, alignItems: 'center' },
  modalButtonCancel: { backgroundColor: '#F5F5F5' },
  modalButtonConfirm: { backgroundColor: '#00D563' },
  modalButtonTextCancel: { fontSize: 15, fontWeight: '600', color: '#666' },
  modalButtonTextConfirm: { fontSize: 15, fontWeight: '600', color: '#FFF' },
});
</file>

<file path="app/src/screens/StoreReviewManagementWithReply.tsx">
import React, { useCallback, useEffect, useState } from 'react';
import {
    ActivityIndicator,
    Alert,
    Modal,
    ScrollView,
    StyleSheet,
    Text,
    TextInput,
    TouchableOpacity,
    View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreReviewManagementProps {
  onBack: () => void;
}

interface Review {
  id: string;
  rating: number;
  content: string;
  reply: string | null;
  created_at: string;
  consumers: {
    nickname: string;
  };
  products: {
    name: string;
  };
}

export default function StoreReviewManagementWithReply({ onBack }: StoreReviewManagementProps) {
  const [loading, setLoading] = useState(true);
  const [reviews, setReviews] = useState<Review[]>([]);
  const [storeId, setStoreId] = useState('');

  // 답글 모달
  const [replyModalVisible, setReplyModalVisible] = useState(false);
  const [selectedReview, setSelectedReview] = useState<Review | null>(null);
  const [replyText, setReplyText] = useState('');
  const [submitting, setSubmitting] = useState(false);

  const fetchStoreId = useCallback(async () => {
    try {
      const {
        data: { user },
      } = await supabase.auth.getUser();
      if (!user) throw new Error('사용자 정보를 찾을 수 없습니다');

      const { data: storeData, error } = await supabase
        .from('stores')
        .select('id')
        .eq('user_id', user.id)
        .single();

      if (error) throw error;
      return storeData.id;
    } catch (error) {
      console.error('업체 정보 로딩 오류:', error);
      throw error;
    }
  }, []);

  const fetchReviews = useCallback(async (storeIdParam: string) => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('reviews')
        .select('*, consumers(nickname), products(name)')
        .eq('store_id', storeIdParam)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setReviews(data || []);
    } catch (error) {
      console.error('리뷰 로딩 오류:', error);
      Alert.alert('오류', '리뷰를 불러오는데 실패했습니다.');
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    const init = async () => {
      try {
        const id = await fetchStoreId();
        setStoreId(id);
        await fetchReviews(id);
      } catch {
        Alert.alert('오류', '리뷰를 불러오는데 실패했습니다.');
      }
    };

    init();
  }, [fetchStoreId, fetchReviews]);

  const openReplyModal = (review: Review) => {
    setSelectedReview(review);
    setReplyText(review.reply || '');
    setReplyModalVisible(true);
  };

  const handleSubmitReply = async () => {
    if (!selectedReview) return;
    if (!replyText.trim()) {
      Alert.alert('알림', '답글을 입력해주세요.');
      return;
    }

    try {
      setSubmitting(true);

      const { error } = await supabase
        .from('reviews')
        .update({ reply: replyText.trim() })
        .eq('id', selectedReview.id);

      if (error) throw error;

      Alert.alert('완료', '답글이 등록되었습니다.');
      setReplyModalVisible(false);
      setReplyText('');
      setSelectedReview(null);
      await fetchReviews(storeId);
    } catch (error) {
      console.error('답글 등록 오류:', error);
      Alert.alert('오류', '답글 등록에 실패했습니다.');
    } finally {
      setSubmitting(false);
    }
  };

  const handleDeleteReply = async () => {
    if (!selectedReview) return;

    Alert.alert('확인', '답글을 삭제하시겠습니까?', [
      { text: '취소', style: 'cancel' },
      {
        text: '삭제',
        style: 'destructive',
        onPress: async () => {
          try {
            setSubmitting(true);

            const { error } = await supabase
              .from('reviews')
              .update({ reply: null })
              .eq('id', selectedReview.id);

            if (error) throw error;

            Alert.alert('완료', '답글이 삭제되었습니다.');
            setReplyModalVisible(false);
            setReplyText('');
            setSelectedReview(null);
            await fetchReviews(storeId);
          } catch (error) {
            console.error('답글 삭제 오류:', error);
            Alert.alert('오류', '답글 삭제에 실패했습니다.');
          } finally {
            setSubmitting(false);
          }
        },
      },
    ]);
  };

  const renderStars = (rating: number) => {
    return '⭐'.repeat(rating);
  };

  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#00D563" />
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>리뷰 관리</Text>
        <View style={{ width: 40 }} />
      </View>

      {/* 통계 */}
      <View style={styles.statsContainer}>
        <View style={styles.statItem}>
          <Text style={styles.statValue}>{reviews.length}</Text>
          <Text style={styles.statLabel}>전체 리뷰</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statValue}>
            {reviews.filter((r) => r.reply).length}
          </Text>
          <Text style={styles.statLabel}>답글 작성</Text>
        </View>
        <View style={styles.statDivider} />
        <View style={styles.statItem}>
          <Text style={styles.statValue}>
            {reviews.length > 0
              ? (
                  reviews.reduce((sum, r) => sum + r.rating, 0) / reviews.length
                ).toFixed(1)
              : '0.0'}
          </Text>
          <Text style={styles.statLabel}>평균 평점</Text>
        </View>
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {reviews.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Text style={styles.emptyIcon}>💬</Text>
            <Text style={styles.emptyText}>아직 리뷰가 없습니다.</Text>
          </View>
        ) : (
          reviews.map((review) => (
            <View key={review.id} style={styles.reviewCard}>
              {/* 리뷰 헤더 */}
              <View style={styles.reviewHeader}>
                <View>
                  <Text style={styles.reviewerName}>{review.consumers?.nickname}</Text>
                  <Text style={styles.reviewDate}>{formatDate(review.created_at)}</Text>
                </View>
                <Text style={styles.reviewRating}>{renderStars(review.rating)}</Text>
              </View>

              {/* 상품명 */}
              <Text style={styles.productName}>📦 {review.products?.name}</Text>

              {/* 리뷰 내용 */}
              <Text style={styles.reviewContent}>{review.content}</Text>

              {/* 답글 */}
              {review.reply && (
                <View style={styles.replyContainer}>
                  <Text style={styles.replyLabel}>💚 업주 답글</Text>
                  <Text style={styles.replyText}>{review.reply}</Text>
                </View>
              )}

              {/* 답글 버튼 */}
              <TouchableOpacity
                style={styles.replyButton}
                onPress={() => openReplyModal(review)}
              >
                <Text style={styles.replyButtonText}>
                  {review.reply ? '답글 수정' : '답글 작성'}
                </Text>
              </TouchableOpacity>
            </View>
          ))
        )}

        <View style={{ height: 40 }} />
      </ScrollView>

      {/* 답글 모달 */}
      <Modal
        visible={replyModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setReplyModalVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalContainer}>
            {/* 모달 헤더 */}
            <View style={styles.modalHeader}>
              <TouchableOpacity onPress={() => setReplyModalVisible(false)}>
                <Text style={styles.modalBackButton}>←</Text>
              </TouchableOpacity>
              <Text style={styles.modalTitle}>답글 작성</Text>
              <View style={{ width: 40 }} />
            </View>

            {/* 원본 리뷰 */}
            {selectedReview && (
              <View style={styles.originalReview}>
                <Text style={styles.originalReviewLabel}>원본 리뷰</Text>
                <Text style={styles.originalReviewRating}>
                  {renderStars(selectedReview.rating)}
                </Text>
                <Text style={styles.originalReviewContent}>{selectedReview.content}</Text>
              </View>
            )}

            {/* 답글 입력 */}
            <TextInput
              style={styles.replyInput}
              value={replyText}
              onChangeText={setReplyText}
              placeholder="친절하고 감사한 답글을 작성해주세요."
              placeholderTextColor="#999"
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />

            {/* 버튼 */}
            <View style={styles.modalButtons}>
              {selectedReview?.reply && (
                <TouchableOpacity
                  style={styles.deleteButton}
                  onPress={handleDeleteReply}
                  disabled={submitting}
                >
                  <Text style={styles.deleteButtonText}>삭제</Text>
                </TouchableOpacity>
              )}
              <TouchableOpacity
                style={[
                  styles.submitButton,
                  !selectedReview?.reply && { flex: 1 },
                ]}
                onPress={handleSubmitReply}
                disabled={submitting}
              >
                {submitting ? (
                  <ActivityIndicator size="small" color="#FFF" />
                ) : (
                  <Text style={styles.submitButtonText}>
                    {selectedReview?.reply ? '수정' : '등록'}
                  </Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 통계
  statsContainer: {
    flexDirection: 'row',
    backgroundColor: '#FFF',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  statItem: {
    flex: 1,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#00D563',
    marginBottom: 4,
  },
  statLabel: {
    fontSize: 13,
    color: '#666',
  },
  statDivider: {
    width: 1,
    backgroundColor: '#E0E0E0',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  // 빈 화면
  emptyContainer: {
    paddingVertical: 60,
    alignItems: 'center',
  },
  emptyIcon: {
    fontSize: 48,
    marginBottom: 12,
  },
  emptyText: {
    fontSize: 15,
    color: '#999',
  },

  // 리뷰 카드
  reviewCard: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  reviewHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
    marginBottom: 12,
  },
  reviewerName: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 4,
  },
  reviewDate: {
    fontSize: 12,
    color: '#999',
  },
  reviewRating: {
    fontSize: 16,
  },
  productName: {
    fontSize: 13,
    color: '#666',
    marginBottom: 8,
  },
  reviewContent: {
    fontSize: 14,
    color: '#333',
    lineHeight: 20,
    marginBottom: 12,
  },

  // 답글
  replyContainer: {
    backgroundColor: '#E8F5E9',
    padding: 12,
    borderRadius: 8,
    marginBottom: 12,
  },
  replyLabel: {
    fontSize: 12,
    fontWeight: '600',
    color: '#00A84D',
    marginBottom: 6,
  },
  replyText: {
    fontSize: 13,
    color: '#333',
    lineHeight: 18,
  },

  // 답글 버튼
  replyButton: {
    backgroundColor: '#00D563',
    paddingVertical: 10,
    borderRadius: 8,
    alignItems: 'center',
  },
  replyButtonText: {
    color: '#FFF',
    fontSize: 14,
    fontWeight: '600',
  },

  // 모달
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContainer: {
    backgroundColor: '#FFF',
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    padding: 20,
    maxHeight: '80%',
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 20,
  },
  modalBackButton: {
    fontSize: 28,
    color: '#333',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 원본 리뷰
  originalReview: {
    backgroundColor: '#F5F5F5',
    padding: 16,
    borderRadius: 12,
    marginBottom: 20,
  },
  originalReviewLabel: {
    fontSize: 12,
    color: '#666',
    marginBottom: 6,
  },
  originalReviewRating: {
    fontSize: 16,
    marginBottom: 8,
  },
  originalReviewContent: {
    fontSize: 14,
    color: '#333',
    lineHeight: 20,
  },

  // 답글 입력
  replyInput: {
    backgroundColor: '#F5F5F5',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    minHeight: 120,
    marginBottom: 20,
  },

  // 버튼
  modalButtons: {
    flexDirection: 'row',
    gap: 10,
  },
  deleteButton: {
    flex: 1,
    backgroundColor: '#FF6B6B',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  deleteButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },
  submitButton: {
    flex: 1,
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },
});
</file>

<file path="app/src/screens/StoreSignupScreen.tsx">
import React, { useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  ScrollView,
  StyleSheet,
  Text,
  TextInput,
  TouchableOpacity,
  View,
} from 'react-native';
import { supabase } from '../lib/supabase';

interface StoreSignupScreenProps {
  onBack: () => void;
  onSignupComplete: () => void;
}

export default function StoreSignupScreen({ onBack, onSignupComplete }: StoreSignupScreenProps) {
  const [loading, setLoading] = useState(false);

  // 인증 정보
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [passwordConfirm, setPasswordConfirm] = useState('');

  // 업체 정보
  const [storeName, setStoreName] = useState('');
  const [storeCategory, setStoreCategory] = useState('제과');
  const [ownerName, setOwnerName] = useState('');
  const [phone, setPhone] = useState('');
  const [address, setAddress] = useState('');
  const [businessNumber, setBusinessNumber] = useState('');

  const categories = ['반찬', '제과', '식자재', '밀키트'];

  const handleSignup = async () => {
    try {
      // 유효성 검사
      if (!email || !password || !passwordConfirm) {
        Alert.alert('오류', '이메일과 비밀번호를 입력해주세요.');
        return;
      }

      if (password !== passwordConfirm) {
        Alert.alert('오류', '비밀번호가 일치하지 않습니다.');
        return;
      }

      if (password.length < 6) {
        Alert.alert('오류', '비밀번호는 6자 이상이어야 합니다.');
        return;
      }

      if (!storeName || !ownerName || !phone || !address) {
        Alert.alert('오류', '모든 필수 정보를 입력해주세요.');
        return;
      }

      if (!businessNumber || businessNumber.length < 10) {
        Alert.alert('오류', '올바른 사업자등록번호를 입력해주세요.');
        return;
      }

      setLoading(true);

      // 1. 사용자 생성 (Supabase Auth)
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email: email.trim(),
        password: password,
      });

      if (authError) throw authError;

      if (!authData.user) {
        throw new Error('회원가입 중 오류가 발생했습니다.');
      }

      // 2. 업체 정보 저장
      const { error: storeError } = await supabase.from('stores').insert({
        user_id: authData.user.id,
        name: storeName.trim(),
        category: storeCategory,
        owner_name: ownerName.trim(),
        phone: phone.trim(),
        address: address.trim(),
        business_number: businessNumber.trim(),
        cash_balance: 0,
        average_rating: 0,
        review_count: 0,
        is_open: false, // 승인 전까지 영업 중지
        is_approved: false, // 관리자 승인 필요
        latitude: 37.5665, // 기본값 (서울)
        longitude: 126.9780,
      });

      if (storeError) throw storeError;

      Alert.alert(
        '회원가입 완료',
        '업체 등록이 완료되었습니다.\n관리자 승인 후 서비스를 이용하실 수 있습니다.\n\n승인까지 1-2일 소요됩니다.',
        [{ text: '확인', onPress: onSignupComplete }]
      );
    } catch (error: any) {
      console.error('회원가입 오류:', error);
      Alert.alert('오류', error.message || '회원가입에 실패했습니다.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      {/* 헤더 */}
      <View style={styles.header}>
        <TouchableOpacity onPress={onBack}>
          <Text style={styles.backButton}>←</Text>
        </TouchableOpacity>
        <Text style={styles.headerTitle}>업주 회원가입</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} showsVerticalScrollIndicator={false}>
        {/* 안내 메시지 */}
        <View style={styles.infoBox}>
          <Text style={styles.infoIcon}>📋</Text>
          <Text style={styles.infoText}>
            업체 정보를 입력하시면 관리자 승인 후{'\n'}서비스를 이용하실 수 있습니다.
          </Text>
        </View>

        {/* 로그인 정보 */}
        <Text style={styles.sectionTitle}>로그인 정보</Text>

        <Text style={styles.label}>이메일 *</Text>
        <TextInput
          style={styles.input}
          value={email}
          onChangeText={setEmail}
          placeholder="store@example.com"
          placeholderTextColor="#999"
          keyboardType="email-address"
          autoCapitalize="none"
        />

        <Text style={styles.label}>비밀번호 *</Text>
        <TextInput
          style={styles.input}
          value={password}
          onChangeText={setPassword}
          placeholder="6자 이상"
          placeholderTextColor="#999"
          secureTextEntry
        />

        <Text style={styles.label}>비밀번호 확인 *</Text>
        <TextInput
          style={styles.input}
          value={passwordConfirm}
          onChangeText={setPasswordConfirm}
          placeholder="비밀번호 재입력"
          placeholderTextColor="#999"
          secureTextEntry
        />

        {/* 업체 정보 */}
        <Text style={styles.sectionTitle}>업체 정보</Text>

        <Text style={styles.label}>업체명 *</Text>
        <TextInput
          style={styles.input}
          value={storeName}
          onChangeText={setStoreName}
          placeholder="예: 투굿 베이커리"
          placeholderTextColor="#999"
        />

        <Text style={styles.label}>카테고리 *</Text>
        <View style={styles.categoryContainer}>
          {categories.map((cat) => (
            <TouchableOpacity
              key={cat}
              style={[
                styles.categoryButton,
                storeCategory === cat && styles.categoryButtonActive,
              ]}
              onPress={() => setStoreCategory(cat)}
            >
              <Text
                style={[
                  styles.categoryText,
                  storeCategory === cat && styles.categoryTextActive,
                ]}
              >
                {cat}
              </Text>
            </TouchableOpacity>
          ))}
        </View>

        <Text style={styles.label}>대표자명 *</Text>
        <TextInput
          style={styles.input}
          value={ownerName}
          onChangeText={setOwnerName}
          placeholder="홍길동"
          placeholderTextColor="#999"
        />

        <Text style={styles.label}>연락처 *</Text>
        <TextInput
          style={styles.input}
          value={phone}
          onChangeText={setPhone}
          placeholder="010-1234-5678"
          placeholderTextColor="#999"
          keyboardType="phone-pad"
        />

        <Text style={styles.label}>사업자등록번호 *</Text>
        <TextInput
          style={styles.input}
          value={businessNumber}
          onChangeText={setBusinessNumber}
          placeholder="000-00-00000"
          placeholderTextColor="#999"
          keyboardType="numeric"
        />

        <Text style={styles.label}>주소 *</Text>
        <TextInput
          style={[styles.input, styles.textArea]}
          value={address}
          onChangeText={setAddress}
          placeholder="서울시 강남구 테헤란로 123"
          placeholderTextColor="#999"
          multiline
          numberOfLines={2}
        />

        {/* 가입하기 버튼 */}
        <TouchableOpacity
          style={styles.submitButton}
          onPress={handleSignup}
          disabled={loading}
        >
          {loading ? (
            <ActivityIndicator size="small" color="#FFF" />
          ) : (
            <Text style={styles.submitButtonText}>가입하기</Text>
          )}
        </TouchableOpacity>

        {/* 안내사항 */}
        <View style={styles.noticeBox}>
          <Text style={styles.noticeTitle}>📢 안내사항</Text>
          <Text style={styles.noticeText}>• 가입 후 1-2일 내 승인 처리됩니다.</Text>
          <Text style={styles.noticeText}>
            • 승인 완료 시 이메일로 안내드립니다.
          </Text>
          <Text style={styles.noticeText}>• 서비스 이용 전 캐시 충전이 필요합니다.</Text>
        </View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#F5F5F5',
  },

  // 헤더
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#FFF',
    paddingHorizontal: 20,
    paddingTop: 50,
    paddingBottom: 15,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  backButton: {
    fontSize: 28,
    color: '#333',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
  },

  // 스크롤뷰
  scrollView: {
    flex: 1,
    paddingHorizontal: 20,
    paddingTop: 20,
  },

  // 안내 박스
  infoBox: {
    backgroundColor: '#E8F5E9',
    padding: 16,
    borderRadius: 12,
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 20,
    gap: 12,
  },
  infoIcon: {
    fontSize: 24,
  },
  infoText: {
    flex: 1,
    fontSize: 14,
    color: '#00A84D',
    lineHeight: 20,
  },

  // 섹션
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#333',
    marginTop: 20,
    marginBottom: 15,
  },

  // 라벨
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#333',
    marginBottom: 8,
  },

  // 입력 필드
  input: {
    backgroundColor: '#FFF',
    borderRadius: 12,
    padding: 16,
    fontSize: 15,
    color: '#333',
    borderWidth: 1,
    borderColor: '#E0E0E0',
    marginBottom: 15,
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },

  // 카테고리 선택
  categoryContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 10,
    marginBottom: 15,
  },
  categoryButton: {
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderRadius: 20,
    backgroundColor: '#FFF',
    borderWidth: 1,
    borderColor: '#E0E0E0',
  },
  categoryButtonActive: {
    backgroundColor: '#00D563',
    borderColor: '#00D563',
  },
  categoryText: {
    fontSize: 14,
    color: '#666',
    fontWeight: '500',
  },
  categoryTextActive: {
    color: '#FFF',
    fontWeight: '600',
  },

  // 제출 버튼
  submitButton: {
    backgroundColor: '#00D563',
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
    marginTop: 10,
    marginBottom: 20,
  },
  submitButtonText: {
    color: '#FFF',
    fontSize: 16,
    fontWeight: '600',
  },

  // 안내사항
  noticeBox: {
    backgroundColor: '#FFF4E5',
    padding: 16,
    borderRadius: 12,
    marginBottom: 20,
  },
  noticeTitle: {
    fontSize: 15,
    fontWeight: '600',
    color: '#333',
    marginBottom: 10,
  },
  noticeText: {
    fontSize: 13,
    color: '#666',
    marginBottom: 4,
    lineHeight: 18,
  },
});
</file>

<file path="app/tsconfig.json">
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "**/*.ts",
    "**/*.tsx",
    ".expo/types/**/*.ts",
    "expo-env.d.ts"
  ]
}
</file>

<file path="CLAUDE.md">
# 팀장 에이전트 (Team Leader)

당신은 앱/웹 서비스 개발 프로젝트의 **팀장**입니다. 사용자와 직접 소통하며, 팀원들(서브에이전트와 스킬)을 조율하여 프로젝트를 성공적으로 이끕니다.

## 핵심 원칙

1. **깊이 있는 사고 (Ultra Think)**: 모든 결정과 작업에서 깊이 생각하고 최선의 방안을 도출합니다.
2. **바이브 코딩**: 사용자가 직접 코딩하지 않습니다. 모든 개발은 팀이 수행합니다.
3. **주도적 대화**: 필요한 정보를 능동적으로 확보하고, 명확한 방향을 제시합니다.

## 팀장의 역할

### 1. 프로젝트 관리
- 전체 업무 계획 수립 및 요구사항 파악
- 업무 분담 및 일정 계획
- 팀원들의 아웃풋 취합 및 정리, 아웃풋을 적절히 활용
- 사용자에게 진행 상황 보고
- 매 프로젝트와 작업 수행 시, 필요한 MCP 또는 extend 등 기술이 필요할 경우 사용자에 요청하여 이를 셋업할 수 잇도록 함

### 2. 팀원 조율
필요에 따라 적절한 팀원을 호출하여 작업을 위임합니다:

#### 서브에이전트 (복잡한 작업)
- **prd-agent**: PRD(제품 요구사항 정의서) 작성
- **ux-ui-agent**: 고객 여정 및 사용자 시나리오 설계
- **trd-agent**: 기술명세서(TRD) 작성
- **tdd-agent**: 테스트 주도 개발, 코드 품질 검증

#### 스킬 (정형화된 문서/작업)
- **api-spec**: API 명세서 작성
- **erd**: ERD(엔티티 관계 다이어그램) 작성
- **ia-db**: IA 점검 보고서 및 DB 스키마 설계
- **test-plan**: 테스트 계획서 작성
- **deploy-strategy**: 배포 전략 수립
- **create-agent**: 새로운 서브에이전트/스킬 생성
- **supabase-helper**: Supabase DB 관리 (테이블, RLS, 함수, 마이그레이션)
- **frontend-design**: 고품질 UI 디자인 (React Native/Expo 최적화)
- **webapp-testing**: Playwright 기반 웹앱 테스트 (Expo 웹 빌드 테스트)

### 3. 개발 및 테스트 수행
- 실제 서비스 개발의 주체로서 코드 작성
- TDD 에이전트와 협력하여 품질 확보
- 테스트가 워크플로우의 표준으로 실행되도록 관리
- 작업 완료 후 테스트 항목을 리스트업해서 파일로 저장 및 관리하며, 이를 이후 지속 업데이트 한다. 프로젝트 시작 시 사전에 테스트 방법을 구체화하며, 이에 필요한 인프라와 리소스를 갖출 수 있도록 사용자와 논의한다. 예로, 플러터로 개발하는 경우 웹으로 빌드 및 크롬에서 실행하여 puppeteer MCP로 테스트할 수 있는데, 이와 같이 해당 프로젝트의 내용과 성격에 맞춰 자동 테스트 진행할 수 있도록 한다. 테스트 시에는 모든 버그에 대해 side effect를 고려하여 신중히 수정하며, 리스트업한 테스트 항목들이 모두 문제 없도록 한 뒤 사용자에게 아웃풋을 산출한다. 이 과정에서 반복하는 유사한 또는 동일한 문제들을 별도 파일로 관리하여, 해당 개발 진행 시 해당 파일을 참고할 수 있도록 한다.
- 개발 업무를 수행하거나, tdd-agent에 업무를 할당할 때 절대 API키는 하드코딩하지 않도록 하며, 민감한 정보는 로그에 남기지 않는다.
- 비전공자인 사용자가 이해 및 활용하기 용이하도록 주석 / 체계 등에 신경쓴다.

### 4. 세션 관리
- 작업 중 세션 사용량이 한계에 도달할 것으로 예상되면:
  - 작업을 분할하여 계획
  - 중단 전 가능한 만큼의 아웃풋 제공
  - 다음 세션에서 이어서 진행할 수 있도록 상태 저장

### 5. 무료 프로그램 이용 검토.
 - 데이터베이스 및 백엔드 부문에서는, supabase사용을 우선적으로 검토
 - 호스팅 및 배포 부문에서는, Vercel사용을 우선적으로 검토
 - 이메일 및 커뮤니케이션 부문에서는, Resend사용을 우선적으로 검토
 - 분석 부문에서는, posthog사용을 우선적으로 검토

### 6. 컨텍스트 관리 (중요!)
대화 중 다음 상황을 **상시 모니터링**하고 사용자에게 **선제적으로 제안**합니다:

#### /compact 제안 시점
- 대화가 길어져 응답 속도가 느려질 때
- 같은 주제로 10회 이상 대화가 오갔을 때
- 이전 대화 내용이 현재 작업과 관련 없어졌을 때
- "컨텍스트가 커지고 있습니다" 등의 시스템 메시지가 보일 때

#### /clear 제안 시점
- 하나의 큰 작업이 완전히 끝났을 때
- 완전히 새로운 주제/작업을 시작할 때
- 이전 대화 내용이 더 이상 필요 없을 때
- 오류가 누적되어 깨끗하게 시작하는 게 나을 때

#### 제안 형식
```
💡 **세션 관리 제안**: /compact 실행을 권장합니다.
- 이유: [구체적 이유]
- 현재 작업 상태: [요약]
```

**주의**: 이 제안은 사용자의 별도 요청 없이도 적극적으로 수행합니다.

## 프로젝트 아웃풋 (1~8번)

프로젝트 진행 시 다음 산출물을 순차적으로 도출합니다:

1. **PRD**: 제품 비전, 목표, 핵심 기능, 타겟 사용자, 비기능적 요구사항
2. **고객 여정 & 사용자 시나리오**: UI/UX 설계, 디자인 원칙, 컴포넌트 구조
3. **TRD**: 아키텍처, 기술 스택, 보안, 코드 가이드라인
4. **API 명세**: 엔드포인트, 데이터 모델, 인증 방식
5. **ERD**: 엔티티 관계 다이어그램
6. **IA & DB 설계**: 점검 보고서, DB 테이블 플로우, 스키마
7. **테스트 계획**: 유닛/통합/API 테스트, 에러/엣지 케이스
8. **배포 전략**: 인프라, 모니터링, 롤백 계획

## 기술 스택 (기본값)

- **프론트엔드**: React, Next.js
- **테스트**: Jest, React Testing Library (또는 프로젝트에 적합한 도구)
- **하이브리드 앱**: 필요시 React Native 또는 Capacitor 검토

## 커뮤니케이션 스타일

- 명확하고 구조화된 응답 제공
- 진행 상황을 단계별로 보고
- 결정이 필요한 사항은 옵션과 함께 제시
- 문제 발생 시 원인과 해결 방안 함께 제시

## 작업 시작 시

1. 사용자의 요구사항을 명확히 파악
2. 필요한 정보가 부족하면 질문
3. 작업 계획 수립 및 공유
4. 적절한 팀원 호출하여 작업 진행
5. 결과물 취합 및 정리하여 보고
</file>

<file path="docs/PROJECT-ANALYSIS-REPORT.md">
# 프로젝트 현황 분석 보고서

> **작성일**: 2026-01-16
> **프로젝트명**: 재고 할인 중개 플랫폼 (투굿투고 유사 서비스)
> **분석 대상**: GitHub 저장소, 실제 프로젝트 폴더, Word 문서

---

## 1. 프로젝트 개요

### 1.1 비즈니스 모델
- **목적**: 음식물 낭비 감소 + 소비자 할인 혜택 제공
- **수익 모델**: 업체 캐시 선결제 → 픽업 완료 시 15~20% 수수료 차감
- **결제 방식**: 소비자는 업체에서 현장 결제 (카드/현금/이체)

### 1.2 사용자 유형
| 유형 | 역할 | 구현 상태 |
|------|------|----------|
| 소비자 | 할인 상품 검색, 예약, 리뷰 | ✅ 완료 |
| 업주 | 상품 등록, 예약 관리, 캐시 관리 | ✅ 완료 |
| 운영자 | 전체 관리, 클레임 처리 | ❌ 미구현 |

### 1.3 기술 스택
| 영역 | 기술 | 버전 |
|------|------|------|
| Frontend | React Native + Expo | SDK 54, RN 0.81.5 |
| Language | TypeScript | 5.9.2 |
| Backend | Supabase (PostgreSQL) | Latest |
| Authentication | Supabase Auth | JWT |
| 예정 | 토스페이먼츠, 카카오맵 | 미연동 |

---

## 2. 현재 프로젝트 구조

### 2.1 실제 프로젝트 위치
```
C:\Users\user\OneDrive\바탕 화면\투굿투고\myapp\
```

### 2.2 폴더 구조
```
myapp/
├── App.tsx                    # 메인 앱 (통합 네비게이션)
├── app.json                   # Expo 설정
├── package.json               # 의존성
├── .env                       # 환경변수 (Supabase)
├── src/
│   ├── lib/
│   │   └── supabase.ts       # Supabase 클라이언트
│   ├── screens/              # 27개 화면 파일
│   │   ├── LoginScreen.tsx
│   │   ├── ConsumerSignupScreen.tsx
│   │   ├── StoreSignupScreen.tsx
│   │   ├── StoreListHome.tsx
│   │   ├── StoreDetail.tsx
│   │   ├── ReservationScreen.tsx
│   │   ├── MyReservations.tsx
│   │   ├── ReviewScreen.tsx
│   │   ├── MyPageScreen.tsx
│   │   ├── StoreDashboard.tsx
│   │   ├── StoreProductManagement.tsx
│   │   ├── StoreCashManagement.tsx
│   │   ├── StoreReservationManagement.tsx
│   │   ├── StoreReviewManagement.tsx
│   │   └── ... (기타)
│   └── components/           # 공통 컴포넌트
├── assets/                   # 정적 파일
└── node_modules/
```

### 2.3 GitHub 저장소
- **초기 브랜치**: `claude/marketplace-architecture-design-bbYHF`
- **최신 브랜치**: `claude/continue-platform-dev-GZurO`
- **내용**: 주로 문서와 가이드, 코드 예제 (실행 가능한 프로젝트 아님)

---

## 3. 구현 현황

### 3.1 완료된 기능 (문서 기준 MVP 90%)

#### 소비자 기능
| 기능 | 파일 | 상태 |
|------|------|------|
| 로그인 | LoginScreen.tsx | ✅ |
| 소비자 회원가입 | ConsumerSignupScreen.tsx | ✅ |
| 업체 리스트 | StoreListHome.tsx | ✅ |
| 업체 상세 | StoreDetail.tsx | ✅ |
| 예약하기 | ReservationScreen.tsx | ✅ |
| 예약 내역 | MyReservations.tsx | ✅ |
| 리뷰 작성 | ReviewScreen.tsx | ✅ |
| 마이페이지 | MyPageScreen.tsx | ✅ |

#### 업주 기능
| 기능 | 파일 | 상태 |
|------|------|------|
| 업주 회원가입 | StoreSignupScreen.tsx | ✅ |
| 대시보드 | StoreDashboard.tsx | ✅ |
| 상품 관리 | StoreProductManagement.tsx | ✅ |
| 캐시 관리 | StoreCashManagement.tsx | ✅ |
| 캐시 내역 | StoreCashHistory.tsx | ✅ |
| 예약 관리 | StoreReservationManagement.tsx | ✅ |
| 리뷰 관리 | StoreReviewManagement.tsx | ✅ |
| 업체 정보 | StoreInfoManagement.tsx | ✅ |
| 단골 고객 | StoreRegularCustomers.tsx | ✅ |

### 3.2 미구현 기능

| 기능 | 우선순위 | 비고 |
|------|----------|------|
| 지도 기반 탐색 | 높음 | 카카오/구글 맵 연동 필요 |
| 실결제 연동 | 높음 | 토스페이먼츠 연동 필요 |
| 푸시 알림 | 중간 | Expo Push, 카카오 알림톡 |
| 운영자 대시보드 | 중간 | 전체 관리 기능 |
| 소셜 로그인 | 낮음 | 카카오, 구글 |
| 즐겨찾기 | 낮음 | 업체 즐겨찾기 |
| 검색 기능 | 중간 | 업체/상품 검색 |

---

## 4. 발견된 문제점

### 4.1 코드 관리 문제

#### 문제 1: 코드 분산
```
- 실제 앱: C:\...\투굿투고\myapp\
- GitHub: 문서와 가이드만 저장
- 코드 동기화 방식: 수동 복사-붙여넣기
```

**위험**: 버전 관리 어려움, 코드 유실 가능성

#### 문제 2: 중복 파일
```
GitHub 저장소 내:
- StoreProductManagement.tsx
- StoreProductManagement-FIXED.tsx
- StoreProductManagement-NEW.tsx
- StoreProductManagement-WITH-IMAGE.tsx
```

**위험**: 어떤 파일이 최신인지 혼란

#### 문제 3: 테스트 부재
- 자동화된 테스트 없음
- 수동 Expo 테스트만 진행
- 품질 보증 체계 없음

### 4.2 아키텍처 문제

#### 문제 4: 네비게이션 구조
- Expo Router 미사용 (파일 기반 라우팅 X)
- App.tsx에서 수동 상태 관리로 화면 전환
- 확장성 제한

#### 문제 5: 상태 관리
- 전역 상태 관리 라이브러리 없음
- useState로만 관리
- 복잡한 상태 흐름 어려움

---

## 5. 경쟁사 분석 인사이트 (Word 문서 기반)

### 5.1 주요 경쟁사
| 서비스 | 특징 | 참고 포인트 |
|--------|------|------------|
| Too Good To Go | 글로벌, 서프라이즈 백 | 지구 보호 메시지 |
| 럭키밀 | 50%+ 할인, Bubble MVP | 선물/행운 브랜딩 |
| 마감 히어로 | 30초 상품 등록 | 매장 추천 버튼 |
| 라스트 오더 | 실재고 미연동 문제 | 반면교사 |

### 5.2 핵심 교훈 (라스트 오더 리뷰 분석)
1. **재고 신뢰**: 결제 전 재고 확정 필수
2. **가격 신뢰**: 정가 증빙 필요
3. **품질 기준**: D-몇일, 제조일 표시 의무
4. **환불 신속**: 자동 환불 (수동 CS 배제)
5. **픽업 전용**: 배송 확장은 나중에

---

## 6. 요구사항 vs 구현 갭 분석

### 6.1 소비자 시나리오 매칭

| 요구사항 (Word) | 구현 상태 | 갭 |
|----------------|----------|-----|
| 거리순 업체 리스트 | ✅ | - |
| 지도 기반 탐색 | ❌ | 지도 API 연동 필요 |
| 즐겨찾기 | ❌ | 미구현 |
| 예약 시 수량 차감 | ✅ | - |
| 60분 내 예약 취소 | ❓ | 확인 필요 |
| 픽업 완료 버튼 | ✅ | - |
| 누적 절약 금액 | ❓ | 확인 필요 |
| 알림 구독 | ❌ | 미구현 |

### 6.2 업주 시나리오 매칭

| 요구사항 (Word) | 구현 상태 | 갭 |
|----------------|----------|-----|
| 상품 등록 (정가/할인가/수량) | ✅ | - |
| 제조일/소비기한 자동 설정 | ❓ | 확인 필요 |
| 예약 취소 조건 (30분/2시간 규칙) | ❓ | 확인 필요 |
| 캐시 충전 | ✅ | 실결제 미연동 |
| 캐시 1만원 미만 시 비활성화 | ❓ | 확인 필요 |
| 영업시간 외 비활성화 | ❓ | 확인 필요 |

---

## 7. 권장 조치

### 7.1 즉시 조치 (1단계)

1. **프로젝트 통합**
   - 실제 앱 코드를 이 작업 폴더로 이동
   - Git으로 버전 관리 시작
   - 중복 파일 정리

2. **문서 체계화**
   - PRD 정리 (요구사항 문서)
   - TRD 정리 (기술 문서)
   - API 명세 정리

3. **테스트 환경 구축**
   - 테스트 계정 생성
   - 기본 테스트 시나리오 작성

### 7.2 단기 조치 (2단계)

1. **코드 리팩토링**
   - 네비게이션 구조 개선 (Expo Router 적용 검토)
   - 상태 관리 라이브러리 도입 (Zustand 권장)
   - 공통 컴포넌트 분리

2. **핵심 기능 완성**
   - 지도 연동 (카카오맵)
   - 결제 연동 (토스페이먼츠)
   - 알림 시스템

### 7.3 장기 조치 (3단계)

1. **운영자 기능**
2. **성능 최적화**
3. **테스트 자동화**

---

## 8. 다음 단계

팀장으로서 다음 순서로 진행할 것을 제안합니다:

1. **프로젝트 통합**: 실제 앱 코드를 현재 작업 폴더로 이동
2. **PRD 정리**: PRD 에이전트 호출하여 요구사항 문서화
3. **TRD 정리**: TRD 에이전트 호출하여 기술 문서화
4. **테스트 환경 구축**: TDD 에이전트와 협력하여 테스트 체계 수립
5. **개발 재개**: 미구현 기능 순차적 개발

---

**다음 액션**: 사용자 확인 후 프로젝트 통합 진행
</file>

</files>
